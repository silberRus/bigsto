
#Область ПрограммныйИнтерфейс

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  Неотрицательный - Булево, если Истина, то числа только положительные, если Ложь, то любые.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти, Неотрицательный = Ложь) Экспорт
	
	Если Неотрицательный Тогда
		Знак = ДопустимыйЗнак.Неотрицательный;
	Иначе
		Знак = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак));

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Дополняет одну таблицу значений строками другой таблицы значений
//
// Параметры:
//	Приемник			- произвольная коллекция, в которую добавляются строки
//	Источник 			- произвольная коллекция, из которой беруться добавляемые строки
//	СоответствиеПолей	- Соответствие - используется чтобы заполнить поля с разными названиями, 
//										ключ содержит имя поля приемника, значение содержит имя поля источника
//
Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник, СоответствиеПолей = Неопределено) Экспорт

	Для каждого СтрокаИсточника Из Источник Цикл
		НоваяСтрока = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточника);
		Если СоответствиеПолей <> Неопределено Тогда
			Для каждого КлючИЗначение Из СоответствиеПолей Цикл
				НоваяСтрока[КлючИЗначение.Ключ] = СтрокаИсточника[КлючИЗначение.Значение];
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

// Заполняет колонку таблицы значений последовательными номерами
//
// Параметры:
//	Таблица - таблица значений, строки которой нужно пронумеровать
//	ИмяКолонкиНомераСтроки - колонка таблицы значений, в которой будут указаны номера строк
//
Процедура ПронумероватьТаблицуЗначений(Таблица, ИмяКолонкиНомераСтроки) Экспорт

	Если Таблица.Колонки.Найти(ИмяКолонкиНомераСтроки) = Неопределено Тогда
		Таблица.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));
	КонецЕсли;

	КоличествоСтрок = Таблица.Количество() - 1;
	Для НомерСтроки = 0 По КоличествоСтрок Цикл
		Таблица[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	КонецЦикла;

КонецПроцедуры

// Выгружает таблицу значений из ДанныеФормыКоллекция и ТабличнаяЧасть
//
// Параметры:
// 		ТаблицаИсточник - ДанныеФормыКоллекция, ТабличнаяЧасть - Таблица источник выгрузки
// 		Строки - Массив, Структура - Массив строк для выгрузки или структура отбора
// 		Колонки - Строка - Перечисленные через запятую имена колонок для выгрузки
// 		КолонкиПоЗначению - Структура - Структура колонок для добавление в результирующую таблицу:
// 										Ключ - Имя новой колонки
// 										Значение - Значение для подстановки по все строки новой колонки
// 		НовыеИменаКолонок - Структура - Структура с данными о переименовании колонок в результирующей таблице:
// 										Ключ - Текущее имя колонки
// 										Значение - Новое имя колонки
//
// Возвращаемое значение:
// 		ТаблицаЗначений - Таблица результат выгрузки из таблицы источника с добавленными и переименоваными колонками
//
Функция ВыгрузитьТаблицуЗначений(ТаблицаИсточник, Строки = Неопределено, Колонки = "НомерСтроки",
			Знач КолонкиПоЗначению = Неопределено, Знач НовыеИменаКолонок = Неопределено) Экспорт
	
	// Определение значений по умолчанию
	Если КолонкиПоЗначению = Неопределено Тогда
		КолонкиПоЗначению = Новый Структура;
	КонецЕсли;
	Если НовыеИменаКолонок = Неопределено Тогда
		НовыеИменаКолонок = Новый Структура;
	КонецЕсли;
	
	// Определить список выгружаемых колонок
	СтруктураДругихИменКолонок = Новый Структура;
	Для Каждого НовоеИмя Из НовыеИменаКолонок Цикл
		СтруктураДругихИменКолонок.Вставить(НовоеИмя.Значение, НовоеИмя.Ключ);
	КонецЦикла;
	ИменаКолонок = "";
	ИмяКолонки = "";
	СтруктураКолонок = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураКолонок Цикл
		Если Не СтруктураДругихИменКолонок.Свойство(Колонка.Ключ, ИмяКолонки) Тогда
			ИмяКолонки = Колонка.Ключ;
		КонецЕсли;
		Если Не КолонкиПоЗначению.Свойство(ИмяКолонки) Тогда
			ИменаКолонок = ИменаКолонок + ", " + ИмяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	// Выгрузить из таблицы источника
	Если ТипЗнч(ТаблицаИсточник) = Тип("ТаблицаЗначений") Тогда
		ТаблицаРезультата = ТаблицаИсточник.Скопировать(Строки, Сред(ИменаКолонок, 3));
	Иначе
		ТаблицаРезультата = ТаблицаИсточник.Выгрузить(Строки, Сред(ИменаКолонок, 3));
	КонецЕсли;
	
	// Добавить новые колонки в таблицу результата
	Если КолонкиПоЗначению <> Неопределено Тогда
		Для Каждого Колонка Из КолонкиПоЗначению Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Колонка.Значение));
			ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ, Новый ОписаниеТипов(МассивТипов));
			ТаблицаРезультата.ЗаполнитьЗначения(Колонка.Значение, Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	// Переименовать колонки в таблице результата
	Если НовыеИменаКолонок <> Неопределено Тогда
		Для Каждого Колонка Из НовыеИменаКолонок Цикл
			ТаблицаРезультата.Колонки[Колонка.Ключ].Имя = Колонка.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции // ВыгрузитьТаблицуЗначений()

// Процедура делает запись в журнал регистрации и сообщает пользователю, если это сообщение об ошибке 
// Параметры:
//   ПараметрыЖурнала - Структура - параметры записи в журнал регистрации
//			Свойства:
//       		ГруппаСобытий - Строка - префикс для имени события журнала регистрации
//       		Метаданные - ОбъектМетаданных - метаданные для записи в журнал регистрации
//       		Данные - Произвольный - данные для записи в журнал регистрации
//   ИмяСобытия - Строка  - имя события (в журнал событие записывается в формате ГруппаСобытий.ИмяСобытия)
//   Уровень - УровеньЖурналаРегистрации  - Соответствует уровням журнала регистрации
//   Комментарий - Строка - комментарий о событии
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Строка - Информация об ошибке, которую так же необходимо задокументировать в комментарии журнала регистрации
//
Процедура ЗаписатьВЖурналСообщитьПользователю(ПараметрыЖурнала, УровеньЖурнала, ИмяСобытия, Знач Комментарий = "", ИнформацияОбОшибке = Неопределено) Экспорт
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Если Комментарий = "" Тогда
			ТестСообщенияПользователю = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Иначе
			ТестСообщенияПользователю = Комментарий + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = Комментарий + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Строка") 
			И Не ПустаяСтрока(ИнформацияОбОшибке) Тогда
			Комментарий = Комментарий + Символы.ПС + ИнформацияОбОшибке;
		КонецЕсли;
		ТестСообщенияПользователю = Комментарий;
	КонецЕсли;
	
	// Журнал регистрации 
	УстановитьПривилегированныйРежим(Истина);
	ЗаписьЖурналаРегистрации(
	    СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			ПараметрыЖурнала.ГруппаСобытий + ?(ИмяСобытия = "", "", "." + ИмяСобытия)),
		УровеньЖурнала, 
		ПараметрыЖурнала.Метаданные, 
		ПараметрыЖурнала.Данные, 
		Комментарий);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка 
		Или УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СокрЛП(ТестСообщенияПользователю),ПараметрыЖурнала.Данные);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта
//
//	Параметры:
//		Объект - Произвольный - объект, для которого нужно получить ключ данных
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если СтрНайти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

// Вызывается из подписки ЗаполнитьРеквизитыОбъекта
// Проверет заполненность реквизитов формы, связанных с фукциональными опциями
// ИспользоватьНесколькоОрганизаций, ИспользоватьНесколькоСкладов, ИспользоватьНесколькоВалют
//
//	Параметры:
//		Объект - Произвольный - объект
//		ДанныеЗаполнения - Структура
//		СтандартнаяОбработка - Структура
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы
//
Процедура ОбработкаЗаполнения(Объект, ДанныеЗаполнения, СтандартнаяОбработка) Экспорт
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизаций")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Организация")
		И Не ЗначениеЗаполнено(Объект.Организация) Тогда
		Объект.Организация = ЗначениеНастроекПовтИсп.ПолучитьОрганизациюПоУмолчанию(Объект.Организация);
		Если Не ЗначениеЗаполнено(Объект.Организация) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Организации.Ссылка
			|ИЗ
			|	Справочник.Организации КАК Организации");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Организация"". В информационной базе введено несколько организаций,
				|Включите опцию ""НСИ и администрирование""-""Предприятие""-""Несколько организаций""!'");
			Иначе
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Организация"". Возможно, в информационной базе не введено ни одной организации!
				|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Сведения об организации"".'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоСкладов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Склад")
		И Не ЗначениеЗаполнено(Объект.Склад) Тогда
		Объект.Склад = ЗначениеНастроекПовтИсп.ПолучитьСкладПоУмолчанию(Объект.Склад);
		Если Не ЗначениеЗаполнено(Объект.Склад) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Склады.Ссылка
			|ИЗ
			|	Справочник.Склады КАК Склады");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". В информационной базе введено несколько складов,
				|Включите опцию ""НСИ и администрирование""-""Склад и доставка""-""Несколько складов""!'");
			Иначе
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". Возможно, в информационной базе не введено ни одного склада
				|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка складского учета"".'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Валюта")
		И Не ЗначениеЗаполнено(Объект.Валюта) Тогда
		Объект.Валюта = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.Валюта);
		Если Не ЗначениеЗаполнено(Объект.Валюта) Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Валюта"". Установите валюту управленческого учета!'");
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "ВалютаВзаиморасчетов")
		И Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
		Объект.ВалютаВзаиморасчетов = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.ВалютаВзаиморасчетов);
		Если Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""ВалютаВзаиморасчетов"". Установите валюту управленческого учета!'");
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоКасс")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Касса")
		И Не ЗначениеЗаполнено(Объект.Касса) Тогда
		
		Если Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь Тогда
			// Не требуется заполнение кассы при не включенной опции "ИспользоватьНесколькоКасс"
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияКассыОрганизацииПоУмолчанию();
			СтруктураПараметров.Касса 			= Объект.Касса;
			Объект.Касса = ЗначениеНастроекПовтИсп.ПолучитьКассуОрганизацииПоУмолчанию(СтруктураПараметров);
			Если Не ЗначениеЗаполнено(Объект.Касса) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	Кассы.Ссылка
				|ИЗ
				|	Справочник.Кассы КАК Кассы
				|ГДЕ
				|	НЕ Кассы.ПометкаУдаления");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". В информационной базе введено несколько касс,
					|Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько касс""!'");
				Иначе
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". Возможно, в информационной базе не введено ни одной кассы!
					|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка кассы"".'");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоРасчетныхСчетов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "БанковскийСчет")
		И Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
		
		Если Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь Тогда
			// Не требуется заполнение расчетного счета при не включенной опции "ИспользоватьНесколькоРасчетныхСчетов"
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияБанковскогоСчетаОрганизацииПоУмолчанию();
			СтруктураПараметров.БанковскийСчет = Объект.БанковскийСчет;  
			Объект.БанковскийСчет = ЗначениеНастроекПовтИсп.ПолучитьБанковскийСчетОрганизацииПоУмолчанию(СтруктураПараметров);
			
			Если Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	БанковскиеСчетаОрганизаций.Ссылка
				|ИЗ
				|	Справочник.БанковскиеСчетаОрганизаций КАК БанковскиеСчетаОрганизаций");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". В информационной базе введено несколько банковских счетов организаций,
					|Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько банковских счетов""!'");
				Иначе
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". Возможно, в информационной базе не введено ни одного банковского счета организации!
					|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка банковского счета"".'");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет уникальный идентификатор платежа
Функция ПолучитьУникальныйИдентификаторПлатежа(Объект) Экспорт
	
	Префикс = ПолучитьПерфиксДляУИП(Объект.Ссылка);
	Дата = Формат(Объект.Дата, "ДФ=yyMM");
	Номер = СтрЗаменить(Объект.Номер, "-", "");
	Код = Строка(Префикс) + Строка(Дата) + Строка(Номер);
	УИН = ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код);
	
	Возврат УИН;
	
КонецФункции

// Функция возвращает изменения документа, относительно записанного в базе
// 
// Параметры:
// 	Объект - ДокументОбъект - Документ, измение которого необходимо проанализировать
// 	РеквизитыИсключения - Структура - Структура имен реквизитов, изменение которых проверять не требуется
// 	ТабличныеЧастиИсключения - Структура - Структура имен табличных частей, изменение которых проверять не требуется
//
// Возвращаемое значение:
// 	Структура - Структура - Содержит изменения объекта:
// 								- по ключу "Реквизиты" - таблица измененных реквизитов
// 								- по ключу "ТабличныеЧасти" - структура низменных табличных частей
Функция ИзмененияДокумента(Объект, РеквизитыИсключения = Неопределено, ТабличныеЧастиИсключения = Неопределено) Экспорт
	
	Результат = Новый Структура;
	
	Если РеквизитыИсключения = Неопределено Тогда
		РеквизитыИсключения = Новый Структура;
	КонецЕсли;
	
	Если ТабличныеЧастиИсключения = Неопределено Тогда
		ТабличныеЧастиИсключения = Новый Структура;
	КонецЕсли;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	ПолноеИмя = МетаданныеДокумента.ПолноеИмя();
	
	СтрокаНеограниченнойДлинны = Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(0));
	
	РеквизитыДокумента = Новый Структура;
	РеквизитыДокумента.Вставить("Дата");
	Для каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		Если СтрНайти(Реквизит.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
			Продолжить;
		КонецЕсли;
		Если РеквизитыИсключения.Свойство(Реквизит.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыДокумента.Вставить(Реквизит.Имя);
	КонецЦикла;
	
	ТабличныеЧастиДокумента = Новый Структура;
	Для каждого ТабличнаяЧасть Из МетаданныеДокумента.ТабличныеЧасти Цикл
		Если СтрНайти(ТабличнаяЧасть.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если ТабличныеЧастиИсключения.Свойство(ТабличнаяЧасть.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыТабличнойЧасти = Новый Структура;
		Для каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
			Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
				Продолжить;
			КонецЕсли; 
			РеквизитыТабличнойЧасти.Вставить(Реквизит.Имя);
		КонецЦикла;
		ТабличныеЧастиДокумента.Вставить(ТабличнаяЧасть.Имя, РеквизитыТабличнойЧасти);
	КонецЦикла;
	
	ТекстЗапроса= "ВЫБРАТЬ
		|	Таблица.Проведен КАК Проведен";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ); 
	КонецЦикла;
	
	ШаблонПоместить = "
	|ИЗ
	|	%1 КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|";
	ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ПолноеИмя);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий(); 
	
	ТаблицаИзмененыхРеквизитов = Новый ТаблицаЗначений;
	ТаблицаИзмененыхРеквизитов.Колонки.Добавить("Имя");
	ТаблицаИзмененыхРеквизитов.Колонки.Добавить("НовоеЗначение");
	ТаблицаИзмененыхРеквизитов.Колонки.Добавить("СтароеЗначение");
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		Если Выборка[Реквизит.Ключ] <> Объект[Реквизит.Ключ] Тогда
			НоваяСтрока = ТаблицаИзмененыхРеквизитов.Добавить();
			НоваяСтрока.Имя = Реквизит.Ключ;
			НоваяСтрока.НовоеЗначение = Объект[Реквизит.Ключ];
			НоваяСтрока.СтароеЗначение = Выборка[Реквизит.Ключ];
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаИзмененыхРеквизитов.Количество() > 0 Тогда
		Результат.Вставить("Реквизиты", ТаблицаИзмененыхРеквизитов);
	КонецЕсли;
	
	Для каждого ТабличнаяЧасть Из ТабличныеЧастиДокумента Цикл
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонПоместить = "
		|ПОМЕСТИТЬ НоваяТаблица%1
		|ИЗ
		|	&%1 КАК Таблица
		|;
		|
		|////////////////////////////
		|";
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ТабличнаяЧасть.Ключ);
		
		ТекстОбъединенияНовая =
		"ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		
		ТекстОбъединенияСтарая =
		"ВЫБРАТЬ
		|	-Таблица.НомерСтроки КАК НомерСтроки";
		
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстОбъединенияНовая  = ТекстОбъединенияНовая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
			ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонИзНовая = "
		|ИЗ
		|	НоваяТаблица%1 КАК Таблица";
		ТекстОбъединенияНовая = ТекстОбъединенияНовая + СтрШаблон(ШаблонИзНовая, ТабличнаяЧасть.Ключ);
		
		ШаблонИзСтарая = "
		|ИЗ
		|	%1.%2 КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
		ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонИзСтарая, ПолноеИмя, ТабличнаяЧасть.Ключ);
		
		ТекстЗапроса = ТекстЗапроса + 
		"ВЫБРАТЬ
		|	СУММА(ВложенныйЗапрос.НомерСтроки) КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	ВложенныйЗапрос.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ 
		|(" 
		+ Символы.ПС + ТекстОбъединенияНовая 
		+ Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "
		+ Символы.ПС + ТекстОбъединенияСтарая + ") КАК ВложенныйЗапрос
		|
		|СГРУППИРОВАТЬ ПО";
		
		ШаблонСгруппировать = "
		|	ВложенныйЗапрос.%1,";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонСгруппировать, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "ИСТИНА
		|ИМЕЮЩИЕ 
		|	СУММА(ВложенныйЗапрос.НомерСтроки) <> 0";
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр(ТабличнаяЧасть.Ключ, Объект[ТабличнаяЧасть.Ключ]);
		
		РезультатЗапроса = Запрос.Выполнить();
		Если НЕ РезультатЗапроса.Пустой() Тогда
			Если НЕ Результат.Свойство("ТабличныеЧасти") Тогда
				Результат.Вставить("ТабличныеЧасти", Новый Структура);
			КонецЕсли;
			Результат.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Ключ, РезультатЗапроса.Выгрузить());
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПолученияПредставленияДанных

// Возвращает строковое представление документа для отображения в сообщениях.
//
// Параметры:
//	Ссылка - ссылка на документ
//	Номер - номер документа
//	Дата - дата документа
//
Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	
	Возврат
		Ссылка.Метаданные().Синоним
		+ ?(ЗначениеЗаполнено(Номер), " " + Номер, "")
		+ ?(ЗначениеЗаполнено(Дата), " " + НСтр("ru='от'") + " " + Формат(Дата,"ДЛФ=D"), "");
	
КонецФункции

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации"
//
// Возвращаемое значение:
//  КоллекцияОбъектовМетаданных
// 
Функция МетаданныеОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат Метаданные.ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Метаданные.Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Метаданные.Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат Метаданные.ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Метаданные.Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Метаданные.Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Метаданные.Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат Метаданные.ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат Метаданные.ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат Метаданные.ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат Метаданные.РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат Метаданные.РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат Метаданные.РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат Метаданные.РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат Метаданные.БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Метаданные.Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Метаданные.Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Метаданные.Последовательности[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 		Объект                      - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивПроверяемыхРеквизитов - Массив - массив проверяемых реквизитов.
//
// Возвращаемое значение:
// 		Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь
//
Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, МассивПроверяемыхРеквизитов) Экспорт
	
	Перем ПроверяемыеРеквизитыТЧ;
	Отказ = Ложь;
	
	// Получение метаданных объекта
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	// Создание структуры стандартных реквизитов
	СтандартныеРеквизиты = Новый Структура;
	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтандартныеРеквизиты.Вставить(Реквизит.Имя, ?(ЗначениеЗаполнено(Реквизит.Синоним), Реквизит.Синоним, Реквизит.Имя));
	КонецЦикла;
	
	// Создание структуры для хранения имен табличных частей и проверяемых реквизитов в них.
	// 		Ключ -  Имя табличной части
	// 		Значение - Массив - Массив строк, реквизитов этой табличной части для проверки
	ТабличныеЧасти = Новый Структура;
	
	// Создание шаблонов сообщений об ошибках не заполненных реквизитов и реквизитов табличных частей
	ШаблонОшибкиРеквизита = НСтр("ru='Поле ""%ИмяРеквизита%"" не заполнено'");
	ШаблонОшибкиТЧ = НСтр("ru='Не введено ни одной строки в список ""%ИмяРеквизита%""'");
	ШаблонОшибкиРеквизитаТЧ = НСтр("ru='Не заполнена колонка ""%ИмяРеквизита%"" в строке %НомерСтроки% списка ""%ИмяТабличнойЧасти%""'");
	
	// Проверка реквизитов объекта и заполнение структуры по реквизитам табличных частей
	Для Каждого Реквизит Из МассивПроверяемыхРеквизитов Цикл
		
		ПозицияТочки = СтрНайти(Реквизит,".");
		
		Если ПозицияТочки > 0 Тогда // В случае если указан реквизит табличной части
			
			ДлинаСтроки       = СтрДлина(Реквизит);
			ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			
			// Сохранение проверяемого реквизита табличной части в структуру
			Если НЕ ТабличныеЧасти.Свойство(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ) Тогда
				ПроверяемыеРеквизитыТЧ = Новый Массив;
				ТабличныеЧасти.Вставить(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ);
			КонецЕсли;
			ПроверяемыеРеквизитыТЧ.Добавить(ИмяРеквизита);
			
		Иначе // В случае если указан реквизит объекта
			
			Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				
				Если МетаданныеОбъекта.Реквизиты.Найти(Реквизит) <> Неопределено Тогда // Если указано имя реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						МетаданныеОбъекта.Реквизиты[Реквизит].Синоним);
				ИначеЕсли СтандартныеРеквизиты.Свойство(Реквизит) Тогда // Если указано имя стандартного реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						СтандартныеРеквизиты[Реквизит]);
				Иначе // Если указано имя табличной части
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиТЧ, "%ИмяРеквизита%",
						МетаданныеОбъекта.ТабличныеЧасти[Реквизит].Синоним);
				КонецЕсли;
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки,
					Объект,
					Реквизит,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка реквизитов в табличных частях
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		ТабличнаяЧастьОбъекта = Объект[ТабличнаяЧасть.Ключ];
		МассивРеквизитов = ТабличнаяЧасть.Значение;
		
		// Цикл по всем строкам табличной части.
		Для НомерСтроки=0 По ТабличнаяЧастьОбъекта.Количество()-1 Цикл
			
			// Цикл по всем проверяемым реквизитам для текущей табличной части.
			Для НомерРеквизита=0 По МассивРеквизитов.Количество()-1 Цикл
				
				ИмяРеквизита = МассивРеквизитов[НомерРеквизита];
				
				Если Не ЗначениеЗаполнено(ТабличнаяЧастьОбъекта[НомерСтроки][ИмяРеквизита]) Тогда
					
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизитаТЧ, "%ИмяРеквизита%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяРеквизита].Синоним);
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%НомерСтроки%", Формат(НомерСтроки+1, "ЧГ=0"));
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяТабличнойЧасти%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Синоним);
					
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						ТекстОшибки,
						Объект,
						ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТабличнойЧасти, НомерСтроки+1, ИмяРеквизита),
						,
						Отказ);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивПроверяемыхРеквизитов.Очистить();
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеРеквизитовОбъекта()

// Осуществляет проверку соответствия организации документа и хозяйственной операции.
//
Процедура ПроверитьПравильностьУказанияХозяйственнойОперации(ДокументОбъект, Отказ) Экспорт
	
	Если ДокументОбъект.Организация = Справочники.Организации.УправленческаяОрганизация
	   И (ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.РеализацияКлиентуРеглУчет
	 ИЛИ ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.ЗакупкаУПоставщикаРеглУчет) Тогда
	 
		Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе нельзя указывать операцию %1 и управленческую организацию'"),
			ДокументОбъект.ХозяйственнаяОперация);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			Текст,
			ДокументОбъект,
			"ХозяйственнаяОперация",
			,
			Отказ);
	 
	КонецЕсли;
	
КонецПроцедуры // ПроверитьПравильностьУказанияХозяйственнойОперации()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ           - ДокументСсылка - Документ, на основании которого осуществляется ввод
// Статус             - Статус документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиСтатус   - Булево - Если Истина - документ, на основании которого осуществляется ввод, имеет некорректный статус
// СоглашениеДоступноВнешнемуПользователю Булево - Если Истина - документ на основаннии которого осуществляется ввод имеет соглашение
//                                                               доступное внешнему пользователю.
//
Процедура ПроверитьВозможностьВводаНаОсновании(Документ,
	                                           Статус = Неопределено,
	                                           ЕстьОшибкиПроведен = Ложь,
	                                           ЕстьОшибкиСтатус = Ложь,
	                                           МассивДопустимыхСтатусов = Неопределено,
	                                           СоглашениеДоступноВнешнемуПользователю = Неопределено) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиСтатус Тогда
		
		Если МассивДопустимыхСтатусов = Неопределено Тогда
			ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании запрещен.'");
		ИначеЕсли ТипЗнч(МассивДопустимыхСтатусов) = Тип("Массив") Тогда
			
			ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен в %СтрокаДопустимыхСтатусов%.'");
			СтрокаДопустимыхСтатусов = "";
			
			Для Каждого ДопустимыйСтатус Из МассивДопустимыхСтатусов Цикл
				СтрокаДопустимыхСтатусов = СтрокаДопустимыхСтатусов + """"+ ДопустимыйСтатус + """, ";
			КонецЦикла;
			
			СтрокаДопустимыхСтатусов = Лев(СтрокаДопустимыхСтатусов, СтрДлина(СтрокаДопустимыхСтатусов)-2);
			
			Если МассивДопустимыхСтатусов.Количество() = 0 Тогда
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании запрещен.'");
			ИначеЕсли МассивДопустимыхСтатусов.Количество() = 1 Тогда
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусе %СтрокаДопустимыхСтатусов%.'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрокаДопустимыхСтатусов);
			Иначе
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусах %СтрокаДопустимыхСтатусов%.'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрокаДопустимыхСтатусов);
			КонецЕсли;
			
		КонецЕсли;
		
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Статус%",   Статус);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ОбщегоНазначенияУТКлиентСервер.АвторизованВнешнийПользователь() И НЕ СоглашениеДоступноВнешнемуПользователю = Истина Тогда
		
		ТекстОшибки = НСтр("ru='Соглашение документа %Документ% недоступно для работы при самообслуживании. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОсновании()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ                            - ДокументСсылка - Документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен                  - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиВернутьМногооборотнуюТару - Булево - Если Истина - по документу, на основании которого осуществляется ввод, тара не возвратная
//
Процедура ПроверитьВозможностьВводаНаОснованииВыкупаТары(Документ, ЕстьОшибкиПроведен, ЕстьОшибкиВернутьМногооборотнуюТару) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиВернутьМногооборотнуюТару Тогда
		
		ТекстОшибки = НСтр("ru='В документе %Документ% не стоит признак возврата многооборотной тары. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// ЕстьОшибкиТиповое  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - типовое
// ЭтоАгентскиеУслуги  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - соглашение по оказанию агентских услуг
//
Процедура ПроверитьВозможностьВводаНаОснованииСоглашения(ЕстьОшибкиТиповое = Ложь, ЭтоАгентскиеУслуги = Ложь) Экспорт
	
	Если ЕстьОшибкиТиповое Тогда
		
		ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения с клиентом запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	Если ЭтоАгентскиеУслуги Тогда
		
		ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения по оказанию агентских услуг запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСоглашения()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Партнер - СправочникСсылка.Партнеры - Партнер из сделки по продаже
//
Процедура ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже(Партнер) Экспорт
	
	Если Не ЗначениеЗаполнено(Партнер) Тогда
		
		ТекстОшибки = НСтр("ru='В сделке не указан партнер, ввод на основании запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже()

// Устанавливает или сбрасывает флаг Согласован у справочника.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// ДокументОбъект     - СправочникОбъект - Справочник, в котором необходимо изменить флаг Согласован
// СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен
//
Процедура ИзменитьПризнакСогласованностиСправочника(СправочникОбъект, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	// Справочник не имеет статуса
	Если СтатусНеСогласован = Неопределено Тогда
		
		Если Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	// Справочник имеет статус, в котором проведенный справочник не согласован
	Иначе
		
		Если СправочникОбъект.Статус = СтатусНеСогласован И СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Ложь;
		ИначеЕсли СправочникОбъект.Статус <> СтатусНеСогласован И Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиСправочника()

// Устанавливает или сбрасывает флаг Согласован у документа.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// ДокументОбъект     - ДокументОбъект - Документ, в котором необходимо изменить флаг Согласован
// РежимЗаписи        - Режим записи документа
// СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен
//
Процедура ИзменитьПризнакСогласованностиДокумента(ДокументОбъект, Знач РежимЗаписи, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	Если РежимЗаписи = РежимЗаписиДокумента.Запись
	 ИЛИ РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		
		Если ДокументОбъект.Согласован Тогда
			ДокументОбъект.Согласован = Ложь;
		КонецЕсли;
		
	ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		
		// Документ не имеет статуса
		Если СтатусНеСогласован = Неопределено Тогда
		
			Если Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		// Документ имеет статус из массива, в которых проведенный документ не согласован
		ИначеЕсли ТипЗнч(СтатусНеСогласован) = Тип("Массив") Тогда
			
			Если ДокументОбъект.Согласован Тогда
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						
						ДокументОбъект.Согласован = Ложь;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			Иначе
				
				ДокументСогласован = Истина;
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						ДокументСогласован = Ложь;
					КонецЕсли;
					
				КонецЦикла;
				
				Если ДокументСогласован Тогда
					ДокументОбъект.Согласован = Истина;
				КонецЕсли;
				
			КонецЕсли;
			
		// Документ имеет статус, в котором проведенный документ не согласован
		Иначе
			
			Если ДокументОбъект.Статус = СтатусНеСогласован И ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Ложь;
			ИначеЕсли ДокументОбъект.Статус <> СтатусНеСогласован И Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиДокумента()

// Настраивает подключаемое оборудование в форме,
// устанавливает флаг ИспользоватьПодключаемоеОборудование в форме
// Параметры:
//   Форма - Форма, в которой необходимо настроить подключаемое оборудование
//
Процедура НастроитьПодключаемоеОборудование(Форма, ПрефиксыЭлементовФормы = "Товары") Экспорт
	
	ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	
	Форма.ИспользоватьПодключаемоеОборудование = ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования);
	
	ЕстьТСД  =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ТерминалСбораДанных) <> Неопределено;
	ЕстьВесы =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ЭлектронныеВесы) <> Неопределено;
		
	Если ЗначениеЗаполнено(ПрефиксыЭлементовФормы) Тогда
		МассивПрефиксыЭлементовФормы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПрефиксыЭлементовФормы, ",");
	Иначе
		МассивПрефиксыЭлементовФормы = Новый Массив;
		МассивПрефиксыЭлементовФормы.Добавить(ПрефиксыЭлементовФормы);
	КонецЕсли;
	
	Для Каждого Префикс Из МассивПрефиксыЭлементовФормы Цикл
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ЗагрузитьДанныеИзТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ВыгрузитьДанныеВТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ПолучитьВес",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьВесы);
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, что включена ф.о "Использовать подключаемое оборудование",
// настроено ли оборудование и авторизовался пользователь,
// а не внешний пользователь.
Функция ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования = Неопределено) Экспорт
	
	ИспользоватьПодключаемоеОборудование = ПолучитьФункциональнуюОпцию("ИспользоватьПодключаемоеОборудование");
	ПользовательАвторизовался 			 = ТипЗнч(Пользователи.АвторизованныйПользователь()) = Тип("СправочникСсылка.Пользователи");
	
	Если ТипыПодключенногоОборудования = Неопределено Тогда
		ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	КонецЕсли;
	
	Возврат
		ИспользоватьПодключаемоеОборудование
		И ПользовательАвторизовался
		И ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Количество() > 0;
												 
КонецФункции

// Возвращает список пользователей, имеющих роли, указанные в качестве параметра
//
// Параметры:
// 		МассивРолей - Массив - массив с именами ролей
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя
// 
//	Возвращаемое значение:
//		СписокЗначений с элементами СправочникСсылка.Пользователи
//
Функция ПользователиСДоступнымиРолями(МассивРолей, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	СписокПользователей = Новый СписокЗначений;
	Если ПредставлениеТекущегоПользователя = Неопределено Тогда
		ПредставлениеТекущегоПользователя = НСтр("ru='<Мои документы>'");
	КонецЕсли;
	
	// Запрос получения списка всех пользователей. Выполняется в привилегированном режиме
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПрофилиГруппДоступаРоли.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ПрофилиГруппДоступа
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК ПрофилиГруппДоступаРоли
	|ГДЕ
	|	ПрофилиГруппДоступаРоли.Роль.Имя В(&МассивРолей)
	|
	|СГРУППИРОВАТЬ ПО
	|	ПрофилиГруппДоступаРоли.Ссылка
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь) КАК Пользователь
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ГруппыПользователей.Состав КАК ГруппыПользователейСостав
	|		ПО ГруппыДоступаПользователи.Пользователь = ГруппыПользователейСостав.Ссылка
	|ГДЕ
	|	ГруппыДоступаПользователи.Ссылка.Профиль В
	|			(ВЫБРАТЬ
	|				ПрофилиГруппДоступа.Ссылка
	|			ИЗ
	|				ПрофилиГруппДоступа КАК ПрофилиГруппДоступа)
	|
	|СГРУППИРОВАТЬ ПО
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь)";
	
	Запрос.УстановитьПараметр("МассивРолей", МассивРолей);
	
	МассивВсехПользователей = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Пользователь");
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Запрос получения списка "разрешенных" пользователей
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Пользователи.Ссылка КАК Пользователь
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.Ссылка В(&МассивПользователей)
	|	И Пользователи.ПометкаУдаления = ЛОЖЬ
	|	И Пользователи.Недействителен = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Пользователи.Наименование";
	Запрос.УстановитьПараметр("МассивПользователей", МассивВсехПользователей);
	
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ТекущийПользователь = Выборка.Пользователь Тогда
			СписокПользователей.Вставить(0, Выборка.Пользователь, ПредставлениеТекущегоПользователя);
		Иначе
			СписокПользователей.Добавить(Выборка.Пользователь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокПользователей;
	
КонецФункции

// Возвращает список пользователей, имеющих право на изменение объекта метаданных
//
// Параметры:
// 		ОбъектМетаданных - Метаданные - объект метаданных, на которые проверяются права доступа
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя
// 
//	Возвращаемое значение:
//		СписокЗначений с элементами СправочникСсылка.Пользователи
//
Функция ПолучитьСписокПользователейСПравомДобавления(ОбъектМетаданных, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	МассивРолей = ПраваПользователяПовтИсп.ИменаРолейСПравомДобавления(ИмяОбъектаМетаданных);
	
	Если НЕ ЗначениеЗаполнено(МассивРолей) Тогда
		Возврат Новый СписокЗначений;
	КонецЕсли;
	
	Возврат ПользователиСДоступнымиРолями(МассивРолей, ПредставлениеТекущегоПользователя);;
	
КонецФункции

// Возвращает свернутую копию таблицы значений.
//
Функция СвернутьТаблицуЗначенийПоРеквизиту(ТаблицаРеквизитыДокументов, ИмяРеквизита) Экспорт
	
	Таблица = ТаблицаРеквизитыДокументов.Скопировать();
	Таблица.Свернуть(ИмяРеквизита);
	Возврат Таблица;
	
КонецФункции // СвернутьТаблицуЗначенийПоРеквизиту()

// Удаляет указанные строки из таблицы значений.
// 
// Параметры:
//	Таблица - ТаблицаЗначений - обрабатываемая таблица
//	Строки  - Массив(элементы - СтрокаТаблицыЗначений) - массив удаляемых строк
//
Процедура УдалитьСтрокиТаблицыЗначений(Таблица, Строки) Экспорт
	
	Для Каждого СтрокаТаблицы Из Строки Цикл
		Таблица.Удалить(СтрокаТаблицы);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет строки из таблицы значений с учетом переданного отбора.
// 
// Параметры:
//	Таблица 			  - ТаблицаЗначений - обрабатываемая таблица
//	СтруктураПоиска 	  - Структура - структура поиска строк, см. описание метода НайтиСтроки() таблицы значений
//	УдалятьПопавшиеВОтбор - Булево - если указать Ложь, то будут удалены все строки, не входящие в отбор
//
Процедура НайтиИУдалитьСтрокиТаблицыЗначений(Таблица, СтруктураПоиска, УдалятьПопавшиеВОтбор = Истина) Экспорт
	
	Строки = Таблица.НайтиСтроки(СтруктураПоиска);
	
	Если НЕ УдалятьПопавшиеВОтбор Тогда
		
		Если Строки.Количество() = Таблица.Количество() Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = 0 Тогда
			Таблица.Очистить();
		Иначе
			
			УдаляемыеСтроки = Новый Массив;
			
			Для Каждого СтрокаТаблицы Из Таблица Цикл
				
				Если Строки.Найти(СтрокаТаблицы) = Неопределено Тогда
					УдаляемыеСтроки.Добавить(СтрокаТаблицы); // строка не входит в переданный отбор
				КонецЕсли;
				
			КонецЦикла;
			
			УдалитьСтрокиТаблицыЗначений(Таблица, УдаляемыеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Если Строки.Количество() = 0 Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = Таблица.Количество() Тогда
			Таблица.Очистить();
		Иначе
			УдалитьСтрокиТаблицыЗначений(Таблица, Строки);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры
	
// Функция проверяет наличие согласующего по указанной роли в регистре сведений Исполнители задач.
//
// Параметры:
//	ПроверяемаяРоль - Ссылка на роль исполнителя - Элемент справочника РолиИсполнителей
//
Функция ПроверитьСогласующегоБизнесПроцесс(ПроверяемаяРоль) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ИсполнителиЗадач.Исполнитель КАК ЕстьИсполнитель
		|ИЗ
		|	РегистрСведений.ИсполнителиЗадач КАК ИсполнителиЗадач
		|ГДЕ
		|	ИсполнителиЗадач.РольИсполнителя =&РольИсполнителя";

	Запрос.УстановитьПараметр("РольИсполнителя", ПроверяемаяРоль);
	Результат = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = Результат.Выбрать();

	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции // ПроверитьСогласующегоБизнесПроцесс()

// Фукнция раскладывает переданный массив сслылок в соотвествие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соотвествие:
//			Ключ - полное имя типа ссылки
//	        Значение - массив ссылок этого типа
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

// Возвращает разницу между двумя датами (в днях)
//
// Параметры
//  ДатаНачала 		- Дата - начальная дата периода
//  ДатаОкончания	- Дата - конечная дата периода
//
// Возвращаемое значение:
//   Число	 - количество дней между двумя датами
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	СекундВМинуте = 60;
	МинутВЧасе = 60;
	ЧасовВДне = 24;
	
	Если Периодичность = Перечисления.Периодичность.Год Тогда
		Возврат Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		Возврат ?(Месяц(ДатаОкончания)>6, 2, 1) - ?(Месяц(ДатаНачала)>6, 2, 1) + 2*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		Возврат Цел(Месяц(НачалоКвартала(ДатаОкончания))/3) - Цел(Месяц(НачалоКвартала(ДатаНачала))/3) + 4*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		Возврат Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		Возврат Цел((ДатаОкончания - ДатаНачала)/(10 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		Возврат Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала))/(7 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		Возврат (ДатаОкончания - ДатаНачала)/(СекундВМинуте*МинутВЧасе*ЧасовВДне);
		
	КонецЕсли;
	
КонецФункции

// Проверяет использование объекта
//
// Параметры:
//  Параметры		- Структура - содержит объект использование которого нужно проверить
//  АдресХранилища	- Строка - адрес хранилища в которое будут помещен результат проверки
//
Процедура ПроверитьИспользованиеОбъекта(Параметры, АдресХранилища) Экспорт
	
	ЕстьСсылки = ОбщегоНазначенияВызовСервера.ЕстьСсылкиНаОбъект(Параметры.Объект);
	
	ПоместитьВоВременноеХранилище(ЕстьСсылки, АдресХранилища);
	
КонецПроцедуры

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект
// см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта()
// Если полученное значение не имеет тип булево, возвращается значение Ложь
//
Функция ЗначениеРеквизитаОбъектаТипаБулево(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	Если ТипЗнч(Результат) <> Тип("Булево") Тогда
		Результат = ЛожЬ;
	КонецЕсли;
	
	Возврат Результат
	
КонецФункции

// Возвращает ключ коллекции, имеющий указанное значение.
//
Функция КлючКоллекцииПоЗначению(Коллекция, Значение) Экспорт
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Если КлючИЗначение.Значение = Значение Тогда
			Возврат КлючИЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает коллекцию, в которой ключи и значения поменяны местами.
//
Функция ПоменятьКлючИЗначениеКоллекции(Коллекция) Экспорт
	
	Если ТипЗнч(Коллекция) = Тип("Структура") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый Структура;
	ИначеЕсли ТипЗнч(Коллекция) = Тип("Соответствие") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый Соответствие;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		НоваяКоллекция.Вставить(КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
	Если ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый ФиксированнаяСтруктура(НоваяКоллекция);
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый ФиксированноеСоответствие(НоваяКоллекция);
	КонецЕсли;
	
	Возврат НоваяКоллекция;
	
КонецФункции

// Возвращает количество документов прописью.
//
// Параметры:
//  КоличествоДокументов - Число - Количество документов
//
// Возвращаемое значение:
//  Строка - Количество документов прописью
//
Функция ЧислоДокументовПрописью(КоличествоДокументов) Экспорт
	
	КоличествоПрописью = ЧислоПрописью(
		КоличествоДокументов,
		НСтр("ru='SN = Истина; FN = Ложь; FS = Ложь;'"),
		НСтр("ru = 'документа,документа,документов,м,,,,,0'"));
	Поз = СтрНайти(КоличествоПрописью, "документ");
	Если Поз <> 0 Тогда
		КоличествоПрописью = Сред(КоличествоПрописью, Поз);
	КонецЕсли;
	КоличествоПрописью = Строка(КоличествоДокументов) + " " + НРег(КоличествоПрописью);
	
	Возврат КоличествоПрописью;
	
КонецФункции

// Возвращает описание типов по переданному типу
// 
// Параметры:
//	Тип - Тип - тип значения
//
// Возвращаемое значение:
//	ОписаниеТипов - созданное на основании переданного типа описание типов
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);
	
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	
	Возврат ОписаниеТипов;
КонецФункции

// Возвращает таблицу значений на основании массива структур
// 
// Параметры:
//	МассивСтруктур - МассивСтруктур - массив структур, которые будут преобразованы в таблиц значений.
//										Свойства структуры первого элемента массива определяютс состав колонок результирующей таблицы
//
// Возвращаемое значение:
//	ТаблицаЗначений - таблица значений, созданная из массива структур
// 
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл 
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
КонецФункции

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//	Запрос			- Запрос - запрос, параметры которого предварительно установлены.
//	ТекстыЗапроса	- СписокЗначений - в списке перечислены тексты запросов и их имена.
//	ОбходРезультата - ОбходРезультатаЗапроса - вариант обхода результата запроса.
//	ДобавитьРазделитель - Булево - добавлять разделитель между запросами из ТекстыЗапроса
//	УничтожитьСозданныеВременныеТаблицы - Булево - добавить уничножение временных таблиц, создаваемых в ТекстыЗапроса
//										Для уничтожения таблице должно быть присвоено имя в ТекстыЗапроса
//
// Возвращаемое значение:
//   Структура   - структура в которую помещены полученные таблицы
//
Функция ВыгрузитьРезультатыЗапроса(Запрос,
								 	ТекстыЗапроса,
									ОбходРезультата = Неопределено,
									ДобавитьРазделитель = Ложь,
									УничтожитьСозданныеВременныеТаблицы = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	// Инициализация варианта обхода результата запроса.
	Если ОбходРезультата = Неопределено Тогда
		ОбходРезультата = ОбходРезультатаЗапроса.Прямой;
	КонецЕсли;
	
	МассивТекстовЗапросов 	 = Новый Массив;
	МассивУничтожаемыхТаблиц = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстовЗапросов.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли; 
		
		МассивТекстовЗапросов.Добавить(ТекстЗапроса.Значение + ?(ДобавитьРазделитель, РазделительЗапросовВПакете(), ""));
		
		Если УничтожитьСозданныеВременныеТаблицы
		 И ЗначениеЗаполнено(ТекстЗапроса.Представление)
		 И СтрНайти(ВРег(ТекстЗапроса.Значение), "ПОМЕСТИТЬ") <> 0 Тогда
			МассивУничтожаемыхТаблиц.Добавить(ТекстЗапроса.Представление);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого ИмяУдаляемойТаблицы Из МассивУничтожаемыхТаблиц Цикл
		МассивТекстовЗапросов.Добавить("УНИЧТОЖИТЬ " + ИмяУдаляемойТаблицы + РазделительЗапросовВПакете());
	КонецЦикла;
	
	Если МассивТекстовЗапросов.Количество() > 0 Тогда
		
		// Выполнение запроса.
		Запрос.Текст = СтрСоединить(МассивТекстовЗапросов, Символы.ПС);
		Результат = Запрос.ВыполнитьПакет();

		// Помещение результатов запроса в таблицы.
		Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
			
			Если НЕ ПустаяСтрока(ТекстЗапроса.Представление) Тогда // имя таблицы
				Таблицы.Вставить(
					ТекстЗапроса.Представление,
					Результат[ТекстыЗапроса.Индекс(ТекстЗапроса)].Выгрузить(ОбходРезультата));
			КонецЕсли;

		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Таблицы;
	
КонецФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Параметры:
//  ПолноеИмя - Строка - Полный путь к метаданным реквизита как в дереве метаданных.
//                       Пример: "Документы.ПоступлениеБезналичныхДенежныхСредств.ТабличныеЧасти.РасшифровкаПлатежа.Реквизиты.Заказ"
//                               "РегистрыНакопления.ДвиженияКонтрагентДоходыРасходы.Измерения.ОбъектРасчетов"
//
// Возвращаемое значение:
//  ОбъектМетаданных,КоллекцияОбъектовМетаданных
//
Функция МетаданныеПоИмени(МетаданныеСтрокой) Экспорт
	
	Возврат СвойствоМетаданных(Метаданные, СтрРазделить(МетаданныеСтрокой, "."));
	
КонецФункции

//Возвращает структуру границ оборотов по регистру
//
// Параметры:
//  ИмяРегистра - Строка - Имя регистра накопления.
//  Отборы      - Строка - Отборы виртуальной таблицы оборотов, для которой необходимо получить границы.
//  Параметры   - Структура - Параметры запроса для отборов виртуальной таблицы.
//
// Возвращаемое значение:
//  Структура - Структура границ со свойствами:
//  	* МинимальнаяДата - Дата - Начальная граница оборотов.
//  	* МаксимальнаяДата - Дата - Конечная граница оборотов.
//
Функция ГраницыОборотовРегистра(ИмяРегистра, Отборы, Параметры) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПсевдонимТаблицы.Период КАК Период
	|ИЗ
	|	РегистрНакопления." + ИмяРегистра + ".Обороты(, , Запись, " + Отборы + ") КАК ПсевдонимТаблицы
	|
	|УПОРЯДОЧИТЬ ПО
	|	Период;
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПсевдонимТаблицы.Период КАК Период
	|ИЗ
	|	РегистрНакопления." + ИмяРегистра + ".Обороты(, , Запись, " + Отборы + ") КАК ПсевдонимТаблицы
	|
	|УПОРЯДОЧИТЬ ПО
	|	Период УБЫВ");
	
	Для каждого Параметр из Параметры Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	Результат = Запрос.ВыполнитьПакет();
	СтруктураГраниц = Новый Структура;
	СтруктураГраниц.Вставить("МинимальнаяДата", ?(Результат[0].Пустой(), Дата(1,1,1), Результат[0].Выгрузить()[0].Период));
	СтруктураГраниц.Вставить("МаксимальнаяДата", ?(Результат[1].Пустой(), Дата(2999,1,1), Результат[1].Выгрузить()[0].Период));
	
	Возврат СтруктураГраниц;
	
КонецФункции

// Возвращает строку для вставки между запросами, объединяемыми в пакет
// 
// Возвращаемое значение:
//  Строка 
//
Функция РазделительЗапросовВПакете() Экспорт
	
	Возврат "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
КонецФункции

// Возвращает Истина, если включен режим отладки.
Функция РежимОтладки() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	РежимОтладки = ОбщегоНазначенияКлиентСервер.РежимОтладки()
		ИЛИ Константы.РежимОтладки.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат РежимОтладки;
	
КонецФункции

// Перед попыткой непосредственного удаления документа устанавливает
// пометку на удаление, что позволяет отработать предусмотренным
// механизмам в документе.
// Формирует список сообщений об успешном удалении документов, либо
// об ошибках не позволяющих удалить документы.
//
// Параметры:
//  СсылкиНаУдаление - Массив - Список созданных документов.
// 
// Возвращаемое значение:
//   Структура - Содержит список сообщений. Состав ключей определяется в функции ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.
//
Функция УдалитьДокументы(СсылкиНаУдаление) Экспорт
	
	Перем СписокОшибок;
	
	Если СсылкиНаУдаление.Количество() = 0 Тогда
		Возврат СписокОшибок;
	КонецЕсли;
	
	ТекстИмеютсяСсылки  = НСтр("ru = 'Имеются ссылки на %1 - %2.'");
	ТекстПомечен        = НСтр("ru = '%1 - помечен на удаление.'");
	ТекстУдален         = НСтр("ru = '%1 - удален.'");
	ТекстНеЗаблокирован = НСтр("ru = '%1 - не удалось пометить на удаление документ, возможно документ редактируется другим пользователем.'");
	
	МассивИменОбъектовМетаданных = Новый Массив();
	Для Каждого ДокументКУдалению Из СсылкиНаУдаление Цикл
		ИмяОбъектаМетаданных = ДокументКУдалению.Метаданные().ПолноеИмя();
		Если МассивИменОбъектовМетаданных.Найти(ИмяОбъектаМетаданных) = Неопределено Тогда
			МассивИменОбъектовМетаданных.Добавить(ИмяОбъектаМетаданных);
		КонецЕсли;
	КонецЦикла;
	ИменаОбъектовМетаданных = СтрСоединить(МассивИменОбъектовМетаданных, ",");
	
	Регистры = ОбщегоНазначенияУТПовтИсп.РегистрыСведенийПоМетаданнымИзмерений(ИменаОбъектовМетаданных, Истина);
	
	НазначенияЗаказов = НазначенияЗаказов(СсылкиНаУдаление);
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(СсылкиНаУдаление, НазначенияЗаказов);
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТабСсылок = НайтиПоСсылкам(СсылкиНаУдаление);
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Если Ссылка[0] = Ссылка[1] Или ЭтоЗаписьВедомогоРегистраСведений(Ссылка[1], Регистры) Тогда
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПомечатьНаУдаление = Новый Массив();
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка[1]);
		Если Индекс = Неопределено Тогда
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) = Неопределено Тогда
				
				ПомечатьНаУдаление.Добавить(Ссылка[0]);
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИмеютсяСсылки, СокрЛП(Ссылка[0]), СокрЛП(Ссылка[1])); 
				ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
				
			КонецЕсли;
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ОбработкаЗавершена = Ложь;
	Пока Не ОбработкаЗавершена Цикл
		
		ОбработкаЗавершена = Истина;
		
		ВсегоСтрок = ТабСсылок.Количество();
		Для Счетчик = 1 По ВсегоСтрок Цикл
			Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) <> Неопределено Тогда
				
				Если ПомечатьНаУдаление.Найти(Ссылка[1]) = Неопределено Тогда
					
					ПомечатьНаУдаление.Добавить(Ссылка[1]);
					
				КонецЕсли;
				
				ТабСсылок.Удалить(Ссылка);
				ОбработкаЗавершена = Ложь;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого Ссылка из СсылкиНаУдаление Цикл
		
		ДокументОбъект = Ссылка.ПолучитьОбъект();
		Если ДокументОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ДокументОбъект.Заблокировать();
		Исключение
			
			Если ПомечатьНаУдаление.Найти(Ссылка) = Неопределено Тогда
				ПомечатьНаУдаление.Добавить(Ссылка);
			КонецЕсли;
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНеЗаблокирован, СокрЛП(Ссылка)); 
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			Продолжить;
			
		КонецПопытки;
		
		ДокументОбъект.УстановитьПометкуУдаления(Истина);
		Если ПомечатьНаУдаление.Найти(Ссылка) <> Неопределено Тогда
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстПомечен, СокрЛП(Ссылка));
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка из ПомечатьНаУдаление Цикл
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка);
		Если Индекс <> Неопределено Тогда
			СсылкиНаУдаление.Удалить(Индекс);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка из СсылкиНаУдаление Цикл
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстУдален, СокрЛП(Ссылка)); 
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
		
	КонецЦикла;
	
	УдалитьОбъекты(СсылкиНаУдаление, Ложь);
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат СписокОшибок;
	
КонецФункции

// Возвращает строку для вставки между текстами объединяемых запросов
// Параметры:
//	ТолькоУникальные - Булево - признак того, что необходимо выбирать только уникальные записи при объединении
//		значение по умолчанию - ЛОЖЬ.
// 
// Возвращаемое значение:
//  Строка 
//
Функция РазделительЗапросовВОбъединении(ТолькоУникальные = Ложь) Экспорт
	
	Возврат Символы.ПС + Символы.ПС + "ОБЪЕДИНИТЬ" + ?(ТолькоУникальные, "", " ВСЕ") + Символы.ПС + Символы.ПС;
	
КонецФункции

// Возвращает структуру с ключами, соответствующими колонкам таблицы значений.
// Значения в структуре заполненяются значениями полей из переданной строки таблицы.
//
// Параметры:
//	ТекущаяСтрока - СтрокаТаблицыЗначений
//
// Возвращаемое значение:
//	Структура
//
Функция ПреобразоватьСтрокуТаблицыВСтруктуру(ТекущаяСтрока) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Колонка Из ТекущаяСтрока.Владелец().Колонки Цикл
		Результат.Вставить(Колонка.Имя, ТекущаяСтрока[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Устанавливает параметры запроса из переданной структуры.
//
// Параметры:
//	Запрос - Запрос - запрос, параметры которого надо установить
//	ПараметрыЗапроса - Структура - структура с устанавливаемыми параметрами запроса
//
Процедура УстановитьПараметрыЗапроса(Запрос, ПараметрыЗапроса) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область НастройкиФорм

// Устанавливает параметры контекстных функциональных опций формы.
//
Процедура НастроитьФормуПоПараметрам(Форма, ПараметрыНастройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиФорм.Ссылка
	|ИЗ
	|	Справочник.ПараметрыКонтекстныхФункциональныхОпций КАК НастройкиФорм
	|ГДЕ
	|	ИСТИНА";
	
	Для каждого ПараметрНастройки Из ПараметрыНастройки Цикл
	
		ТекстЗапроса = ТекстЗапроса + " 
		|	И НастройкиФорм." + ПараметрНастройки.Ключ + " = &" + ПараметрНастройки.Ключ;
		Запрос.УстановитьПараметр(ПараметрНастройки.Ключ, ПараметрНастройки.Значение);
	
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		Настройка = Выборка.Ссылка;
		
	Иначе
		
		СправочникОбъект = Справочники.ПараметрыКонтекстныхФункциональныхОпций.СоздатьЭлемент();
		
		ЗаполнитьЗначенияСвойств(СправочникОбъект, ПараметрыНастройки);
		
		СправочникОбъект.Записать();
		
		Настройка = СправочникОбъект.Ссылка;
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("НастройкаФормы", Настройка));
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ИнициализироватьРеквизитыФормыДляПолнотекстовогоПоиска(Форма, ИмяФОИспользованияППД) Экспорт
	
	Форма.ИнформационнаяБазаФайловая      = ОбщегоНазначения.ИнформационнаяБазаФайловая();
	Форма.ИспользоватьПолнотекстовыйПоиск = ОбщегоНазначенияУТВызовСервера.ИспользуетсяПолнотекстовыйПоиск(ИмяФОИспользованияППД);
	
	Если Форма.ИспользоватьПолнотекстовыйПоиск Тогда
			
		Форма.ИндексПолнотекстовогоПоискаАктуален = ПолнотекстовыйПоискСервер.ИндексПоискаАктуален();
		
	КонецЕсли;
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ПересчитатьТаблицуТоваровВВалютуРегл(МенеджерВременныхТаблиц) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	ТаблицаТоваровПредварительная
	|
	|ИТОГИ
	|	СУММА(ТаблицаТоваровПредварительная.СуммаБезНДС),
	|	СУММА(ТаблицаТоваровПредварительная.СуммаНДС),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Валюта),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Дата)
	|ПО
	|	ТаблицаТоваровПредварительная.Ссылка
	|";
	РезультатЗапроса = Запрос.Выполнить();
	
	ПересчитанныеСуммыДокументов = Новый ТаблицаЗначений;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		ПересчитанныеСуммыДокументов.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	ВалютаРегл = Константы.ВалютаРегламентированногоУчета.Получить();
	КэшКурсовВалют = РаботаСКурсамиВалютУТ.ИнициализироватьКэшКурсовВалют();
	
	ВыборкаПоДокументу = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоДокументу.Следующий() Цикл
		
		КурсВалютыДокумента = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВыборкаПоДокументу.Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		КурсВалютыРегл      = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВалютаРегл, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		
		СуммаДокумента     = ВыборкаПоДокументу.СуммаБезНДС + ВыборкаПоДокументу.СуммаНДС;
		СуммаДокументаРегл = СуммаДокумента * КурсВалютыДокумента / КурсВалютыРегл;
		
		УчтеноБазыРаспределения = 0;
		УжеРаспределено = 0;
		
		Выборка = ВыборкаПоДокументу.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			СуммаСНДС = Выборка.СуммаБезНДС + Выборка.СуммаНДС;
			
			СуммаСНДСРегл = ?(СуммаДокумента <> 0, Окр(СуммаДокументаРегл * (УчтеноБазыРаспределения + СуммаСНДС) / СуммаДокумента, 2) - УжеРаспределено, 0);
			
			УчтеноБазыРаспределения = УчтеноБазыРаспределения + СуммаСНДС;
			УжеРаспределено         = УжеРаспределено + СуммаСНДСРегл;
			
			НоваяЗапись = ПересчитанныеСуммыДокументов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Выборка, , "СуммаНДС, СуммаБезНДС");
			
			ТекПроцентНДС = ЦенообразованиеКлиентСервер.ПолучитьСтавкуНДСЧислом(Выборка.СтавкаНДС);
			
			НоваяЗапись.СуммаНДС    = ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(СуммаСНДСРегл, ТекПроцентНДС);
			НоваяЗапись.СуммаБезНДС = СуммаСНДСРегл - НоваяЗапись.СуммаНДС;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Запрос.Текст = "
	|УНИЧТОЖИТЬ ТаблицаТоваровПредварительная;
	|ВЫБРАТЬ";
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		Запрос.Текст = Запрос.Текст + "
		|Таблица." + Колонка.Имя + ",";
	КонецЦикла;
	Запрос.Текст = Лев(Запрос.Текст, СтрДлина(Запрос.Текст)-1);
	Запрос.Текст = Запрос.Текст + "
	|ПОМЕСТИТЬ ТаблицаТоваровПредварительная
	|ИЗ &Таблица КАК Таблица";
	Запрос.УстановитьПараметр("Таблица", ПересчитанныеСуммыДокументов);
	Запрос.Выполнить();
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ПересчитатьТаблицуТоваровВВалюты(МенеджерВременныхТаблиц, ВалютыДляПересчета) Экспорт
	
	ПоказателиДляПересчета = "СуммаБезНДС, СуммаНДС";
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	ТаблицаТоваровПредварительная
	|
	|ИТОГИ
	|	СУММА(ТаблицаТоваровПредварительная.СуммаБезНДС),
	|	СУММА(ТаблицаТоваровПредварительная.СуммаНДС),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Валюта),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Дата)
	|ПО
	|	ТаблицаТоваровПредварительная.Ссылка
	|";
	РезультатЗапроса = Запрос.Выполнить();
	
	ПересчитанныеСуммыДокументов = Новый ТаблицаЗначений;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		ПересчитанныеСуммыДокументов.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	МассивПоказателей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПоказателиДляПересчета, ",", , Истина);
	Для каждого ПоказательДляПересчета из МассивПоказателей Цикл
		ИсходнаяКолонка = ПересчитанныеСуммыДокументов.Колонки.Найти(ПоказательДляПересчета);
		Если ИсходнаяКолонка = Неопределено ИЛИ Не ИсходнаяКолонка.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			Продолжить;
		КонецЕсли;
		Для каждого ВалютаВКоторуюПересчитываем из ВалютыДляПересчета Цикл
			ПересчитанныеСуммыДокументов.Колонки.Добавить(ИсходнаяКолонка.Имя + ВалютаВКоторуюПересчитываем.Ключ, ИсходнаяКолонка.ТипЗначения);
		КонецЦикла;
	КонецЦикла;
	
	КэшКурсовВалют = РаботаСКурсамиВалютУТ.ИнициализироватьКэшКурсовВалют();
	СтруктураВалют = Новый Структура;
	Для каждого ВалютаДляПересчета из ВалютыДляПересчета Цикл
		Если ТипЗнч(ВалютаДляПересчета.Значение) = Тип("СправочникСсылка.Валюты") Тогда
			ДанныеПоВалюте = Новый Структура("Валюта, ОбщаяСумма, Распределено", ВалютаДляПересчета.Значение, 0, 0);
			СтруктураВалют.Вставить(ВалютаДляПересчета.Ключ, ДанныеПоВалюте);
		КонецЕсли;
	КонецЦикла;
	
	ВыборкаПоДокументу = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоДокументу.Следующий() Цикл
		
		КурсВалютыДокумента = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВыборкаПоДокументу.Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		ОбщаяСумма          = ВыборкаПоДокументу.СуммаБезНДС + ВыборкаПоДокументу.СуммаНДС;
		Распределено        = 0;
		
		Для каждого ТекущаяВалютаДляПересчета из СтруктураВалют Цикл
			Валюта = ТекущаяВалютаДляПересчета.Значение.Валюта;
			Если Валюта <> ВыборкаПоДокументу.Валюта Тогда
				КурсВалюты = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
				ТекущаяВалютаДляПересчета.Значение.ОбщаяСумма = ОбщаяСумма * КурсВалютыДокумента / КурсВалюты;
				ТекущаяВалютаДляПересчета.Значение.Распределено = 0;
			КонецЕсли;
		КонецЦикла;
		
		Выборка = ВыборкаПоДокументу.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Сумма = Выборка.СуммаБезНДС + Выборка.СуммаНДС;
			
			НоваяЗапись = ПересчитанныеСуммыДокументов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Выборка);
			
			Если ОбщаяСумма = 0 Тогда
				
				Для каждого ТекущаяВалютаДляПересчета из СтруктураВалют Цикл
					НоваяЗапись["СуммаНДС"+ТекущаяВалютаДляПересчета.Ключ] = 0;
					НоваяЗапись["СуммаБезНДС"+ТекущаяВалютаДляПересчета.Ключ] = 0;
				КонецЦикла;
				
				Продолжить;
				
			КонецЕсли;
			
			Для каждого ТекущаяВалютаДляПересчета из СтруктураВалют Цикл
				
				ДанныеВалюты = ТекущаяВалютаДляПересчета.Значение;
				
				Если ДанныеВалюты.Валюта = Выборка.Валюта Тогда
					ВалютнаяСумма = Сумма;
					ВалютнаяСуммаНДС = Выборка.СуммаНДС;
				Иначе
					ВалютнаяСумма = Окр(ДанныеВалюты.ОбщаяСумма * (Распределено + Сумма) / ОбщаяСумма, 2) - ДанныеВалюты.Распределено;
				
					ДанныеВалюты.Распределено = ДанныеВалюты.Распределено + ВалютнаяСумма;
					ТекПроцентНДС = ЦенообразованиеКлиентСервер.ПолучитьСтавкуНДСЧислом(Выборка.СтавкаНДС);
					ВалютнаяСуммаНДС = ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(ВалютнаяСумма, ТекПроцентНДС);
				КонецЕсли;
				
				НоваяЗапись["СуммаНДС"+ТекущаяВалютаДляПересчета.Ключ] = ВалютнаяСуммаНДС;
				НоваяЗапись["СуммаБезНДС"+ТекущаяВалютаДляПересчета.Ключ] = ВалютнаяСумма - ВалютнаяСуммаНДС;
				
			КонецЦикла;
			
			Распределено = Распределено + Сумма;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Запрос.Текст = "
	|УНИЧТОЖИТЬ ТаблицаТоваровПредварительная;
	|ВЫБРАТЬ";
	Для Каждого Колонка Из ПересчитанныеСуммыДокументов.Колонки Цикл
		Запрос.Текст = Запрос.Текст + "
		|Таблица." + Колонка.Имя + ",";
	КонецЦикла;
	Запрос.Текст = Лев(Запрос.Текст, СтрДлина(Запрос.Текст)-1);
	Запрос.Текст = Запрос.Текст + "
	|ПОМЕСТИТЬ ТаблицаТоваровПредварительная
	|ИЗ &Таблица КАК Таблица";
	Запрос.УстановитьПараметр("Таблица", ПересчитанныеСуммыДокументов);
	Запрос.Выполнить();
	
КонецПроцедуры

// Удаляет повторяющиеся элементы массива.
//
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве 		   = Новый Соответствие; 
		БылоНеопределено 	   = Ложь;
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента    = ТипЗнч(ЭлементМассива); 
			
			Если ЭлементМассива = Неопределено Тогда
				
				Если БылоНеопределено ИЛИ НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				
				Продолжить;
				
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
			
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	ЗначениеКлавиша						- Клавиша
//
// Возвращаемое значение
//	Строка - Представление клавиши
//
Функция ПредставлениеКлавиши(ЗначениеКлавиша) Экспорт
	
	Если Строка(Клавиша._1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "1";
	ИначеЕсли Строка(Клавиша._2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "2";
	ИначеЕсли Строка(Клавиша._3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "3";
	ИначеЕсли Строка(Клавиша._4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "4";
	ИначеЕсли Строка(Клавиша._5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "5";
	ИначеЕсли Строка(Клавиша._6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "6";
	ИначеЕсли Строка(Клавиша._7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "7";
	ИначеЕсли Строка(Клавиша._8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "8";
	ИначеЕсли Строка(Клавиша._9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "9";
	ИначеЕсли Строка(Клавиша.Num0) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 0";
	ИначеЕсли Строка(Клавиша.Num1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 1";
	ИначеЕсли Строка(Клавиша.Num2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 2";
	ИначеЕсли Строка(Клавиша.Num3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 3";
	ИначеЕсли Строка(Клавиша.Num4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 4";
	ИначеЕсли Строка(Клавиша.Num5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 5";
	ИначеЕсли Строка(Клавиша.Num6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 6";
	ИначеЕсли Строка(Клавиша.Num7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 7";
	ИначеЕсли Строка(Клавиша.Num8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 8";
	ИначеЕсли Строка(Клавиша.Num9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 9";
	ИначеЕсли Строка(Клавиша.NumAdd) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num +";
	ИначеЕсли Строка(Клавиша.NumDecimal) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num .";
	ИначеЕсли Строка(Клавиша.NumDivide) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num /";
	ИначеЕсли Строка(Клавиша.NumMultiply) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num *";
	ИначеЕсли Строка(Клавиша.NumSubtract) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num -";
	Иначе
		Возврат Строка(ЗначениеКлавиша);
	КонецЕсли;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	СочетаниеКлавиш						- Сочетание клавиш для которого нужно сформировать представление
//	БезСкобок							- Флаг, указывающий, что представление должно быть сформировано без скобок
//
// Возвращаемое значение
//	Строка - Представление сочетания клавиш
//
Функция ПредставлениеСочетанияКлавиш(СочетаниеКлавиш, БезСкобок = Ложь) Экспорт
	
	Если СочетаниеКлавиш.Клавиша = Клавиша.Нет Тогда
		Возврат "";
	КонецЕсли;
	
	Наименование = ?(БезСкобок, "", "(");
	Если СочетаниеКлавиш.Ctrl Тогда
		Наименование = Наименование + "Ctrl+"
	КонецЕсли;
	Если СочетаниеКлавиш.Alt Тогда
		Наименование = Наименование + "Alt+"
	КонецЕсли;
	Если СочетаниеКлавиш.Shift Тогда
		Наименование = Наименование + "Shift+"
	КонецЕсли;
	Наименование = Наименование + ПредставлениеКлавиши(СочетаниеКлавиш.Клавиша) + ?(БезСкобок, "", ")");
	
	Возврат Наименование;
	
КонецФункции

// Устанавливае свойство ОтображениеСтраницФормы в Нет, если фактически отображается только одна закладка
// Параметры:
//  ЭлементСтраница  - ГруппаФормы - страница, для которой определяется необходимость отображения закладок.
//
Процедура УдалитьЗакладкиЕслиСтраницаОдна(ЭлементСтраница) Экспорт
	
	Если ЭлементСтраница.ПодчиненныеЭлементы.Количество() = 1 Тогда
		ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
	Иначе
		КоличествоВидимыхСтраниц = 0;
		Для Каждого ПодчиненнаяСтраница Из ЭлементСтраница.ПодчиненныеЭлементы Цикл
			
			Если КоличествоВидимыхСтраниц > 1 Тогда
				Прервать;
			КонецЕсли;
			
			Для Каждого ЭлементСтраницы Из ПодчиненнаяСтраница.ПодчиненныеЭлементы Цикл
				
				Если ЭлементСтраницы.Видимость Тогда
					КоличествоВидимыхСтраниц = КоличествоВидимыхСтраниц + 1;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если КоличествоВидимыхСтраниц = 1 Тогда
			ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Служебная процедура.
//
Процедура ПересчитатьТаблицуТоваровВВалютуУпр(МенеджерВременныхТаблиц) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	ТаблицаТоваровВВалютеУпр
	|
	|ИТОГИ
	|	СУММА(ТаблицаТоваровВВалютеУпр.СуммаБезНДС),
	|	СУММА(ТаблицаТоваровВВалютеУпр.СуммаНДС),
	|	МАКСИМУМ(ТаблицаТоваровВВалютеУпр.Валюта),
	|	МАКСИМУМ(ТаблицаТоваровВВалютеУпр.Дата)
	|ПО
	|	ТаблицаТоваровВВалютеУпр.Ссылка
	|";
	РезультатЗапроса = Запрос.Выполнить();
	
	ПересчитанныеСуммыДокументов = Новый ТаблицаЗначений;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		ПересчитанныеСуммыДокументов.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	        
	ВалютаУпр = Константы.ВалютаУправленческогоУчета.Получить();
	КэшКурсовВалют = РаботаСКурсамиВалютУТ.ИнициализироватьКэшКурсовВалют();
	
	ВыборкаПоДокументу = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоДокументу.Следующий() Цикл
		
		КурсВалютыДокумента = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВыборкаПоДокументу.Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		КурсВалютыУпр      = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВалютаУпр, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		
		СуммаДокумента     = ВыборкаПоДокументу.СуммаБезНДС + ВыборкаПоДокументу.СуммаНДС;
		СуммаДокументаРегл = СуммаДокумента * КурсВалютыДокумента / КурсВалютыУпр;
		
		УчтеноБазыРаспределения = 0;
		УжеРаспределено = 0;
		
		Выборка = ВыборкаПоДокументу.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			СуммаСНДС = Выборка.СуммаБезНДС + Выборка.СуммаНДС;
			
			СуммаСНДСРегл = ?(СуммаДокумента <> 0, Окр(СуммаДокументаРегл * (УчтеноБазыРаспределения + СуммаСНДС) / СуммаДокумента, 2) - УжеРаспределено, 0);
			
			УчтеноБазыРаспределения = УчтеноБазыРаспределения + СуммаСНДС;
			УжеРаспределено         = УжеРаспределено + СуммаСНДСРегл;
			
			НоваяЗапись = ПересчитанныеСуммыДокументов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Выборка, , "СуммаНДС, СуммаБезНДС");
			
			ТекПроцентНДС = ЦенообразованиеКлиентСервер.ПолучитьСтавкуНДСЧислом(Выборка.СтавкаНДС);
			
			НоваяЗапись.СуммаНДС    = ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(СуммаСНДСРегл, ТекПроцентНДС);
			НоваяЗапись.СуммаБезНДС = СуммаСНДСРегл - НоваяЗапись.СуммаНДС;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Запрос.Текст = "
	|УНИЧТОЖИТЬ ТаблицаТоваровВВалютеУпр;
	|ВЫБРАТЬ";
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		Запрос.Текст = Запрос.Текст + "
		|Таблица." + Колонка.Имя + ",";
	КонецЦикла;
	Запрос.Текст = Лев(Запрос.Текст, СтрДлина(Запрос.Текст)-1);
	Запрос.Текст = Запрос.Текст + "
	|ПОМЕСТИТЬ ТаблицаТоваровВВалютеУпр
	|ИЗ &Таблица КАК Таблица";
	Запрос.УстановитьПараметр("Таблица", ПересчитанныеСуммыДокументов);
	Запрос.Выполнить();
	
КонецПроцедуры

#КонецОбласти

#Область ЗаполненияТабличныхЧастейДокумента

// Функция возвращает параметры проверки заполнения количества
// 
// Возвращаемое значение:
//  Структура - структура параметров:
//  	*ИмяТЧ - Строка - значение по умолчанию "Товары"
//  	*СуффиксДопРеквизита - Строка - значение по умолчанию "" - если в ТЧ два реквизита "Количество", то второй назван с суффиксом.
//  		если суффикс передан, то проверяются оба реквизита
//  	*ПроверитьВозможностьОкругления - Булево - Истина если нужно проверить возможность округления
//  	*УсловиеОтбораСтрокДляОкругления - Строка - Условие выбора строк для проверки округления.
//  		в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ
//  	*ПроверитьКомплектностьТоварныхМест - Булево - Флаг необхоидмости проверки комплектности товарных есть.
//  	*УсловиеОтбораСтрокПроверкиКомплектности - Строка - строка условия для запроса. Например, "Не ТаблицаТовары.ЭтоУпаковочныйЛист"
//  	*ПоляГруппировкиПроверкиКомплектности - Строка - Поля, по которым группируются товары для формирования целых товаров из товарных мест. 
//			Поля "Номенклатура", "Характеристика" и "Серия" будут добавлены по умолчанию. 
//			Поле "<Приставка>Назначение" нужно добавлять, если имя колонки отлично от строки "Назначение". Например, "НовоеНазначение".
//
Функция ПараметрыПроверкиЗаполненияКоличества() Экспорт
	
	ПараметрыПроверки = Новый Структура;
	ПараметрыПроверки.Вставить("ИмяТЧ",                           		"Товары");	
	ПараметрыПроверки.Вставить("ПутьКДанным",                     "Объект");
	ПараметрыПроверки.Вставить("СуффиксДопРеквизита",             		"");
	ПараметрыПроверки.Вставить("ПроверитьВозможностьОкругления",  		Истина);
	ПараметрыПроверки.Вставить("УсловиеОтбораСтрокДляОкругления", 		"");
	ПараметрыПроверки.Вставить("ПроверитьКомплектностьТоварныхМест", 	Ложь);
	ПараметрыПроверки.Вставить("УсловиеОтбораСтрокПроверкиКомплектности", "");
	ПараметрыПроверки.Вставить("ПоляГруппировкиПроверкиКомплектности", 	"");
	
	Возврат ПараметрыПроверки;
	
КонецФункции

// Процедуры проверки заполнения реквизита Количество и КоличествоУпаковок в документах.
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ПроверяемыеРеквизиты - массив проверяемых реквизитов
//	Отказ - отказ продолжения операции
Процедура ПроверитьЗаполнениеКоличества(Объект, ПроверяемыеРеквизиты, Отказ, ПараметрыПроверки = Неопределено) Экспорт
	
	Перем ЗаполнятьРеквизитОбязательно;
	Перем ЗаполнятьДопРеквизитОбязательно;
	
	Если ПараметрыПроверки = Неопределено Тогда
		ПараметрыПроверки = ПараметрыПроверкиЗаполненияКоличества();
	КонецЕсли;
	
	ИмяТЧ               = ПараметрыПроверки.ИмяТЧ;
	СуффиксДопРеквизита = ПараметрыПроверки.СуффиксДопРеквизита;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	Если ИмяТЧ = "Объект" Тогда
		
		ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти("Количество"));
		ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти("КоличествоУпаковок"));

		Если Объект.Количество = 0 И Объект.КоличествоУпаковок <> 0 Тогда

			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = 'Обнаружено нулевое количество при пересчете в единицу хранения'"),
					КлючДанных,
					"КоличествоУпаковок",
					,
					Отказ);

		ИначеЕсли Объект.Количество = 0 Или Объект.КоличествоУпаковок = 0 Тогда

			ТекстСообщения = НСтр("ru = 'Не заполнено поле ""%ПредставлениеПоляКоличество%""'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеПоляКоличество%", Объект.Метаданные().Реквизиты.Количество.Синоним);
			
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,
					КлючДанных,
					"КоличествоУпаковок",
					,
					Отказ);
				
		КонецЕсли;
	Иначе
		МетаданныеОбъекта = Объект.Метаданные();
		                                 
		РеквизитПроверки =  ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".КоличествоУпаковок");
		ЗаполнятьРеквизитОбязательно = РеквизитПроверки <> Неопределено;
		Если РеквизитПроверки <> Неопределено Тогда
			ПроверяемыеРеквизиты.Удалить(РеквизитПроверки);
			ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".Количество"));
		КонецЕсли;
		
		ПредставлениеТЧ = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
		ПредставлениеРеквизитаКоличествоУпаковок = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты.КоличествоУпаковок.Синоним;
		Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
			РеквизитПроверки =  ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".КоличествоУпаковок"+СуффиксДопРеквизита);
			ЗаполнятьДопРеквизитОбязательно = РеквизитПроверки <> Неопределено;
			Если РеквизитПроверки <> Неопределено Тогда
				ПроверяемыеРеквизиты.Удалить(РеквизитПроверки);
				ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".Количество"+СуффиксДопРеквизита));
			КонецЕсли;
			ПредставлениеРеквизитаКоличествоУпаковокДоп  = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты["КоличествоУпаковок"+СуффиксДопРеквизита].Синоним;
		Иначе
			ЗаполнятьДопРеквизитОбязательно = Ложь;
			ПредставлениеРеквизитаКоличествоУпаковокДоп = "";
		КонецЕсли;
		
		ШаблонОшибкаКоличества = НСтр("ru = 'Не заполнена колонка ""%ПредставлениеКолонки%"" в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""'");
		ШаблонОшибкаКоличества = СтрЗаменить(ШаблонОшибкаКоличества, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ШаблонОшибкаПересчета = НСтр("ru = 'Обнаружено нулевое количество при пересчете в единицу хранения в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""'");
		ШаблонОшибкаПересчета = СтрЗаменить(ШаблонОшибкаПересчета, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		
		Для Каждого СтрокаТаб Из Объект[ИмяТЧ] Цикл
			
			Если СтрокаТаб.Количество = 0 
				И СтрокаТаб.КоличествоУпаковок <> 0 Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаПересчета, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
				
			ИначеЕсли ЗаполнятьРеквизитОбязательно
				И (СтрокаТаб.Количество = 0
				Или СтрокаТаб.КоличествоУпаковок = 0) Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаКоличества, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеКолонки%", ПредставлениеРеквизитаКоличествоУпаковок);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
						
			КонецЕсли;
			
			
			Если Не ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Продолжить;
			КонецЕсли;
			
			Если СтрокаТаб["Количество"+СуффиксДопРеквизита] = 0 
				И СтрокаТаб["КоличествоУпаковок"+СуффиксДопРеквизита] <> 0 Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаПересчета, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок"+СуффиксДопРеквизита);
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
				
			ИначеЕсли ЗаполнятьДопРеквизитОбязательно
				И (СтрокаТаб["Количество"+СуффиксДопРеквизита] = 0
				Или СтрокаТаб["КоличествоУпаковок"+СуффиксДопРеквизита]  = 0) Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаКоличества, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеКолонки%", ПредставлениеРеквизитаКоличествоУпаковокДоп);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки,"КоличествоУпаковок"+СуффиксДопРеквизита);
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
						
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.Номенклатура КАК Номенклатура,
	|	ТЧ.КоличествоУпаковок КАК КоличествоУпаковок,
	|	ТЧ.Количество КАК КоличествоВДокументе,
	|	ВЫРАЗИТЬ(ТЧ.Упаковка КАК Справочник.УпаковкиЕдиницыИзмерения) КАК Упаковка,
	|	&ИмяПоляКоличествоУпаковокСуффикс КАК КоличествоУпаковокСуффикс,
	|	&ИмяПоляКоличествоСуффикс КАК КоличествоВДокументеСуффикс
	|ПОМЕСТИТЬ ВТДляЗапроса
	|ИЗ
	|	&ТЧ КАК ТЧ
	|ГДЕ
	|	ТЧ.Упаковка <> ЗНАЧЕНИЕ(Справочник.УпаковкиЕдиницыИзмерения.ПустаяСсылка)
	|	И &УсловиеОтбораСтрокДляОкругления
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТДляЗапроса.НомерСтроки,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.Упаковка КАК Справочник.УпаковкиЕдиницыИзмерения).ТипИзмеряемойВеличины В (&МерныеТипы) КАК МожноОкруглять,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.Номенклатура КАК Справочник.Номенклатура).ЕдиницаИзмерения КАК БазоваяЕдиницаИзмерения,
	|	ВТДляЗапроса.Номенклатура,
	|	ВТДляЗапроса.Упаковка,
	|	&ТекстЗапросаКоэффициентУпаковки КАК КоэффициентУпаковки,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковок * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК Количество,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковок * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 0)) КАК КоличествоОкругленное,
	|	ВТДляЗапроса.КоличествоВДокументе КАК КоличествоВДокументе,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковокСуффикс * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоСуффикс,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковокСуффикс * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 0)) КАК КоличествоСуффиксОкругленное,
	|	ВТДляЗапроса.КоличествоВДокументеСуффикс КАК КоличествоВДокументеСуффикс
	|ПОМЕСТИТЬ ВТ
	|ИЗ
	|	ВТДляЗапроса КАК ВТДляЗапроса  
	|ГДЕ
	|	ЕСТЬNULL(ВТДляЗапроса.Упаковка.ТипУпаковки, НЕОПРЕДЕЛЕНО) <> ЗНАЧЕНИЕ(Перечисление.ТипыУпаковокНоменклатуры.ТоварноеМесто)
	|	И ВЫРАЗИТЬ(ВТДляЗапроса.Номенклатура КАК Справочник.Номенклатура).ЕдиницаИзмерения.ТипИзмеряемойВеличины = &ШтучныйТип
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ПРЕДСТАВЛЕНИЕ(ТЧ.БазоваяЕдиницаИзмерения) КАК БазоваяЕдиницаИзмерения,
	|	ПРЕДСТАВЛЕНИЕ(ТЧ.Упаковка) КАК Упаковка,
	|	ТЧ.КоличествоОкругленное КАК КоличествоОкругленное,
	|	ТЧ.КоличествоСуффиксОкругленное КАК КоличествоСуффиксОкругленное,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА ВЫБОР
	|						КОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное > 0
	|							ТОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное
	|						ИНАЧЕ ТЧ.КоличествоОкругленное - ТЧ.Количество
	|					КОНЕЦ
	|			ИНАЧЕ ВЫБОР
	|					КОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество > 0
	|						ТОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество
	|					ИНАЧЕ ТЧ.Количество - ТЧ.КоличествоВДокументе
	|				КОНЕЦ
	|		КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоОтклонение,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоОкругленное / ТЧ.КоэффициентУпаковки / 100
	|			ИНАЧЕ 0
	|		КОНЕЦ КАК ЧИСЛО(15, 3)) КАК КоличествоМаксимальнаяПогрешность,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|				ТОГДА ВЫБОР
	|						КОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное > 0
	|							ТОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное
	|						ИНАЧЕ ТЧ.КоличествоСуффиксОкругленное - ТЧ.КоличествоСуффикс
	|					КОНЕЦ
	|			ИНАЧЕ ВЫБОР
	|					КОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс > 0
	|						ТОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс
	|					ИНАЧЕ ТЧ.КоличествоСуффикс - ТЧ.КоличествоВДокументеСуффикс
	|				КОНЕЦ
	|		КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоСуффиксОтклонение,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоСуффиксОкругленное / ТЧ.КоэффициентУпаковки / 100
	|			ИНАЧЕ 0
	|		КОНЕЦ КАК ЧИСЛО(15, 3)) КАК КоличествоСуффиксМаксимальнаяПогрешность
	|ИЗ
	|	ВТ КАК ТЧ
	|ГДЕ
	|	((ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА ВЫБОР
	|								КОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное > 0
	|									ТОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное
	|								ИНАЧЕ ТЧ.КоличествоОкругленное - ТЧ.Количество
	|							КОНЕЦ
	|					ИНАЧЕ ВЫБОР
	|							КОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество > 0
	|								ТОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество
	|							ИНАЧЕ ТЧ.Количество - ТЧ.КоличествоВДокументе
	|						КОНЕЦ
	|				КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3))) > (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоОкругленное / ТЧ.КоэффициентУпаковки / 100
	|					ИНАЧЕ 0
	|				КОНЕЦ КАК ЧИСЛО(15, 3)))
	|			ИЛИ (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА ВЫБОР
	|								КОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное > 0
	|									ТОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное
	|								ИНАЧЕ ТЧ.КоличествоСуффиксОкругленное - ТЧ.КоличествоСуффикс
	|							КОНЕЦ
	|					ИНАЧЕ ВЫБОР
	|							КОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс > 0
	|								ТОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс
	|							ИНАЧЕ ТЧ.КоличествоСуффикс - ТЧ.КоличествоВДокументеСуффикс
	|						КОНЕЦ
	|				КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3))) > (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоСуффиксОкругленное / ТЧ.КоэффициентУпаковки / 100
	|					ИНАЧЕ 0
	|				КОНЕЦ КАК ЧИСЛО(15, 3))))
	|
	|УПОРЯДОЧИТЬ ПО
	|	НомерСтроки";

	
	Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "ТЧ.Количество"+СуффиксДопРеквизита);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоУпаковокСуффикс", "ТЧ.КоличествоУпаковок"+СуффиксДопРеквизита);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "0");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоУпаковокСуффикс", "0");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекстЗапросаКоэффициентУпаковки",
		Справочники.УпаковкиЕдиницыИзмерения.ТекстЗапросаКоэффициентаУпаковки(
			"ВТДляЗапроса.Упаковка",
			"ВТДляЗапроса.Номенклатура"));
			
	Если ПараметрыПроверки.УсловиеОтбораСтрокДляОкругления <> "" Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", 
									СтрЗаменить(ПараметрыПроверки.УсловиеОтбораСтрокДляОкругления, ИмяТЧ + ".", "ТЧ."));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", "ИСТИНА");
	КонецЕсли; 
			
	Если ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
		ДопустимыйПроцентОтклонения = Константы.ДопустимоеОтклонениеПриОкругленииКоличества.Получить();
	Иначе
		ДопустимыйПроцентОтклонения = 0;
	КонецЕсли;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Если ИмяТЧ = "Объект" Тогда
		
		Таблица = Новый ТаблицаЗначений;
		Таблица.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("КоличествоУпаковок", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		
		СтрокаТаблицы = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, Объект);
		
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОбработкаОбъект.ПодборСерийВДокументы") Тогда 
		Таблица = Объект[ИмяТЧ].Выгрузить();
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.ЗаполнитьЗначения(Объект.ПараметрыПроверки.Номенклатура, "Номенклатура");
		Таблица.ЗаполнитьЗначения(Объект.ПараметрыПроверки.Упаковка, "Упаковка");
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	Иначе	
		Запрос.УстановитьПараметр("ТЧ", Объект[ИмяТЧ].Выгрузить());
	КонецЕсли;	
	
	Запрос.УстановитьПараметр("ДопустимыйПроцентОтклонения", ДопустимыйПроцентОтклонения);
	Запрос.УстановитьПараметр("ПроверитьВозможностьОкругления", ПараметрыПроверки.ПроверитьВозможностьОкругления);
	
	МерныеТипы = Новый Массив;
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Вес);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Объем);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Площадь);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Длина);
	Запрос.УстановитьПараметр("МерныеТипы", МерныеТипы);
	Запрос.УстановитьПараметр("ШтучныйТип", Перечисления.ТипыИзмеряемыхВеличин.КоличествоШтук);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если ИмяТЧ = "Объект" Тогда
		Если Не ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'Количество в ""%Упаковка%"" переведено в количество в ""%БазоваяЕдиницаИзмерения%"" с погрешностью - %КоличествоОтклонение% %Упаковка%, что недопустимо, что свидетельствует об ошибке в работе программы. Обратитесь к администратору.'");
		ИначеЕсли ДопустимыйПроцентОтклонения > 0 Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'После округления количество товара будет равно %КоличествоОкругленное% %БазоваяЕдиницаИзмерения%, при этом погрешность округления составит %КоличествоОтклонение% %Упаковка%, что превышает максимальную погрешность - %КоличествоМаксимальнаяПогрешность% %Упаковка%.'");
		Иначе
			ШаблонОшибкаОкругления = НСтр("ru = 'Количество в ""%Упаковка%"" некратно количеству в ""%БазоваяЕдиницаИзмерения%"". Отклонение - %КоличествоОтклонение% %Упаковка%.'");
		КонецЕсли;
	Иначе
		Если Не ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" количество в ""%Упаковка%"" переведено в количество в ""%БазоваяЕдиницаИзмерения%"" с отклонением - %КоличествоОтклонение% %Упаковка%, что свидетельствует об ошибке в работе программы. Обратитесь к администратору.'");
		ИначеЕсли ДопустимыйПроцентОтклонения > 0 Тогда
			ШаблонОшибкаОкругления = НСтр("ru = 'После округления количество товара будет равно %КоличествоОкругленное% %БазоваяЕдиницаИзмерения% в строке %НомерСтроки% списка ""%ПредставлениеТЧ%"", при этом погрешность округления составит %КоличествоОтклонение% %Упаковка%, что превышает максимальную погрешность - %КоличествоМаксимальнаяПогрешность% %Упаковка%.'");
		Иначе 
			ШаблонОшибкаОкругления = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" количество в ""%Упаковка%"" некратно количеству в ""%БазоваяЕдиницаИзмерения%"". Отклонение - %КоличествоОтклонение% %Упаковка%.'");
		КонецЕсли;
		ШаблонОшибкаОкругления = СтрЗаменить(ШаблонОшибкаОкругления, "%ПредставлениеТЧ%", ПредставлениеТЧ);
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		Если Выборка.КоличествоОтклонение > Выборка.КоличествоМаксимальнаяПогрешность Тогда
			ТекстСообщения = ШаблонОшибкаОкругления;
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%БазоваяЕдиницаИзмерения%", Выборка.БазоваяЕдиницаИзмерения);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОтклонение%", Выборка.КоличествоОтклонение);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Упаковка%", Выборка.Упаковка);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоМаксимальнаяПогрешность%", Выборка.КоличествоМаксимальнаяПогрешность);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОкругленное%", Выборка.КоличествоОкругленное);
			Если ИмяТЧ = "Объект" Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, КлючДанных, "КоличествоУпаковок", ПараметрыПроверки.ПутьКДанным, Отказ);
			Иначе
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Строка(Выборка.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "КоличествоУпаковок");
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
			КонецЕсли;
		КонецЕсли;
		Если Выборка.КоличествоСуффиксОтклонение > Выборка.КоличествоСуффиксМаксимальнаяПогрешность Тогда
			ТекстСообщения = ШаблонОшибкаОкругления;
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%БазоваяЕдиницаИзмерения%", Выборка.БазоваяЕдиницаИзмерения);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОтклонение%", Выборка.КоличествоСуффиксОтклонение);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Упаковка%", Выборка.Упаковка);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоМаксимальнаяПогрешность%", Выборка.КоличествоСуффиксМаксимальнаяПогрешность);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОкругленное%", Выборка.КоличествоСуффиксОкругленное);
			Если ИмяТЧ = "Объект" Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, КлючДанных, "КоличествоУпаковок"+СуффиксДопРеквизита, ПараметрыПроверки.ПутьКДанным, Отказ);
			Иначе
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Строка(Выборка.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "КоличествоУпаковок"+СуффиксДопРеквизита);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,ПараметрыПроверки.ПутьКДанным,Отказ);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ПараметрыПроверки.ПроверитьКомплектностьТоварныхМест Тогда 
		НоменклатураСервер.ПроверитьКомплектностьТоварныхМест(Объект[ИмяТЧ], Отказ, ПараметрыПроверки);
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает параметры для округления
//
//	Возвращаемое значение:
//		Структура:
//			*ИмяТЧ - Строка - значение по умолчанию "Товары"
//			*СуффиксДопРеквизита - Строка - значение по умолчанию "" - если в ТЧ два реквизита "Количество", то второй назван с суффиком. 
//											если суффикс передан, то проверяются оба реквизита
//			*УсловиеОтбораСтрокДляОкругления - Строка - Условие выбора строк для проверки округления.
//											в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ
//
Функция ПараметрыОкругленияКоличестваШтучныхТоваров() Экспорт
	
	ПараметрыОкругления = Новый Структура;
	ПараметрыОкругления.Вставить("ИмяТЧ",                           "Товары");	
	ПараметрыОкругления.Вставить("СуффиксДопРеквизита",             "");
	ПараметрыОкругления.Вставить("УсловиеОтбораСтрокДляОкругления", "");
	
	Возврат ПараметрыОкругления;
	
КонецФункции

// Округляет количество товара до целых штук при указании количества в документе в мерных единицах измерения
//
Процедура ОкруглитьКоличествоШтучныхТоваров(Объект, РежимЗаписи = Неопределено, ПараметрыОкругления = Неопределено) Экспорт
	
	Если РежимЗаписи <> Неопределено 
		И РежимЗаписи <> РежимЗаписиДокумента.Проведение
		И ТипЗнч(РежимЗаписи) = Тип("РежимЗаписиДокумента")
		И Объект.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОкругления = Неопределено Тогда
		ПараметрыОкругления = ПараметрыПроверкиЗаполненияКоличества();
	КонецЕсли;
	
	СуффиксДопРеквизита = ПараметрыОкругления.СуффиксДопРеквизита;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.Номенклатура КАК Номенклатура,
	|	ТЧ.Упаковка,
	|	ВЫРАЗИТЬ(ТЧ.Количество КАК ЧИСЛО(15, 0)) КАК КоличествоОкругленное,
	|	ВЫРАЗИТЬ(&ИмяПоляКоличествоСуффикс КАК ЧИСЛО(15, 0)) КАК КоличествоСуффиксОкругленное
	|ПОМЕСТИТЬ ВТ
	|ИЗ
	|	&ТЧ КАК ТЧ
	|ГДЕ
	|	ТЧ.Упаковка <> ЗНАЧЕНИЕ(Справочник.УпаковкиЕдиницыИзмерения.ПустаяСсылка)
	|	И (ТЧ.Количество <> (ВЫРАЗИТЬ(ТЧ.Количество КАК ЧИСЛО(15, 0)))
	|			ИЛИ &ИмяПоляКоличествоСуффикс <> (ВЫРАЗИТЬ(&ИмяПоляКоличествоСуффикс КАК ЧИСЛО(15, 0))))
	|	И (&УсловиеОтбораСтрокДляОкругления)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.КоличествоОкругленное КАК КоличествоОкругленное,
	|	ТЧ.КоличествоСуффиксОкругленное КАК КоличествоСуффиксОкругленное
	|ИЗ
	|	ВТ КАК ТЧ
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК ТНоменклатура
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.УпаковкиЕдиницыИзмерения КАК ТУпаковкиЕдиницыХранения
	|			ПО (ТУпаковкиЕдиницыХранения.Ссылка = ТНоменклатура.ЕдиницаИзмерения)
	|				И (ТУпаковкиЕдиницыХранения.ТипИзмеряемойВеличины = &ШтучныйТип)
	|		ПО (ТНоменклатура.Ссылка = ТЧ.Номенклатура)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.УпаковкиЕдиницыИзмерения КАК ТУпаковкиТЧ
	|		ПО (ТУпаковкиТЧ.Ссылка = ТЧ.Упаковка)
	|			И (ТУпаковкиТЧ.ТипИзмеряемойВеличины В (&МерныеТипы))";
	
	Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "ТЧ.Количество"+СуффиксДопРеквизита);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "0");
	КонецЕсли;
	
	Если ПараметрыОкругления.УсловиеОтбораСтрокДляОкругления <> "" Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", 
									СтрЗаменить(ПараметрыОкругления.УсловиеОтбораСтрокДляОкругления, ПараметрыОкругления.ИмяТЧ + ".", "ТЧ."));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", "ИСТИНА");
	КонецЕсли; 
	
	Запрос = Новый Запрос(ТекстЗапроса);
		
	Если ПараметрыОкругления.ИмяТЧ = "Объект" Тогда
		
		Таблица = Новый ТаблицаЗначений;
		Таблица.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		
		СтрокаТаблицы = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, Объект);
		
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	Иначе	
		Запрос.УстановитьПараметр("ТЧ", Объект[ПараметрыОкругления.ИмяТЧ].Выгрузить());
	КонецЕсли;	
	
	МерныеТипы = Новый Массив;
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Вес);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Объем);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Площадь);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Длина);
	Запрос.УстановитьПараметр("МерныеТипы", МерныеТипы);
	Запрос.УстановитьПараметр("ШтучныйТип", Перечисления.ТипыИзмеряемыхВеличин.КоличествоШтук);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если ПараметрыОкругления.ИмяТЧ = "Объект" Тогда
			Объект.Количество = Выборка.КоличествоОкругленное;
			Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Объект["Количество" + СуффиксДопРеквизита] = Выборка.КоличествоСуффиксОкругленное;
			КонецЕсли;
		Иначе
			Объект[ПараметрыОкругления.ИмяТЧ][Выборка.НомерСтроки - 1].Количество = Выборка.КоличествоОкругленное;
			Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Объект[ПараметрыОкругления.ИмяТЧ][Выборка.НомерСтроки - 1]["Количество" + СуффиксДопРеквизита] = Выборка.КоличествоСуффиксОкругленное;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура проверяет дубли строк в табличной части
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ИмяТЧ - имя проверяемой табличной части
//	КлючевыеРеквизиты - массив имен реквизитов, по которым определяется уникальность строки
//	Отказ - отказ продолжения операции
Процедура ПроверитьНаличиеДублейСтрокТЧ(Объект,ИмяТЧ,КлючевыеРеквизиты,Отказ, ПредставлениеТЧ = "", УказыватьНомераСтрок = Истина) Экспорт
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	МетаданныеОбъекта = Объект.Метаданные();
	Если ПустаяСтрока(ПредставлениеТЧ) Тогда
		ПредставлениеТЧ   = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
	КонецЕсли;
	
	ТекстПоляВыборки = "";
	ТекстПоляСоединения = "";	
    ТекстПоляВыгрузки = "";
	ТекстДляСообщенияОДублях = "";
	Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
		ТекстПоляВыборки = ТекстПоляВыборки + "
			|	ТаблицаПроверки." + СтрМас + ",";
		ТекстПоляСоединения = ТекстПоляСоединения + "
			|	И ТаблицаПроверки." + СтрМас + " = ДублирующиесяСтроки."+ СтрМас;
		ТекстПоляВыгрузки = ТекстПоляВыгрузки + СтрМас + ",";
		
		ПредставлениеРеквизита = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты[СтрМас].Синоним;
		
		ТекстДляСообщенияОДублях = ТекстДляСообщенияОДублях + """"  + ПредставлениеРеквизита  + """, "
	КонецЦикла;	
	
	ТекстДляСообщенияОДублях = Лев(ТекстДляСообщенияОДублях, СтрДлина(ТекстДляСообщенияОДублях) - 2);
	
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыборки,1);
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыгрузки,1);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ 
	|	ТаблицаПроверки.НомерСтроки, " +
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ТаблицаПроверки
	|ИЗ
	|	&ТаблицаПроверки КАК ТаблицаПроверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ТаблицаПроверки.НомерСтроки) КАК НомерСтроки,
	|	СУММА(1) КАК КоличествоДублей,"+
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ДублирующиесяСтроки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|
	|СГРУППИРОВАТЬ ПО " +
		ТекстПоляВыборки + "
	|
	|ИМЕЮЩИЕ
	|	СУММА(1) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПроверки.НомерСтроки,
	|	ДублирующиесяСтроки.НомерСтроки КАК ПерваяСтрока,"+
		ТекстПоляВыборки + "
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДублирующиесяСтроки КАК ДублирующиесяСтроки
	|		ПО ТаблицаПроверки.НомерСтроки <> ДублирующиесяСтроки.НомерСтроки " +
	     		ТекстПоляСоединения;
	Запрос.УстановитьПараметр("ТаблицаПроверки",Объект[ИмяТЧ].Выгрузить(,"НомерСтроки," + ТекстПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если УказыватьНомераСтрок Тогда
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	Иначе
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в поле %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	КонецЕсли;
	Пока Выборка.Следующий() Цикл
		
		ТекстСообщения =  СтрЗаменить(ШаблонСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Выборка.НомерСтроки);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПерваяСтрока%", Выборка.ПерваяСтрока);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НазванияПолей%", ТекстДляСообщенияОДублях);
		
		ПовторяемоеЗначение = "";
		
		Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
			ПредставлениеЗначения = СокрЛП(Строка(Выборка[СтрМас]));
			Если ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
				ПовторяемоеЗначение = ПовторяемоеЗначение + Выборка[СтрМас] + "/";
			КонецЕсли;
		КонецЦикла;
		
		ПовторяемоеЗначение = Лев(ПовторяемоеЗначение, СтрДлина(ПовторяемоеЗначение) - 1);
		
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПовторяемоеЗначение%", ПовторяемоеЗначение);
		
		Если УказыватьНомераСтрок Тогда
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "НомерСтроки");
		Иначе
			Поле = ИмяТЧ;
		КонецЕсли;
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
		
	КонецЦикла;
КонецПроцедуры

// Процедура заполняет значения реквизитов табличной части по структуре
//
// Параметры:
// 		КоллекцияДанных - ДанныеФормыКоллекция - Табличная часть
// 		СтруктураРеквизитов - Структура - Структура. Ключ - имя реквизита флага активности. Значение - строка перечисления зависимых реквизитов
//
Процедура ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции(КоллекцияДанных, СтруктураРеквизитов) Экспорт
	
	// Получение шаблона поля выборки для значения дубликата реквизита
	// 		Если флаг активности ИСТИНА - скопировать значение из реквизита
	// 		Иначе - заполнить пустым значением
	ШаблонПоляВыборки = ",
	|	ВЫБОР КОГДА Коллекция.%ИмяФлага% = ИСТИНА
	|		ТОГДА Коллекция.%ИмяРеквизита%
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК %ИмяРеквизита%%ИмяФлага%";
	
	ПоляВыборки = ""; // Поля выборки для запроса получения данных
	ПоляВыгрузки = "НомерСтроки"; // Перечисление через запятую полей, выгружаемых из коллекции
	Для Каждого РеквизитФлага Из СтруктураРеквизитов Цикл
		ПоляВыгрузки = ПоляВыгрузки + ", " + РеквизитФлага.Ключ;
		ЗависимыеРеквизиты = Новый Структура(РеквизитФлага.Значение);
		Для Каждого ЗависимыйРеквизит Из ЗависимыеРеквизиты Цикл
			ПоляВыборки = ПоляВыборки + СтрЗаменить(СтрЗаменить(ШаблонПоляВыборки, "%ИмяФлага%", РеквизитФлага.Ключ), "%ИмяРеквизита%", ЗависимыйРеквизит.Ключ);
			ПоляВыгрузки = ПоляВыгрузки + ", " + ЗависимыйРеквизит.Ключ + ", " + ЗависимыйРеквизит.Ключ + РеквизитФлага.Ключ;
		КонецЦикла;
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Коллекция.НомерСтроки" + ПоляВыборки + "
	|ПОМЕСТИТЬ втКоллекция
	|ИЗ &КоллекцияДанных КАК Коллекция;
	|
	|ВЫБРАТЬ *
	|ИЗ втКоллекция КАК втКоллекция
	|УПОРЯДОЧИТЬ ПО НомерСтроки");
	Запрос.УстановитьПараметр("КоллекцияДанных", КоллекцияДанных.Выгрузить( , ПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(КоллекцияДанных[Выборка.НомерСтроки-1], Выборка, , "НомерСтроки");
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции()

// Процедура проверяет отмену строк в табличной части документа
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ИмяТЧ - Строка - имя проверяемой табличной части
//	ИмяРеквизитаОтменыСтрок - Строка - имя проверяемого булевого реквизита ТЧ
//
Функция ВсеСтрокиОтменены(Объект, ИмяТЧ, ИмяРеквизитаОтменыСтрок) Экспорт
	
	СтруктураОтбора = Новый Структура(ИмяРеквизитаОтменыСтрок, Ложь);
	НеОтмененныеСтроки = Объект[ИмяТЧ].НайтиСтроки(СтруктураОтбора);
	
	Возврат (НеОтмененныеСтроки.Количество() = 0);
	
КонецФункции

// Создает фиксированную структуру, сожержащую свойства одноименные колонкам таблицы формы.
//
//  Параметры:
//   - Форма - УправляемаяФорма - форма, содержащая таблицу и служебный реквизит,
//                                имя которого образовано именем таблицы с префиксом "Кеш".
//  ИмяТабличнойЧасти - Строка - имя таблицы формы, текущие данные которой необходимо скопировать в служебный реквизит формы.
//		Имя служебного реквизита должно состоять из префикса Кеш и имени табличной части.
//
Процедура ИнициализироватьКешТекущейСтроки(Форма, ИмяТабличнойЧасти, ПутьКТабличнойЧасти = "Объект") Экспорт

	Если ЗначениеЗаполнено(ПутьКТабличнойЧасти) Тогда
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ПутьКТабличнойЧасти + "." + ИмяТабличнойЧасти);
	Иначе
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ИмяТабличнойЧасти);
	КонецЕсли;
	
	РезультатСтруктура = Новый Структура;
	Для Каждого РеквизитФормы Из МассивРеквизитовФормы Цикл
		РезультатСтруктура.Вставить(РеквизитФормы.Имя, Истина);
	КонецЦикла;

	Форма[ИмяТабличнойЧасти + "КешТекущейСтроки"] = Новый ФиксированнаяСтруктура(РезультатСтруктура);

КонецПроцедуры

#КонецОбласти

#Область КонтрольНесогласованныхИзменений

// Осуществляет установку подписки на события изменения элементов формы.
//
// Параметры:
// 		Форма                    - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивЭлементов          - Массив - массив элементов формы.
// 		УстановитьПодписку - Булево - необходимость установки или снятия предупреждения.
//
Процедура УстановитьПодпискуНаСобытияИзмененияЭлементовФормы(Форма, ИменаЭлементов, Установить) Экспорт
	
	Если Не ЗначениеЗаполнено(Форма.Объект.Ссылка) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПолейТаблиц = Новый Структура;
	
	ТипУправляемаяФорма = Тип("УправляемаяФорма");
	ТипДанныеФормыКоллекция = Тип("ДанныеФормыКоллекция");
	ТипДанныеФормыДерево = Тип("ДанныеФормыДерево");
	ТипДанныеФормыСтруктура = Тип("ДанныеФормыСтруктура");
	ТипПолеФормы = Тип("ПолеФормы");
	ТипКнопкаФормы = Тип("КнопкаФормы");
	ТипТаблицаФормы = Тип("ТаблицаФормы");
	
	Элементы = Форма.Элементы;
	
	ОбработчикиСобытийТабличныхЧастей = Новый Структура();
	МассивЭлементов = Новый Массив;
	Для Каждого ИмяЭлементаПолное Из ИменаЭлементов Цикл
		
		ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
		Если ПозицияРазделителя > 0 Тогда
			Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭлементаПолное, ";");
			ИмяЭлемента = Массив[0];
		Иначе
			ИмяЭлемента = ИмяЭлементаПолное;
		КонецЕсли;
		
		Если МассивЭлементов.Найти(ИмяЭлемента) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Элемент = Элементы.Найти(ИмяЭлемента);
		Если Элемент = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивЭлементов.Добавить(ИмяЭлемента);
		
		Если ПозицияРазделителя > 0 И Массив.Количество() > 1 Тогда
			Если СтрНайти(Массив[1], ",") > 0 Тогда
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[1], ","));
			Иначе	
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, Массив[1]);
			КонецЕсли;
		КонецЕсли;
		
		ПоляИсключения = Новый Массив;
		Если ПозицияРазделителя > 0
			И Массив.Количество() > 2 Тогда
			ПоляИсключения = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[2], ",");
		КонецЕсли;
		
		ОбработатьВложенныеПоля(Элементы, Элемент, МассивЭлементов, СтруктураПолейТаблиц, ПоляИсключения);
		
	КонецЦикла;
	
	ИмяОбработчикаПустой = "Подключаемый_ПустойОбработчик_УстановитьДоступностьЭлементовПоСтатусуСервер";
	Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Неопределено Тогда
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Новый Структура;
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Команды", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПриИзменении", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Нажатие", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломИзменения", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломДобавления", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередУдалением", Новый Структура);
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ОжидаетсяОповещение", Ложь);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ЗначенияРеквизитов", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПутьКДанным", Новый Структура);
		
		Для Каждого ИмяТаблицы Из СтруктураПолейТаблиц Цикл
			
			Имена = Новый Массив;
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяТаблицы.Ключ, Новый Структура);
			
			Для Каждого ИмяЭлемента Из СтруктураПолейТаблиц[ИмяТаблицы.Ключ] Цикл
				
				Данные = Неопределено;
				ПутьКДанным = Элементы[ИмяЭлемента].ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					
					Позиция = СтрНайти(ПутьКДанным, ".");
					Пока Позиция > 0 Цикл
						Подстрока = Лев(ПутьКДанным, Позиция - 1);
						ПутьКДанным = Сред(ПутьКДанным, Позиция + 1);
						Позиция = СтрНайти(ПутьКДанным, ".");
					КонецЦикла;					
					Имена.Добавить(ПутьКДанным);
					
				КонецЕсли;
				
			КонецЦикла;
			
			Для Каждого Имя Из Имена Цикл
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов[ИмяТаблицы.Ключ].Вставить(Имя);
			КонецЦикла;
			
		КонецЦикла;
		
		ИмяОбработчикаПриИзменении            = "Подключаемый_ПриИзменении_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаНажатие                 = "Подключаемый_Нажатие_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаКоманды                 = "Подключаемый_Команда_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломИзменения   = "Подключаемый_ПередНачаломИзменения_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломДобавления  = "Подключаемый_ПередНачаломДобавления_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередУдалением          = "Подключаемый_ПередУдалением_УстановитьДоступностьЭлементовПоСтатусуСервер";
		
		Для Каждого ИмяЭлементаПолное Из МассивЭлементов Цикл
			
			ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
			Если ПозицияРазделителя > 0 Тогда
				ИмяЭлемента = Лев(ИмяЭлементаПолное, ПозицияРазделителя - 1);
			Иначе
				ИмяЭлемента = ИмяЭлементаПолное;
			КонецЕсли;
			
			Элемент = Элементы[ИмяЭлемента];
			Если Элемент = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗнчЭлемент = ТипЗнч(Элемент);
			
			Если ТипЗнчЭлемент = ТипПолеФормы Тогда
				
				Действие = Элемент.ПолучитьДействие("ПриИзменении");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПриИзменении.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Данные = Неопределено;
				ПутьКДанным = Элемент.ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьКДанным, ".");
					Данные = Форма;
					Для Каждого СтрокаМассива Из Массив Цикл
						ТипЗнчДанные = ТипЗнч(Данные);
						Если ТипЗнчДанные = ТипУправляемаяФорма
							ИЛИ ТипЗнчДанные = ТипДанныеФормыСтруктура Тогда
							Данные = Данные[СтрокаМассива];
						Иначе
							Данные = Неопределено;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если Данные <> Неопределено Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяЭлемента, Данные);
				КонецЕсли;
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПутьКДанным.Вставить(ИмяЭлемента, ПутьКДанным);
				Элемент.УстановитьДействие("ПриИзменении", ИмяОбработчикаПриИзменении);
				
			ИначеЕсли ТипЗнчЭлемент = ТипТаблицаФормы Тогда
				
				Действия = Неопределено;
				ОбработчикиСобытийТабличныхЧастей.Свойство(ИмяЭлемента, Действия);
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломДобавления") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломДобавления");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломДобавления.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломДобавления", ИмяОбработчикаПередНачаломДобавления);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередУдалением") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередУдалением");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередУдалением.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередУдалением", ИмяОбработчикаПередУдалением);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломИзменения") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломИзменения");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломИзменения.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломИзменения", ИмяОбработчикаПередНачаломИзменения);
				КонецЕсли;
				
			ИначеЕсли ТипЗнчЭлемент = ТипКнопкаФормы Тогда
				
				ИмяКоманды = Элемент.ИмяКоманды;
				
				Если Не ЗначениеЗаполнено(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Свойство(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Действие = Форма.Команды[ИмяКоманды].Действие;
				Если ЗначениеЗаполнено(Действие) Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Вставить(ИмяКоманды, Действие);
				КонецЕсли;
				
				Форма.Команды[ИмяКоманды].Действие = ИмяОбработчикаКоманды;
				
			ИначеЕсли ТипЗнчЭлемент = Тип("ДекорацияФормы") Тогда
				
				Действие = Элемент.ПолучитьДействие("Нажатие");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Нажатие.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Элемент.УстановитьДействие("Нажатие", ИмяОбработчикаНажатие);
				
			Иначе
				ВызватьИсключение НСтр("ru = 'Внутренняя ошибка'");
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений <> Неопределено Тогда
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ОжидаетсяОповещение = Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область УсловноеОформление

// Устанавливаем условное оформление для поля формы "Приоритет"
//    в зависимости от его значения
//
// Параметры:
// 		Форма - Форма - Содержит данную форму 
//
Процедура УстановитьУсловноеОформлениеПриоритета(Форма) Экспорт
	
	Если Форма.ИмяФормы = "Обработка.СамообслуживаниеПартнеров.Форма.МастерОформленияЗаказа" Тогда
		ПутьКРеквизитуПриоритет = "Приоритет";
	Иначе
		ПутьКРеквизитуПриоритет = "Объект.Приоритет";
	КонецЕсли;
	
	УсловноеОформление = Форма.УсловноеОформление;
	ЭлементыФормы = Форма.Элементы;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы["Приоритет"].Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьВысшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.ВысокийПриоритетДокумента);

	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы["Приоритет"].Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьНизшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.НизкийПриоритетДокумента);
	
	//
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Приоритеты.Ссылка КАК Приоритет,
	|	Приоритеты.Цвет   КАК Цвет
	|ИЗ
	|	Справочник.Приоритеты КАК Приоритеты");
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			Элемент = УсловноеОформление.Элементы.Добавить();

			ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
			ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

			ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
			ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			ОтборЭлемента.ПравоеЗначение = Выборка.Приоритет;

			Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", Выборка.Цвет.Получить());
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура заполняет всеми подчиннными полями (с учетом вложенности в группы) оформляемые поля условного оформления
// Пример вызова: ЗаполнитьРекурсивноПоляУсловногоОформления(ЭлементУО.Поля, Элементы.Товары.ПодчиненныеЭлементы)
//
// Параметры:
//	ОформляемыеПоляКомпоновкиДанных	- ОформляемыеПоляКомпоновкиДанных
//	КоллекцияЭлементов - ЭлементыФормы
//	ИсключаяПоля - Массив, Строка, Неопределено - значение по умолчанию Неопределено, массив имен элементов, которые не нужно добавлять в оформляемые поля
//
Процедура ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, КоллекцияЭлементов, Знач ИсключаяПоля = Неопределено) Экспорт
	
	Если ТипЗнч(ИсключаяПоля) = Тип("Строка") Тогда
		ИсключаяПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяПоля);
	КонецЕсли;
	
	Для Каждого Поле Из КоллекцияЭлементов Цикл
		Если ТипЗнч(Поле) = Тип("ПолеФормы") Тогда
			Если ИсключаяПоля = Неопределено
				Или ИсключаяПоля.Найти(Поле.Имя) = Неопределено Тогда
					ПолеЭлемента = ОформляемыеПоляКомпоновкиДанных.Элементы.Добавить();
					ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Поле.Имя);
			КонецЕсли;
		ИначеЕсли ТипЗнч(Поле) = Тип("ГруппаФормы")Тогда	
			ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, Поле.ПодчиненныеЭлементы);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Добавляет на форму условное оформление элемента (отметку незаполненного), исходя из значения служебного реквизита
// по следующему правилу: если реквизит не заполнен а служебный реквизит заполнен то пометка устанавливается, иначе снимается.
//
//  Параметры:
//   УсловноеОформление - УсловноеОформление - условное офрмление формы.
//   ИмяЭлемента - Строка - имя элемента для условного оформления.
//   ИмяРеквизита - Произвольный - Реквизит формы, связанный с элементом формы.
//   ИмяТЧ - Строка - имя табличной части, если требуется оформлять поле таблицы формы.
//   ИмяПризнака - Строка - имя служебного реквизита.
//
Процедура УстановитьСнятьОтметкуНезаполненного(УсловноеОформление, ИмяЭлемента, ИмяРеквизита, ИмяТЧ, ИмяПризнака) Экспорт
	
	Подстановка = ?(ИмяТЧ = "", "", "Объект." + ИмяТЧ + ".");
	ПутьКПризнаку = "Объект.Товары.ИмяПризнака";
	ПутьКПризнаку = СтрЗаменить(ПутьКПризнаку, "Объект.Товары.", Подстановка);
	ПутьКПризнаку = СтрЗаменить(ПутьКПризнаку, "ИмяПризнака", ИмяПризнака);
	
	Подстановка = ?(ИмяТЧ = "", "", ИмяТЧ + ".");
	ПутьКРеквизиту = "Объект.Товары.ИмяРеквизита";
	ПутьКРеквизиту = СтрЗаменить(ПутьКРеквизиту, "Товары.", Подстановка);
	ПутьКРеквизиту = СтрЗаменить(ПутьКРеквизиту, "ИмяРеквизита", ИмяРеквизита);
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ПравоеЗначение = Истина;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ПравоеЗначение = Ложь;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ПереключениеИнтерфейса

// Установка набора видимых подсистем командного интерфейса
//  и настроек всем пользователям вида интерфейса (Такси / в закладках).
//
// Параметры:
//  Режим	 - Строка	 - ИнтерфейсТакси / ИнтерфейсВерсии82 - соответствует константе, которая будет установлена в Истину
//
Процедура УстановитьРежимКомандногоИнтерфейса(Режим) Экспорт
	
	Если НЕ ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	// Установка констант
	
	РежимТакси = ВРег(Режим) = ВРег("ИнтерфейсТакси");
	Режим82    = ВРег(Режим) = ВРег("ИнтерфейсВерсии82");
	
	Если НЕ РежимТакси
		И НЕ Режим82 Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Константы.ИнтерфейсВерсии82.Установить(Режим82);
	
	// Установка настроек по умолчанию всем пользователям
	
	ВсеПользователи = ПользователиИнформационнойБазы.ПолучитьПользователей();
	Если ВсеПользователи.Количество() > 0 Тогда
		Для каждого ПользовательИБ Из ВсеПользователи Цикл
			ПользователиСлужебный.УстановитьНачальныеНастройки(ПользовательИБ.Имя);
		КонецЦикла;
	Иначе
		ПользователиСлужебный.УстановитьНачальныеНастройки("");
	КонецЕсли;

КонецПроцедуры

// Процедура - Переключение интерфейса при создании на сервере
//
// Параметры:
//  Форма	 - УправляемаяФорма	 - Форма панели администрирования
//
Процедура ПереключениеИнтерфейсаПриСозданииНаСервере(Форма) Экспорт 

	// Значения реквизитов формы
	Если Константы.ИнтерфейсВерсии82.Получить() Тогда
		Форма.ВариантИнтерфейса = "ИнтерфейсВерсии82";
	Иначе
		Форма.ВариантИнтерфейса = "ИнтерфейсТакси";
	КонецЕсли;
	Форма.ВариантИнтерфейсаДоИзменения = Форма.ВариантИнтерфейса;
	
	ТекущийРежим = Метаданные.РежимСовместимостиИнтерфейса;
	Такси = (ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.Такси
		ИЛИ ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.ТаксиРазрешитьВерсия8_2);
	
	Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Очистить();
	ПредставлениеИнтерфейса82 = НСтр("ru = 'Как в предыдущих версиях УправлениеТорговлей'");
	Если Такси ИЛИ ПолучитьФункциональнуюОпцию("БазоваяВерсия") Тогда
	
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси"" (рекомендуется)'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82);
		
	Иначе
		
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси""'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82 + " " + НСтр("ru = '(рекомендуется)'"));
		
	КонецЕсли; 

КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Возвращает соответствие массивов документов по типам
//
// Параметры:
// 		МассивСсылок - Массив - Массив ссылок
//
// Возвращаемое значение:
// 		Соответствие - Ключ: Тип; значение: Массив ссылок на документы
//
Функция РазложитьМассивСсылокПоТипам(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Счетчик = 0 По МассивСсылок.Количество() -1 Цикл
		
		ТипСсылки = ТипЗнч(МассивСсылок[Счетчик]);
		Массив = СоответствиеТипов[ТипСсылки];
		Если Массив = Неопределено Тогда
			Массив = Новый Массив;
			СоответствиеТипов.Вставить(ТипСсылки, Массив);
		КонецЕсли;
		Массив.Добавить(МассивСсылок[Счетчик]);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции // РазложитьМассивСсылокПоТипам

#КонецОбласти

#Область МетодыРаботыСРеквизитамиОбъектов

// Позволяет определить есть ли среди реквизитов табличной части объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - строковое имя искомого реквизита.
//  МетаданныеОбъекта - описание метаданных объекта, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части объекта, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиОбъекта(ИмяРеквизита, МетаданныеОбъекта, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // нет такой таб. части
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
КонецФункции

#КонецОбласти

#Область ЗаменаСсылокПоИнформационнойБазе

// Заменяет ссылки по информационной базе.
//
// Параметры:
//	ПарыЗамены - Соответствие - ключи содержат замещаемых, значения содержат заменители
//	Исключения - Массив - необязателен, значения типа ОбъектМетаданных, в экземплярах которых замены проводить нельзя
//
Процедура ЗаменитьСсылки(ПарыЗамен, Исключения = Неопределено) Экспорт
	Английский = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский;
	ДвиженияССубконтоИмя = ?(Метаданные.ВариантВстроенногоЯзыка = Английский, ".RecordsWithExtDimensions", ".ДвиженияССубконто");
	
	Если Исключения = Неопределено Тогда
		Исключения = Новый Массив;
	КонецЕсли;
	
	// [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
	ИндексЗамены = ИндексЗамены(ПарыЗамен);
	КешПолей = Новый Соответствие;
	// обходим индекс и в каждом ключе-объекта полностью замещаем все ссылки, подлежащие замене
	Для Каждого УзелЗамены Из ИндексЗамены Цикл
		Ссылка = УзелЗамены.Ключ;
		МетаданныеУзла = УзелЗамены.Значение.Метаданные;
		Замены = УзелЗамены.Значение.Замены;
		ТипыЗамещаемых = УзелЗамены.Значение.ТипыЗамещаемых;
		
		Если Исключения.Найти(МетаданныеУзла) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоСсылочныйОбъектМетаданных(МетаданныеУзла) Тогда
			// любой ссылочный объект
			ОбъектДанных = Ссылка.ПолучитьОбъект();
			Если ОбъектДанных <> Неопределено Тогда
				ПолноеИмя = МетаданныеУзла.ПолноеИмя();
				ИменаПолей = ИменаПолейСТипами(КешПолей, ПолноеИмя, ТипыЗамещаемых, "Ссылка, Ref");
				ЗаменитьЗначения(ОбъектДанных, ИменаПолей, Замены);
				// табчасти объекта
				ЗаменитьВТабчастях(
					КешПолей, МетаданныеУзла.ТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				// стандартные табчасти планов
				Если Метаданные.ПланыСчетов.Содержит(МетаданныеУзла) Или Метаданные.ПланыВидовРасчета.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВТабчастях(
						КешПолей, МетаданныеУзла.СтандартныеТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				КонецЕсли;
				// пишем сам объект
				ЗаписатьДанные(ОбъектДанных);
				ОбъектДанных = Неопределено;
			КонецЕсли;
		ИначеЕсли Метаданные.Константы.Содержит(МетаданныеУзла) Тогда
			// значения в константах
			Константа = Константы[МетаданныеУзла.Имя];
			Константа.Установить(НовоеЗначение(Константа.Получить(), Замены));
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеУзла) Тогда
			// необъектные таблицы
			ИменаПолей = ИменаПолейСТипами(КешПолей, МетаданныеУзла.ПолноеИмя(), ТипыЗамещаемых);
			Отборы = ОтборыРегистраСведений(МетаданныеУзла, Ссылка);
			Набор = НаборЗаписей(РегистрыСведений[МетаданныеУзла.Имя], Отборы);
			
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);

			ЗаменитьЗначения(Таблица[0], ИменаПолей, Замены);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Не Отборы.Свойство(ИмяПоля) Тогда
					Продолжить;
				КонецЕсли;
				Набор.Отбор[ИмяПоля].Установить(НовоеЗначение(Отборы[ИмяПоля], Замены));
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
		КонецЕсли;
		// обработка движений документа
		Если Метаданные.Документы.Содержит(МетаданныеУзла) Тогда
			Для Каждого Движение Из МетаданныеУзла.Движения Цикл
				ДопТаблица = "";
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
					Регистр = РегистрыНакопления[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
					Регистр = РегистрыСведений[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
					ДопТаблица = ДвиженияССубконтоИмя;
					Регистр = РегистрыБухгалтерии[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
					Регистр = РегистрыРасчета[Движение.Имя];
				КонецЕсли;
				ЗаменитьВПодчиненномРегистре(КешПолей, Регистр, Ссылка, Движение.ПолноеИмя() + ДопТаблица, Замены, ТипыЗамещаемых);
			КонецЦикла;
			// обработка последовательностей, включающих документ
			Для Каждого Движение Из Метаданные.Последовательности Цикл
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Движение.Документы.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВПодчиненномРегистре(
						КешПолей, Последовательности[Движение.Имя], Ссылка, Движение.ПолноеИмя(), Замены, ТипыЗамещаемых);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Строим соответствие вида [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
// в итоге представляем результаты поиска по ссылкам в индексе с ключом-объектом, содержащим замещаемые ссылки
Функция ИндексЗамены(ПарыЗамен)
	
	СписокСсылок = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		СписокСсылок.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(СписокСсылок);
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта)
	
	ИндексЗамены = Новый Соответствие;
	Для Каждого Результат Из РезультатыПоиска Цикл
		УзелЗамены = ИндексЗамены[Результат.Данные];
		Если Неопределено = УзелЗамены Тогда
			УзелЗамены =
				Новый Структура("Метаданные, Замены, ТипыЗамещаемых", Результат.Метаданные, Новый Массив, Новый Массив);
			ИндексЗамены.Вставить(Результат.Данные, УзелЗамены);
		КонецЕсли;

		УзелЗамены.Замены.Добавить(
			Новый Структура("Замещаемое, Заменитель", Результат.Ссылка, ПарыЗамен[Результат.Ссылка]));

		ТипЗамещаемого = ТипЗнч(Результат.Ссылка);
		Если Неопределено = УзелЗамены.ТипыЗамещаемых.Найти(ТипЗамещаемого) Тогда
			УзелЗамены.ТипыЗамещаемых.Добавить(ТипЗамещаемого);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИндексЗамены;
КонецФункции

Процедура ЗаменитьВТабчастях(КешПолей, ОписанияТабчастей, Объект, ИмяОсновнойТаблицы, Замены, ТипыЗамещаемых, Исключения)
	Для Каждого Описание Из ОписанияТабчастей Цикл
		Если Исключения.Найти(Описание) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяОсновнойТаблицы + "." + Описание.Имя, ТипыЗамещаемых, "Ссылка, Ref");
		Для Каждого Табстрока Из Объект[Описание.Имя] Цикл
			ЗаменитьЗначения(Табстрока, ИменаПолей, Замены);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаменитьВПодчиненномРегистре(КешПолей, МенеджерРегистра, Ссылка, ИмяТаблицыРегистра, Замены, ТипыЗамещаемых)
	ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяТаблицыРегистра, ТипыЗамещаемых, "Регистратор, Recorder");
	Набор = НаборЗаписей(МенеджерРегистра, Новый Структура("Регистратор", Ссылка));
	ЗначениеЗаменено = Ложь;
	Для Каждого Запись Из Набор Цикл
		ЗаменитьЗначения(Запись, ИменаПолей, Замены, ЗначениеЗаменено);
	КонецЦикла;
	ЗаписатьДанные(Набор, ЗначениеЗаменено);
КонецПроцедуры

Функция ИменаПолейСТипами(КешПолейТаблиц, ИмяТаблицы, ТипыДанных, ИменаИсключений = "")
	ИменаПолей = Новый Массив;
	
	ТекстЗапроса = СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ Ложь", "ТаблицаВыборки", ИмяТаблицы);
	ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
	Если Неопределено = ПоляТаблицы Тогда
		Запрос = Новый Запрос(ТекстЗапроса);
		ПоляТаблицы = Запрос.Выполнить().Колонки;
		КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
	КонецЕсли;
	
	Исключения = Новый Структура(ИменаИсключений);
	Для Каждого Поле Из ПоляТаблицы Цикл
		Если Исключения.Свойство(Поле.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТипДанных Из ТипыДанных Цикл
			Если Поле.ТипЗначения.СодержитТип(ТипДанных) И Неопределено = ИменаПолей.Найти(Поле.Имя) Тогда
				ИменаПолей.Добавить(Поле.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
    Возврат ИменаПолей;
КонецФункции

Процедура ЗаменитьЗначения(Данные, ИменаПолей, Замены, Заменено = Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		НовоеЗначение = НовоеЗначение(Данные[ИмяПоля], Замены);
		Если НовоеЗначение <> Данные[ИмяПоля] Тогда;
			Заменено = Истина;
			Данные[ИмяПоля] = НовоеЗначение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция НовоеЗначение(СтароеЗначение, Замены)
	Для Каждого Замена Из Замены Цикл
		Если СтароеЗначение = Замена.Замещаемое Тогда
			Возврат Замена.Заменитель;
		КонецЕсли;
	КонецЦикла;
	Возврат СтароеЗначение;
КонецФункции

Процедура ЗаписатьДанные(Данные, Принудительно = Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

Функция НаборЗаписей(МенеджерРегистра, Отборы)
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		Набор.Отбор[Отбор.Ключ].Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

#КонецОбласти

#Область МетодыДляОтладкиИТестирования

// Показать произвольную выборку данных в отладчике
// Пример:
//	ОбщегоНазначенияУТ.ЗапросВыполнитьВыгрузить("выбрать * из Справочник.Валюты где Валюты.Код = &Код", Новый Структура("Код", "810"))
//
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено, МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Показать временную таблицу из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
// Пример вызова функции:
//	ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(Запрос, "ТаблицаТоваров")
//
Функция ПоказатьВременнуюТаблицу(МенеджерВременныхТаблицИлиЗапрос, ИмяВременнойТаблицы) Экспорт
	
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	
	Если ТипЗнч(МенеджерВременныхТаблицИлиЗапрос) = Тип("Запрос") Тогда
		Если МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено Тогда
			МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗакрытьМенеджерВременныхТаблиц = Истина;
			МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц; 
		Иначе
			МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц;
		КонецЕсли;
		МенеджерВременныхТаблицИлиЗапрос.Выполнить();
	Иначе
		МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос;
	КонецЕсли; 
	
	ДанныеТаблицы = ЗапросВыполнитьВыгрузить("ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы,, МенеджерВременныхТаблиц);
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		МенеджерВременныхТаблиц.Закрыть();
		МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено;
	КонецЕсли; 
	
	Возврат ДанныеТаблицы;
	
КонецФункции

// Преобразует таблицу значений в табличный документ и сохраняет его в файл.
// Примеры вызова функции:
// 	ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(Таблица, "c:\temp\таблица.mxl")
// 	ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(МВТ, "Таблица"), "c:\temp\таблица.mxl")
//
// Параметры:
//	Таблица - ТаблицаЗначений - произвольная таблица значений
//	ПолноеИмяФайла - Строка - полное имя сохраняемого файла, с расширением
//
// Возвращаемое значение:
//	Строка - текст сообщения об ошибке или пустая строка, если запись выполнена успешно.
//
Функция СохранитьТаблицуЗначенийВФайл(Таблица, ПолноеИмяФайла) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	НомерСтроки  = 1;
	НомерКолонки = 0;
	
	// Сформируем шапку табличного документа - выведем имена колонок таблицы значений
	Для Каждого ТекКолонка Из Таблица.Колонки Цикл
		
		НомерКолонки = НомерКолонки + 1;
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		Область.Текст 		 = ?(ЗначениеЗаполнено(ТекКолонка.Заголовок), ТекКолонка.Заголовок, ТекКолонка.Имя);
		Область.Шрифт 		 = Новый Шрифт(Область.Шрифт,,, Истина); 
		Область.ГраницаСнизу = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		
	КонецЦикла;
	
	// Выведем строки таблицы значений
	Для Каждого ТекСтр Из Таблица Цикл
		
		НомерСтроки = НомерСтроки + 1;
		НомерКолонки = 0;
		
		Для Каждого ТекКолонка Из Таблица.Колонки Цикл
			
			НомерКолонки = НомерКолонки + 1;
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			Область.Текст = ТекСтр[ТекКолонка.Имя];
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВыгрузкаТаблицы.ФиксацияСверху = 1;
	ВыгрузкаТаблицы.ФиксацияСлева  = 1;
	
	// Сохраним табличный документ в файл
	ТекстОшибки = "";
	Попытка
		ВыгрузкаТаблицы.Записать(ПолноеИмяФайла);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Считывает таблицу значений из табличного документа.
// Помещение таблицы значений в текстовый документ можно выполнить функцией СохранитьТаблицуЗначенийВФайл().
// В первой строке таблицы должны быть указаны имена колонок таблицы значений,
// в остальных строках - значения в соответствующих ячейках таблицы значений.
// Пример вызова функции:
// 	ОбщегоНазначенияУТ.ПолучитьТаблицуЗначенийИзФайла("c:\temp\таблица.mxl")
//
// Параметры:
//	ПолноеИмяФайла - Строка - полное имя считываемого файла, с расширением
//
// Возвращаемое значение:
//	Строка 			- если при чтении файла произошла ошибка, то возвращается текст сообщения об ошибке;
//	ТаблицаЗначений - если ошибок не было, то возвращается считанная таблица значений
//
Функция ПолучитьТаблицуЗначенийИзФайла(ПолноеИмяФайла) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	// Прочитаем файл.
	Попытка
		ВыгрузкаТаблицы.Прочитать(ПолноеИмяФайла);
	Исключение
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Невозможно прочитать таблицу значений из файла ""%1"":
				|%2'"),
			ПолноеИмяФайла,
			ИнформацияОбОшибке());
		
		Возврат ТекстОшибки;
		
	КонецПопытки;
	
	Таблица = Новый ТаблицаЗначений;
	
	Если ВыгрузкаТаблицы.ВысотаТаблицы = 0 ИЛИ ВыгрузкаТаблицы.ШиринаТаблицы = 0 Тогда
		Возврат Таблица;
	КонецЕсли;
	
	// Создадим колонки таблицы значений.
	НомерСтроки = 1;
	
	// В первой строке таблицы должны быть перечислены имена колонок.
	// Если в ячейке первой строки указан текст, не подходящий для имени колонки таблицы значений, то вернем сообщение об ошибке.
	Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		ТекстЯчейки = СокрЛП(Область.Текст);
		
		Попытка
			Таблица.Колонки.Добавить(ТекстЯчейки, Новый ОписаниеТипов("Строка"));
		Исключение
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Невозможно прочитать таблицу значений из файла ""%1"":
					|недопустимое имя колонки таблицы значений: ""%2""'"),
				ПолноеИмяФайла,
				ТекстЯчейки);
			
			Возврат ТекстОшибки;
			
		КонецПопытки;
		
	КонецЦикла;
	
	Для НомерСтроки = 2 По ВыгрузкаТаблицы.ВысотаТаблицы Цикл
		
		НоваяСтрока = Таблица.Добавить();
		
		Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			ТекстЯчейки = СокрЛП(Область.Текст);
			
			НоваяСтрока[Таблица.Колонки[НомерКолонки - 1].Имя] = ТекстЯчейки;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

// Сравнивает построчно указанные таблицы.
//
// Параметры:
//	Таблица1 			   - ТаблицаЗначений - таблица №1
//	Таблица2 			   - ТаблицаЗначений - таблица №2
//	КолонкиДолжныСовпадать - Булево - если Истина, то колонки должны быть идентичны
//
// Возвращаемое значение:
//	Строка 			- если КолонкиДолжныСовпадать = Истина и колонки таблиц отличаются; возвращается описание отличий в колонках
//	ТаблицаЗначений - во всех остальных случаях; содержит только отличающиеся строки таблиц №1 и №2
//		состав колонок таблицы - общие колонки таблиц №1 и №2
//		служебная колонка "СчетчикСтрокСравниваемыхТаблиц" содержит число отличное от 0:
//			если счетчик > 0, то строка встречается в таблице №1 на указанное количество раз больше
//			если счетчик < 0, то строка встречается в таблице №2 на указанное количество раз больше
//
Функция СравнитьТаблицыЗначений(Таблица1, Таблица2, КолонкиДолжныСовпадать = Истина) Экспорт
	
	ОписаниеОтличийВКолонках = Новый Массив;
	ОбщиеКолонки = Новый Массив;
	
	// Проверим колонки Таблица1 в Таблица2
	Для Каждого ТекущаяКолонка Из Таблица1.Колонки Цикл
		
		Если Таблица2.Колонки.Найти(ТекущаяКолонка.Имя) = Неопределено Тогда
			
			// Колонка только в Таблица1
			ОписаниеОтличийВКолонках.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Колонка присутствует только в таблице №1: ""%1""'"),
					ТекущаяКолонка.Имя));
			
		Иначе
			
			// Общая колонка
			ОбщиеКолонки.Добавить(ТекущаяКолонка.Имя);
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверим колонки Таблица2 в Таблица1
	Для Каждого ТекущаяКолонка Из Таблица2.Колонки Цикл
		
		Если Таблица1.Колонки.Найти(ТекущаяКолонка.Имя) = Неопределено Тогда
			
			// Колонка только в Таблица2
			ОписаниеОтличийВКолонках.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Колонка присутствует только в таблице №2: ""%1""'"),
					ТекущаяКолонка.Имя));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если КолонкиДолжныСовпадать И ОписаниеОтличийВКолонках.Количество() > 0 Тогда
		Возврат СтрСоединить(ОписаниеОтличийВКолонках, Символы.ПС);
	КонецЕсли;
	
	СтрокаОбщиеКолонки = СтрСоединить(ОбщиеКолонки, ", ");
	
	// Объединим таблицы 1 и 2.
	// При этом в служебную колонку "СчетчикСтрокСравниваемыхТаблиц" запишем число 1 для 1й и -1 для 2й таблицы.
	ТаблицаОтличий = Таблица1.Скопировать(, СтрокаОбщиеКолонки);
	
	ТаблицаОтличий.Колонки.Добавить("СчетчикСтрокСравниваемыхТаблиц", Новый ОписаниеТипов("Число"));
	ТаблицаОтличий.ЗаполнитьЗначения(1, "СчетчикСтрокСравниваемыхТаблиц");
	
	Для Каждого СтрокаТаблицы Из Таблица2 Цикл
		
		НоваяСтрока = ТаблицаОтличий.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
		
		НоваяСтрока.СчетчикСтрокСравниваемыхТаблиц = -1;
		
	КонецЦикла;
	
	// Свернем строки объединенной таблицы.
	// Строки, в которых СчетчикСтрокСравниваемыхТаблиц <> 0, являются различиями таблиц 1 и 2.
	// Вернем только отличающиеся строки.
	
	ТаблицаОтличий.Свернуть(СтрокаОбщиеКолонки, "СчетчикСтрокСравниваемыхТаблиц");
	
	НайтиИУдалитьСтрокиТаблицыЗначений(
		ТаблицаОтличий,
		Новый Структура("СчетчикСтрокСравниваемыхТаблиц", 0));
	
	Возврат ТаблицаОтличий;
	
КонецФункции

#КонецОбласти

#Область СистемныеОпределяютПоведениеКонфигурации

// Проверяет соблюдение условий открытия базовой версии конфигурации в режиме Предприятие.
//
// Возвращаемое значение:
// 	- если текущая версия конфигурации не является базовой, то возвращается значение Истина.
//  - если текущая версия конфигурации является базовой, то возвращается значение Истина
//	  в случае, если ИБ развернута в файловом варианте и запускается в однопользовательском режиме.
//
Функция ВозможенЗапускБазовойВерсии() Экспорт
	
	Если НЕ СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации() Тогда
		Возврат Истина; // ОК: это не базовая версия
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы()) Тогда
		Возврат Ложь; // не файловая ИБ
	КонецЕсли;
	
	СеансыИнформационнойБазы = ПолучитьСеансыИнформационнойБазы();
	НомерТекущегоСеанса		 = НомерСеансаИнформационнойБазы();
	ЗапрещенныеПриложения	 = ",1CV8,1CV8C,WebClient,WSConnection,COMConnection,";
	
	Для Каждого СеансИБ Из СеансыИнформационнойБазы Цикл
		
		Если СеансИБ.НомерСеанса = НомерТекущегоСеанса Тогда
			Продолжить;
		ИначеЕсли СтрНайти(ЗапрещенныеПриложения, "," + СеансИБ.ИмяПриложения + ",") > 0 Тогда
			Возврат Ложь; // открыты другие сеансы 1С:Предприятия
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина; // ОК: это файловая ИБ в однопользовательском режиме
	
КонецФункции

#КонецОбласти

#Область Версионирование

// Возвращает признак использования версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//
// Возвращаемое значение:
//  Булево
//
Функция ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Экспорт
	
 	Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ПолноеИмяОбъекта);	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьВерсионированиеОбъекта",
		Новый Структура("ТипВерсионируемогоОбъекта", Идентификатор));
		
КонецФункции	

// Включает версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//	ВариантВерсионирования - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если для указанного объекта было включено версионирование
//
Функция ВключитьВерсионированиеОбъекта(ПолноеИмяОбъекта, ВариантВерсионирования = "ВерсионироватьПриЗаписи")
	
	ВерсионированиеВключено = Ложь;
	
	ПеречислениеВариантВерсионирования = Перечисления.ВариантыВерсионированияОбъектов[ВариантВерсионирования];
	
	Если НЕ ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Тогда
		
		ВерсионированиеОбъектов.ЗаписатьНастройкуВерсионированияПоОбъекту(ПолноеИмяОбъекта, ПеречислениеВариантВерсионирования);
		ВерсионированиеВключено = Истина;
		
	КонецЕсли;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

// Включает версионирования для указанных объектов метаданных.
//
// Параметры:
//	Объекты - Соответствие
//  	Ключ 	 - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//		Значение - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если хотя бы для одного из указанных объектов было включено версионирование
//
Функция ВключитьВерсионированиеОбъектов(Объекты) Экспорт
	
	ВерсионированиеВключено = Ложь;
	
	Для Каждого КлючИЗначение Из Объекты Цикл
		ВерсионированиеВключено =
			ВключитьВерсионированиеОбъекта(КлючИЗначение.Ключ, КлючИЗначение.Значение)
			ИЛИ ВерсионированиеВключено;
	КонецЦикла;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

#КонецОбласти

#Область Константы

// Возвращает состав набор констант.
//
// Параметры:
//	Набор - КонстантыНабор
//
// Возвращаемое значение:
//  Структура
//		Ключ - имя константы из набора
//
Функция ПолучитьСтруктуруНабораКонстант(Набор) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого МетаКонстанта Из Метаданные.Константы Цикл
		Если ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Набор, МетаКонстанта.Имя) Тогда
			Результат.Вставить(МетаКонстанта.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Перечисления

// Получает список выбора для указанного перечисления.
//
// Параметры:
//	ИмяПеречисления 	- Строка - имя перечисления как оно задано в конфигураторе.
//	ДанныеВыбора 		- Список значений - сформированный список выбора перечисления.
//	Параметры 			- Структура - подробнее см. ОбработкаПолученияДанныхВыбора
//	ИсключаемыеЗначения - Массив - значения перечисления, не включаемые в список выбора.
//
Процедура ДоступныеДляВыбораЗначенияПеречисления(ИмяПеречисления, ДанныеВыбора, Параметры, ИсключаемыеЗначения) Экспорт
	
	ДанныеВыбора = Новый СписокЗначений; // результат
	
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ЗначенияПеречисления.Ссылка КАК Ссылка,
	|	ПРЕДСТАВЛЕНИЕ(ЗначенияПеречисления.Ссылка) КАК Представление
	|ИЗ
	|	Перечисление.%ИмяПеречисления% КАК ЗначенияПеречисления
	|ГДЕ
	|	НЕ ЗначенияПеречисления.Ссылка В (&ИсключаемыеЗначения)
	|	//%ТекстОтборПоПараметрам%
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗначенияПеречисления.Порядок";
	
	Запрос.УстановитьПараметр("ИсключаемыеЗначения", ИсключаемыеЗначения);
	
	Если Параметры.Отбор.Свойство("Ссылка") Тогда
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "//%ТекстОтборПоПараметрам%", "И ЗначенияПеречисления.Ссылка В (&ОтборПоСсылке)");
		
		Запрос.УстановитьПараметр("ОтборПоСсылке", Параметры.Отбор.Ссылка);
		
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "%ИмяПеречисления%", ИмяПеречисления);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если НЕ ЗначениеЗаполнено(Параметры.СтрокаПоиска)
		 ИЛИ СтрНайти(НРег(Выборка.Представление), НРег(Параметры.СтрокаПоиска)) = 1 Тогда
			ДанныеВыбора.Добавить(Выборка.Ссылка);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область КонтактнаяИнформация

// Актуализирует значения полей КИ из ее представления.
//
//  Параметры:
//		АдресПредставление - представление КИ
//		АдресЗначенияПолей - служебная информация, значения полей КИ
//		ТипКИ			   - тип контактной информации (Перечисления.ТипыКонтактнойИнформации)
//
Процедура ЗаполнитьЗначенияПолейКИПоПредставлению(Представление, ЗначенияПолей, ТипКИ = Неопределено) Экспорт
	
	Если ТипКИ = Неопределено Тогда
		ТипКИ = Перечисления.ТипыКонтактнойИнформации.Адрес;
	КонецЕсли;
	
	Если УправлениеКонтактнойИнформацией.ПредставлениеКонтактнойИнформации(ЗначенияПолей) = Представление Тогда
		Возврат;
	КонецЕсли;
	
	// Сохраним комментарий из старых значений полей.
	Комментарий = СокрЛП(УправлениеКонтактнойИнформацией.КомментарийКонтактнойИнформации(ЗначенияПолей));
	
	// Сформируем значения полей КИ по представлению.
	ЗначенияПолей = УправлениеКонтактнойИнформациейСлужебныйВызовСервера.КонтактнаяИнформацияXMLПоПредставлению(Представление,	ТипКИ);
	
	Если ЗначениеЗаполнено(Комментарий) Тогда
		// Вернем комментарий обратно.
		УправлениеКонтактнойИнформацией.УстановитьКомментарийКонтактнойИнформации(ЗначенияПолей, Комментарий);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ДополнительныеРеквизитыИСведения

// Служебная. Возвращает наборы доп. реквизитов и сведений, доступных при данных настройках конфигурации.
//
// Возвращаемое значение:
//	Массив, элементы - СправочникСсылка.НаборыДополнительныхРеквизитовИСведений
//
Функция ДоступныеДопРеквизитыИСведения() Экспорт
	
	ДоступныеСвойства = Новый Массив;
	
	СвязиСвойствИФО = ОбщегоНазначенияУТПовтИсп.СвязиДопРеквизитовИФункциональныхОпций();
	
	Для Каждого КлючИЗначение Из СвязиСвойствИФО Цикл
		
		Если НЕ ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
			
			// Этот набор доп. свойств не зависит от ФО
			ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
			
		Иначе
			
			РодительскиеФО = Новый Структура(КлючИЗначение.Значение);
			
			Для Каждого ТекущаяФО Из РодительскиеФО Цикл
				Если ПолучитьФункциональнуюОпцию(ТекущаяФО.Ключ) Тогда
					// Включена хотя бы одна ФО, от которой зависит этот набор доп. свойств
					ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДоступныеСвойства;
	
КонецФункции

#КонецОбласти

#Область Подсистемы

// Добавляет подсистему в коллекцию.
//
// Параметры:
//	Коллекция - Массив или СписокЗначений - коллекция, куда добавляется подсистема из метаданных
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно
//	Представление - Строка - представление подсистемы (для списка значений)
//
Процедура ДобавитьПодсистемуВКоллекцию(Коллекция, ИмяПодсистемы, Представление = "") Экспорт
	
	Подсистема = ПодсистемаПоИмени(ИмяПодсистемы);
	Если Подсистема = Неопределено Тогда
		Возврат; // нет такой подсистемы в метаданных
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Представление) Тогда
		Коллекция.Добавить(Подсистема, Представление);
	Иначе
		Коллекция.Добавить(Подсистема);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает метаданные подсистемы по ее имени.
//
// Параметры:
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно
//
// Возвращаемое значение:
//	Объект метаданных - метаданные подсистемы или Неопределено, если подсистемы с таким именем не существует
//
Функция ПодсистемаПоИмени(ИмяПодсистемы) Экспорт
	
	ПолноеИмяПодсистемы = Сред(СтрЗаменить("." + ИмяПодсистемы, ".", ".Подсистема."), 2);;
	
	Возврат Метаданные.НайтиПоПолномуИмени(ПолноеИмяПодсистемы);
	
КонецФункции

#КонецОбласти

#Область Прочее

Процедура ОбработатьВложенныеПоля(ЭлементыФормы, ЭлементФормы, МассивЭлементов, Структура, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы") Тогда
			ИмяЭлемента = ЭлементФормы.Имя;
			Структура.Вставить(ИмяЭлемента, Новый Массив);
			ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, Структура[ИмяЭлемента], ПоляИсключения);
		КонецЕсли;
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			Имя = Элемент.Имя;
			ПодчиненныйЭлемент = ЭлементыФормы[Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Имя) <> Неопределено
					Или ПоляИсключения.Найти(Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьВложенныеПоля(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, Структура, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, МассивЭлементов, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			ПодчиненныйЭлемент = ЭлементыФормы[Элемент.Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Элемент.Имя) <> Неопределено
					Или ПоляИсключения.Найти(Элемент.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Элемент.Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьПоляТаблицыФормы(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает идентификатор конфигурации.
// Длина идентификатора не должна превышать 8 символов.
//
Функция ИДКонфигурации() Экспорт
	
	Возврат "УТ11" + ?(СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации(), "Базовая", ""); // в конфигурации УТ11
	
КонецФункции

Функция ПолучитьПерфиксДляУИП(Ссылка)

	Соответствие = Новый Соответствие();
	Соответствие.Вставить("ДоговорыКонтрагентов",				"ДОГ");
	Соответствие.Вставить("АктВыполненныхРабот",				"АКТ");
	Соответствие.Вставить("ВозвратТоваровПоставщику",			"НКВ");
	Соответствие.Вставить("ВыкупВозвратнойТарыКлиентом",		"НК");
	Соответствие.Вставить("ЗаказКлиента",						"ЗК");
	Соответствие.Вставить("ЗаявкаНаВозвратТоваровОтКлиента",	"ЗКВ");
	Соответствие.Вставить("ОтчетКомиссионера",					"ОК");
	Соответствие.Вставить("ОтчетКомиссионераОСписании",			"ОКС");
	Соответствие.Вставить("ОтчетКомитенту",						"ОКТ");
	Соответствие.Вставить("ОтчетПоКомиссииМеждуОрганизациями",	"ОКО");
	Соответствие.Вставить("РеализацияТоваровУслуг",				"НК");
	Соответствие.Вставить("РеализацияУслугПрочихАктивов",		"НК");
	Соответствие.Вставить("ПередачаТоваровМеждуОрганизациями",	"НК");
	Соответствие.Вставить("СчетНаОплатуКлиенту",				"СЧ");
	Соответствие.Вставить("СчетФактураВыданный",				"СФ");
	
	Возврат Соответствие[Ссылка.Метаданные().Имя];
	
КонецФункции

Функция ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,Сдвиг = Неопределено)
	
	Если Сдвиг = Неопределено Тогда
		Сдвиг = 0;
	КонецЕсли;
	
	СтруктураСоответствий = Новый Структура("А ,Б ,В ,Г ,Д ,Е ,Ж ,З ,И ,К ,Л ,М ,Н ,О ,П ,Р ,С ,Т ,У ,Ф ,Х ,Ц ,Ч ,Ш ,Щ ,Э ,Ю ,Я ,Ъ ,Ы ,Ь,
											|A ,B ,C ,D ,E ,F ,G ,H ,I ,J ,K ,L ,M ,N ,O ,P ,Q ,R ,S ,T ,U ,V ,W ,X ,Y ,Z",
											 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,33,36,42,
											 1 ,3 ,17,29,6 ,30,31,13,32,33,10,34,12,35,14,16,36,37,38,18,39,40,41,21,19,42);
	СтрокаЦифр = "0123456789";	
	ВесРазряда = 1+Сдвиг;
	Результат = 0;
	// Замена служебных символов в коде.
	СтрокаБукв = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЭЮЯЪЫЬABCDEFGHIJKLMNOPQRSTUVWXYZ";
	НовКод = "";
	Для Инд = 1 По СтрДлина(Код) Цикл
		Попытка
			СимволКода = ВРЕГ(Сред(Код,Инд,1));
		Исключение
			СимволКода = Сред(Код,Инд,1);
		КонецПопытки;
		Если СтрНайти(СтрокаЦифр,СимволКода)=0 И СтрНайти(СтрокаБукв,СимволКода)=0 Тогда
			НовКод = НовКод + "0";
		Иначе
			НовКод = НовКод + СимволКода;
		КонецЕсли;
	КонецЦикла;
	Код = НовКод;
	//Конец замены
	Если СтрДлина(Код)<19 Тогда
		СтрокаКода = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Код,19,"0","Справа");
	Иначе
		СтрокаКода = Лев(Код,19);
	КонецЕсли;
	
	Для Инд = 1 По 19 Цикл 
		СимволКода = Сред(СтрокаКода,Инд,1);
		Если СтрНайти(СтрокаЦифр,СимволКода)>0 Тогда
			Значение = Число(СимволКода);
		ИначеЕсли СтруктураСоответствий.Свойство(ВРег(СимволКода)) Тогда
			Значение = СтруктураСоответствий[СимволКода]%10;			
		КонецЕсли;		
		Результат = Результат + ВесРазряда*Значение;
		
		ВесРазряда = ВесРазряда + 1;
		Если ВесРазряда = 11 Тогда
			ВесРазряда = 1;
		КонецЕсли;
	КонецЦикла;
	
	КонтрольныйРазряд = Результат % 11;
	
	Если КонтрольныйРазряд = 10 Тогда
		Если Сдвиг = 0 Тогда
			Возврат ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,2);
		Иначе
			КонтрольныйРазряд = 0;
		КонецЕсли;
	КонецЕсли;
	
	ПолныйКод = СтрокаКода+Строка(КонтрольныйРазряд);
	
	Возврат ПолныйКод;
	
КонецФункции

// Возращает массив уникальных значений из колонки таблицы
//
// Параметры:
//  Таблица    - ТаблицаЗначений, ДанныеФормыКоллекция, ТабличнаяЧасть - таблица, из которой необходимо выбрать данные
//  ИмяКолонки - Строка - имя колонки таблицы значений, из которой необходимо выбрать значения
// 
// Возвращаемое значение:
//  Массив - набор уникальных значений
//
Функция ВыгрузитьЗначенияКолонки(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ТаблицаКопия = Таблица.Скопировать(, ИмяКолонки);
	Иначе
		ТаблицаКопия = Таблица.Выгрузить(, ИмяКолонки);
	КонецЕсли;
	
	ТаблицаКопия.Свернуть(ИмяКолонки);
	
	Возврат ТаблицаКопия.ВыгрузитьКолонку(0);
	
КонецФункции

// Возвращает таблицу значений с данными дерева значений
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений, ДанныеФормыДерево - дерево с данными
//  Уровень		 - Число - уровень дерева, на котором расположены искомые данные (нумерация с 0). Если не передано, то 
//						   будут возвращенные данные со всех последних уровней веток.
//
// Возвращаемое значение:
//  ТаблицаЗначений - содержит данные дерева
//
Функция ДанныеДерева(ДеревоДанных, Уровень = Неопределено) Экспорт
	
	ТаблицаВозврата = Новый ТаблицаЗначений;
	Для Каждого Колонка Из ДеревоДанных.Колонки Цикл
		ТаблицаВозврата.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	Если ТипЗнч(ДеревоДанных) = Тип("ДеревоЗначений") Тогда
		СтрокиДерева = ДеревоДанных.Строки;
	ИначеЕсли ТипЗнч(ДеревоДанных) = Тип("ДанныеФормыДерево") Тогда
		СтрокиДерева = ДеревоДанных.ПолучитьЭлементы();
	Иначе
		ВызватьИсключение НСтр("ru = 'Передан некорректный тип аргумента'");
	КонецЕсли;
	
	ЗаполнитьТаблицуРекурсивно(ТаблицаВозврата, СтрокиДерева, Уровень, 0);
	
	Возврат ТаблицаВозврата;

КонецФункции

Процедура ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, СтрокиДерева, ИскомыйУровень, ТекущийУровень)
	
	Для Каждого Строка Из СтрокиДерева Цикл

		Если ТипЗнч(СтрокиДерева) = Тип("КоллекцияСтрокДереваЗначений") Тогда
			Подстроки = Строка.Строки;
		ИначеЕсли ТипЗнч(СтрокиДерева) = Тип("ДанныеФормыКоллекцияЭлементовДерева") Тогда
			Подстроки = Строка.ПолучитьЭлементы();
		КонецЕсли;
		
		Если ИскомыйУровень = ТекущийУровень 
			Или (ИскомыйУровень = Неопределено И Подстроки.Количество() = 0) Тогда
			НовСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
		Иначе
			ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, Подстроки, ИскомыйУровень, ТекущийУровень + 1);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает свойства последнего задания.
//
// Параметры:
//  Задание - РегламентноеЗадание, Строка, ОчередьЗаданийОбластейДанных - строка уникального идентификатора РегламентногоЗадания.
//
// Возвращаемое значение:
//  СтруктураСвойств.
//
Функция ПолучитьСостояниеПоследнегоЗадания(Задание) Экспорт
	
	СвойстваЗадания = Новый Структура("ДатаНачала, ДатаЗавершения, Состояние");
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		
		ЭлементСправочника = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Задание.Идентификатор, "ДатаНачалаПоследнегоЗапуска, ДатаЗавершенияПоследнегоЗапуска, СостояниеЗадания");
		
		СвойстваЗадания.ДатаНачала = ЭлементСправочника.ДатаНачалаПоследнегоЗапуска;
		СвойстваЗадания.ДатаЗавершения = ЭлементСправочника.ДатаЗавершенияПоследнегоЗапуска;
		СвойстваЗадания.Состояние = ЭлементСправочника.СостояниеЗадания;
		
	Иначе
		
		СвойстваРегЗадания = РегламентныеЗаданияСлужебный.ПолучитьСвойстваПоследнегоФоновогоЗаданияВыполненияРегламентногоЗадания(Задание);
		
		Если СвойстваРегЗадания <> Неопределено Тогда
		
			СвойстваЗадания.ДатаНачала = СвойстваРегЗадания.Начало;
			СвойстваЗадания.ДатаЗавершения = СвойстваРегЗадания.Конец;
			СвойстваЗадания.Состояние = СвойстваРегЗадания.Состояние;
		
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СвойстваЗадания;
	
КонецФункции

Функция СвойствоМетаданных(МетаданныеОбъекта, ЧастиИмени, Индекс = 0)
	
	Имя = ЧастиИмени[Индекс];
	Свойство = МетаданныеОбъекта[Имя];
	Если Индекс < ЧастиИмени.ВГраница() Тогда
		Свойство = СвойствоМетаданных(Свойство, ЧастиИмени, Индекс+1);
	КонецЕсли;
	Возврат Свойство;
	
КонецФункции

// Проверяет, что переданный тип - примитивный
//
// Параметры:
//  ПроверяемыйТип	 - Тип - 
// 
// Возвращаемое значение:
//  Ьулево 
//
Функция ЭтоПримитивныйТип(ПроверяемыйТип) Экспорт
	
	Если ПроверяемыйТип = Тип("Неопределено")
		Или ПроверяемыйТип = Тип("Булево")
		Или ПроверяемыйТип = Тип("Строка")
		Или ПроверяемыйТип = Тип("Число")
		Или ПроверяемыйТип = Тип("Дата")
		Или ПроверяемыйТип = Тип("УникальныйИдентификатор") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

// Представление объекта по метаданнным
//
// Параметры:
//  МетаданныеОбъекта	 - ОбъектМетаданных 
// 
// Возвращаемое значение:
//  Строка 
//
Функция ПредставлениеОбъектаПоМетаданнным(МетаданныеОбъекта) Экспорт
		
	Если Не ПустаяСтрока(МетаданныеОбъекта.ПредставлениеОбъекта) Тогда
		Возврат МетаданныеОбъекта.ПредставлениеОбъекта;
	Иначе
		Возврат МетаданныеОбъекта.Синоним;
	КонецЕсли;
	
КонецФункции

// Получает склад который можно использовать по умолчанию
// Если склад не удалось определить и не используется несколько складов то пользователю выдается сообщение
// 
// Возвращаемое значение:
//   СправочникСсылка.Склады
//
Функция ПолучитьПроверитьСкладПоУмолчанию() Экспорт

	СкладПоУмолчанию = ЗначениеНастроекПовтИсп.ПолучитьСкладПоУмолчанию();
	
	Если Не ЗначениеЗаполнено(СкладПоУмолчанию)
		И Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоСкладов") Тогда
		
		Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
		|	Склады.Ссылка
		|ИЗ
		|	Справочник.Склады КАК Склады");
		
		Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось определить склад, т.к. в информационной базе введено несколько складов,
			|Включите опцию ""НСИ и администрирование""-""Склад и доставка""-""Несколько складов""!'");
		Иначе
			ВызватьИсключение НСтр("ru = 'Не удалось определить склад. Возможно, в информационной базе не введено ни одного склада
			|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка складского учета"".'");
		КонецЕсли;
		
	КонецЕсли;

	Возврат СкладПоУмолчанию
	
КонецФункции

// Устанавливаем условное оформление для поля формы "ВариантОформления" в документе ТаможеннаяДекларация
//    в зависимости от его значения
//
// Параметры:
// 		Список - Форма - Содержит данную форму 
//
Процедура УстановитьУсловноеОформлениеВариантОформленияГТД(Список) Экспорт
	
	УсловноеОформление = Список.УсловноеОформление;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДБрокером;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Брокером'"));
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДСамостоятельно;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Самостоятельно'"));
	
КонецПроцедуры

Функция РазделительЗапросовПакета(ИмяЗапроса = Неопределено) Экспорт
	
	Текст = "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" + ?(ЗначениеЗаполнено(ИмяЗапроса), "// "+ ИмяЗапроса, "") + "
	|";
	
	Возврат Текст;
	
КонецФункции

Функция ЭтоЗаписьВедомогоРегистраСведений(Ссылка, Регистры)
	
	Для Каждого Элемент Из Регистры Цикл
		Если ТипЗнч(Ссылка) = Тип("РегистрСведенийКлючЗаписи." + Элемент.Имя) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция НазначенияЗаказов(МассивЗаказов)
	
	Запрос = Новый Запрос();
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Таблица.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Назначения КАК Таблица
		|ГДЕ
		|	Таблица.Заказ В(&МассивЗаказов)";
	Запрос.УстановитьПараметр("МассивЗаказов", МассивЗаказов);
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Переносит файл от прежнего владельца к новому
//
// Параметры:
//	ВладелецФайла - Ссылка - ссылка на новый объект-владелец файла
//	РеквизитПриемник - Ссылка на справочник присоединенных файлов - Значение переменной-приемника ссылки на новый файл
//	РеквизитИсточник - Ссылка на справочник присоединенных файлов - Значение переменной-источника ссылки на новый файл
//	ФормироватьНовуюСсылкуНаФайл - Булево - указывает создавать ли файл с новой ссылкой или использовать текущую
//
Процедура СкопироватьПрисоединенныйФайл(ВладелецФайла, РеквизитПриемник, РеквизитИсточник, ФормироватьНовуюСсылкуНаФайл = Истина) Экспорт
	ФайлИсточник = РаботаСФайлами.ДанныеФайла(РеквизитИсточник, Новый УникальныйИдентификатор, Истина);
	
	Параметры = Новый Структура;
	Параметры.Вставить("Автор", Пользователи.ТекущийПользователь());
	Параметры.Вставить("ВладелецФайлов", ВладелецФайла);
	Параметры.Вставить("ИмяБезРасширения", ФайлИсточник.Наименование);
	Параметры.Вставить("РасширениеБезТочки", ФайлИсточник.Расширение);
	Параметры.Вставить("ВремяИзмененияУниверсальное", ФайлИсточник.ДатаМодификацииУниверсальная);
	
	ИмяСправочника = РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(ВладелецФайла,, Неопределено);
	
	РеквизитПриемник = РаботаСФайлами.ДобавитьФайл(
		Параметры,
		ФайлИсточник.СсылкаНаДвоичныеДанныеФайла,,
		РеквизитИсточник.Описание,
		?(ФормироватьНовуюСсылкуНаФайл, 
			Неопределено, 
			Справочники[ИмяСправочника].ПолучитьСсылку(РеквизитИсточник.УникальныйИдентификатор())
		)
	);
КонецПроцедуры

// Уничтожает временные таблицы менеджера временных таблиц.
//
// Параметры:
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - менеджер временных таблиц, таблицы которого нужно уничтожить.
//	СписокТаблиц - Строка - имена временных таблиц для уничтожения, разделенные запятыми. Если параметр не установлен - все таблицы.
//	ИсключаяТаблицы - Строка - имена временных таблиц, которые нужно оставить, разделенные запятыми.
//
Процедура УничтожитьВременныеТаблицы(МенеджерВременныхТаблиц, СписокТаблиц = Неопределено, ИсключаяТаблицы = Неопределено) Экспорт
	
	Если ИсключаяТаблицы <> Неопределено Тогда
		МассивИсключаемыхТаблиц = СтрРазделить(ИсключаяТаблицы, ",");
	Иначе
		МассивИсключаемыхТаблиц = Новый Массив();
	КонецЕсли;
	
	Если СписокТаблиц <> Неопределено Тогда
		МассивТаблиц = СтрРазделить(СписокТаблиц, ",");
	Иначе
		МассивТаблиц = Новый Массив();
		Для Каждого Таблица Из МенеджерВременныхТаблиц.Таблицы Цикл
			Если МассивИсключаемыхТаблиц.Найти(Таблица.ПолноеИмя) = Неопределено Тогда
				МассивТаблиц.Добавить(Таблица.ПолноеИмя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если МассивТаблиц.Количество() > 0 Тогда
		ТекстЗапроса = "";
		Для Каждого ИмяТаблицы Из МассивТаблиц Цикл
			ТекстЗапроса = ТекстЗапроса + "УНИЧТОЖИТЬ " + ИмяТаблицы + "; ";
		КонецЦикла;
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.Выполнить();
	КонецЕсли;
	
КонецПроцедуры

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	СериализуемыйОбъект - Произвольный - объект, который может быть сериализован. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки
//
Функция ХешСуммаСериализуемогоОбъекта(СериализуемыйОбъект, ТипХешФункции) Экспорт
	СериализованнаяСтрока = ОбщегоНазначения.ЗначениеВСтрокуXML(СериализуемыйОбъект);
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(СериализованнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	ИсходнаяСтрока - Строка - строка, по которой будет строится хеш. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки
//
Функция ХешСуммаСтроки(ИсходнаяСтрока, ТипХешФункции) Экспорт
	Если Не ТипЗнч(ИсходнаяСтрока) = Тип("Строка") Тогда
		ВызватьИсключение НСтр("ru = 'Недопустимый тип источника получения данных.'");
	КонецЕсли;
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(ИсходнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

#КонецОбласти

#Область РаботаСЖурналамиДокументов 

Процедура ЗаполнитьОтборыПоТаблицеХозОперацийИТиповДокументов(ТаблицаЗначенийДоступно, ОтборХозяйственныеОперации, ОтборТипыДокументов) Экспорт
	
	СтруктураОтбора = Новый Структура("Отбор", Истина);
	ТЗХозОперацииИТипыДокументов = ТаблицаЗначенийДоступно.Скопировать(СтруктураОтбора, "ХозяйственнаяОперация,ИдентификаторОбъектаМетаданных");
	
	ТЗХозОперации = ТЗХозОперацииИТипыДокументов.Скопировать(,"ХозяйственнаяОперация");
	ТЗХозОперации.Свернуть("ХозяйственнаяОперация");
	ОтборХозяйственныеОперации.ЗагрузитьЗначения(ТЗХозОперации.ВыгрузитьКолонку("ХозяйственнаяОперация"));
	
	ТЗХозОперацииИТипыДокументов.Свернуть("ИдентификаторОбъектаМетаданных");
	ОтборТипыДокументов.ЗагрузитьЗначения(ТЗХозОперацииИТипыДокументов.ВыгрузитьКолонку("ИдентификаторОбъектаМетаданных"));
	
КонецПроцедуры

Процедура СформироватьНадписьОтбор(ИнформационнаяНадписьОтбор, ХозяйственныеОперацииИДокументы, ОтборТипыДокументов, ОтборХозяйственныеОперации) Экспорт
	МассивСтрокНадписи = Новый Массив();
	
	ЕстьОтборы = ХозяйственныеОперацииИДокументы.НайтиСтроки(Новый Структура("Отбор",Ложь)).Количество() > 0;
	Если ЕстьОтборы Тогда
		
		ТекстНадписи = НСтр("ru = 'Показаны %КоличествоХозОпераций% по %КоличествоДокументов%'");
		
		КоличествоХозОпераций = СтроковыеФункцииКлиентСервер.ЧислоЦифрамиПредметИсчисленияПрописью(ОтборХозяйственныеОперации.Количество(),НСтр("ru = 'хоз. операция, хоз. операции, хоз. операций'"));
		ТекстНадписи = СтрЗаменить(ТекстНадписи,"%КоличествоХозОпераций%", КоличествоХозОпераций);
		КоличествоТипыДокументов = СтроковыеФункцииКлиентСервер.ЧислоЦифрамиПредметИсчисленияПрописью(ОтборТипыДокументов.Количество(),НСтр("ru = 'документу, документам, документам'"));
		ТекстНадписи = СтрЗаменить(ТекстНадписи,"%КоличествоДокументов%", КоличествоТипыДокументов);
		
		МассивСтрокНадписи.Добавить(ТекстНадписи);
		
		МассивСтрокНадписи.Добавить("  ");
		
		МассивСтрокНадписи.Добавить(Новый ФорматированнаяСтрока(НСтр("ru = 'Настроить'"),,,,"НастроитьОтбор"));
		
	Иначе
		
		МассивСтрокНадписи.Добавить(НСтр("ru = 'Показаны все документы журнала'"));
		МассивСтрокНадписи.Добавить("  ");
		МассивСтрокНадписи.Добавить(Новый ФорматированнаяСтрока(НСтр("ru = 'Настроить'"),,,,"НастроитьОтбор"));
		
	КонецЕсли;
	
	ИнформационнаяНадписьОтбор = Новый ФорматированнаяСтрока(МассивСтрокНадписи);
	
КонецПроцедуры

// Возвращает таблицу с хозяйственными операциями и типами документов доступными по функциональным опциям
// и по правам.
//
// Параметры:
//	ИмяРабочегоМеста - Строка
//
// Возвращаемое значение:
//	ТаблицаЗначений с колонками
//		- ХозяйственнаяОперация
//		- ИдентификаторОбъектаМетаданных
//		- Отбор
//		- ДокументПредставление
//
Функция ДоступныеХозяйственныеОперацииИДокументы(ТаблицаЗначений, ОтборХозяйственныеОперации, ОтборТипыДокументов, КлючНазначенияИспользования) Экспорт
	
	ТаблицаРезультата = ТаблицаЗначений.СкопироватьКолонки();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ИспользоватьВРеестреДокументов
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|ГДЕ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация В(&МассивХозяйственныхОпераций)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	НастройкиХозяйственныхОперацийДокументы.НомерСтроки,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмя,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|ГДЕ
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация В(&МассивХозяйственныхОпераций)
	|	И НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных <> ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
	|ИТОГИ ПО
	|	ХозяйственнаяОперация";
	
	МассивХозяйственныхОпераций = ТаблицаЗначений.ВыгрузитьКолонку("ХозяйственнаяОперация");
	
	Запрос.УстановитьПараметр("МассивХозяйственныхОпераций", МассивХозяйственныхОпераций);
	
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	ВыборкаПоФункциональнымОпциям = РезультатЗапроса[0].Выбрать();
	ВыборкаПоДокументам = РезультатЗапроса[1].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	ИдентификаторыОбъектовМетаданных = РезультатЗапроса[1].Выгрузить().ВыгрузитьКолонку("ИдентификаторОбъектаМетаданных");
	ИдентификаторыОбъектовМетаданных = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ИдентификаторыОбъектовМетаданных);
	// Удалим пустое значение.
	ИдентификаторыОбъектовМетаданных.Удалить(0);
	ПраваПоИдентификаторам = УправлениеДоступом.ПраваПоИдентификаторам(ИдентификаторыОбъектовМетаданных);
	
	
	Пока ВыборкаПоДокументам.Следующий() Цикл
		
		Если ВыборкаПоФункциональнымОпциям.НайтиСледующий(Новый Структура("ИспользоватьВРеестреДокументов", Ложь)) Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Хозяйственная операция ""%1"" не используется журналах документов.'"), ВыборкаПоФункциональнымОпциям.ХозяйственнаяОперация);
		КонецЕсли;
		
		ХозяйственнаяОперацияДоступнаПоФо = Ложь;
		ЕстьФО = Ложь;
		
		Пока ВыборкаПоФункциональнымОпциям.НайтиСледующий(Новый Структура("ХозяйственнаяОперация", ВыборкаПоДокументам.ХозяйственнаяОперация)) Цикл
			
			ЕстьФО = Истина;
			ХозяйственнаяОперацияДоступнаПоФо = ПолучитьФункциональнуюОпцию(ВыборкаПоФункциональнымОпциям.ИмяФункциональнойОпции) 
												Или ХозяйственнаяОперацияДоступнаПоФо;
			
		КонецЦикла;
		ВыборкаПоФункциональнымОпциям.Сбросить();
		Если ЕстьФО И Не ХозяйственнаяОперацияДоступнаПоФо Тогда
			Продолжить;
		КонецЕсли;
		
		Выборка = ВыборкаПоДокументам.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			ПраваИдентификатораОбъектаМетаданных = ПраваПоИдентификаторам.Получить(Выборка.ИдентификаторОбъектаМетаданных);
			Если ПраваИдентификатораОбъектаМетаданных = Неопределено
				Или Не ПраваИдентификатораОбъектаМетаданных.Чтение Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяДокумента = СтрРазделить(Выборка.ПолноеИмя,".")[1];
			ОбъектМетаданных = Метаданные.Документы[ИмяДокумента];
			
			Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				
				Отбор = Новый Структура("ХозяйственнаяОперация, ПолноеИмяДокумента", Выборка.ХозяйственнаяОперация, Выборка.ПолноеИмя);
				НайденныеСтроки = ТаблицаЗначений.НайтиСтроки(Отбор);
				Для Каждого Строка Из НайденныеСтроки Цикл
					НоваяСтрока = ТаблицаРезультата.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
					НоваяСтрока.ИдентификаторОбъектаМетаданных = Выборка.ИдентификаторОбъектаМетаданных;
					НоваяСтрока.ДокументПредставление = Выборка.Синоним;
					НоваяСтрока.ПравоДоступаДобавление = ПраваИдентификатораОбъектаМетаданных.Добавление;
					НоваяСтрока.ПравоДоступаИзменение = ПраваИдентификатораОбъектаМетаданных.Изменение;
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если КлючНазначенияИспользования = "" 
		И ОтборХозяйственныеОперации.Количество() = 0 
		И ОтборТипыДокументов.Количество() = 0 Тогда
		ТаблицаРезультата.ЗаполнитьЗначения(Истина, "Отбор");
	Иначе
		Для Каждого Строка Из ТаблицаРезультата Цикл
			Если ОтборХозяйственныеОперации.Количество() > 0 
					И ОтборТипыДокументов.Количество() > 0
					И ОтборХозяйственныеОперации.НайтиПоЗначению(Строка.ХозяйственнаяОперация) <> Неопределено
					И ОтборТипыДокументов.НайтиПоЗначению(Строка.ИдентификаторОбъектаМетаданных) <> Неопределено
				Или ОтборХозяйственныеОперации.Количество() = 0 
					И ОтборТипыДокументов.Количество() = 0
					И Строка.КлючНазначенияИспользования = КлючНазначенияИспользования Тогда 
				Строка.Отбор = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если ОтборХозяйственныеОперации.Количество() = 0 
		И ОтборТипыДокументов.Количество() = 0 Тогда
		ЗаполнитьОтборыПоТаблицеХозОперацийИТиповДокументов(ТаблицаРезультата, ОтборХозяйственныеОперации, ОтборТипыДокументов);
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции

// Массив менеджеров документов, используемых в переданном массиве хозяйственных операций
//
// Параметры:
//  МассивХозяйственныхОпераций - Массив - 
// 
// Возвращаемое значение:
//   - Массив
//
Функция ИспользуемыеМенеджерыДокументов(ДоступныеХозяйственныеОперацииИДокументы) Экспорт 
	
	ТаблицаОперацииНакладные = ВыделенныеХозяйственныеОперацииИДокументы(ДоступныеХозяйственныеОперацииИДокументы);
	
	Метаданные = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ОбъектМетаданныхДокумента");
	
	МассивМенеджеров = Новый Массив();
	
	Для Каждого Строка Из Метаданные Цикл
		Имя = Строка.Имя;
		МенеджерДокумента = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Имя);
		МассивМенеджеров.Добавить(МенеджерДокумента);
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивМенеджеров);
	
	Возврат МассивМенеджеров;
	
КонецФункции

// Массив типов документов, используемых в переданном массиве хозяйственных операций
//
// Параметры:
//  МассивХозяйственныхОпераций - Массив - 
//  Отбор 						- Структура - Структура отбора по таблице ОписаниеМетаданныхНакладных
// 
// Возвращаемое значение:
//   - Массив
//
Функция ИспользуемыеПолныеИменаДокументов(ХозяйственныеОперацииИДокументы, Отбор = Неопределено) Экспорт 
	
	ПолныеИменаДокументов = Новый Массив();
	
	ТаблицаОперацииНакладные = ВыделенныеХозяйственныеОперацииИДокументы(ХозяйственныеОперацииИДокументы);
		
	Если Отбор <> Неопределено Тогда
		НайденныеСтроки = ТаблицаОперацииНакладные.НайтиСтроки(Отбор);
		
		Для Каждого Строка Из НайденныеСтроки Цикл
			ПолныеИменаДокументов.Добавить(Строка.ПолноеИмяДокумента);
		КонецЦикла;
	Иначе
		
		ПолныеИменаДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ПолноеИмяДокумента");
		
	КонецЕсли;
	
	ПолныеИменаДокументов = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ПолныеИменаДокументов);
	
	Возврат ПолныеИменаДокументов;
	
КонецФункции

// Возвращает таблицу с выделенными отборами по хоз. операциям и документам
//
// Параметры:
//  ДоступныеХозяйственныеОперацииИДокументы - ТаблицаЗначений	 - выгрузка таблицы из реквизита формы ХозяйственныеОперцииИДокументы
// 
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция ВыделенныеХозяйственныеОперацииИДокументы(ДоступныеХозяйственныеОперацииИДокументы) Экспорт  
	
	ОтобраннаяТаблица = ДоступныеХозяйственныеОперацииИДокументы.СкопироватьКолонки();
	
	Отбор = Новый Структура();
	Отбор.Вставить("Отбор", Истина);
	
	НайденныеСтроки = ДоступныеХозяйственныеОперацииИДокументы.НайтиСтроки(Отбор);
	
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		Строка = ОтобраннаяТаблица.Добавить();
		ЗаполнитьЗначенияСвойств(Строка, НайденнаяСтрока);
	КонецЦикла;
	
	Возврат ОтобраннаяТаблица;
	
КонецФункции

// Выделенные хозяйственные операции
//
// Параметры:
//  ДоступныеХозяйственныеОперации	 - Коллекция	 - Список значений формы с доступными хоз. операциями
// 
// Возвращаемое значение:
//  Массив - 
//
Функция ВыделенныеХозяйственныеОперации(ХозяйственныеОперацииИДокументы) Экспорт 
	
	МассивХозОпераций = Новый Массив();
	
	МассивВыделенныхСтрок = ХозяйственныеОперацииИДокументы.НайтиСтроки(Новый Структура("Отбор", Истина));	
	
	Для Каждого Строка Из МассивВыделенныхСтрок Цикл
		МассивХозОпераций.Добавить(Строка.ХозяйственнаяОперация);
	КонецЦикла;
	
	// Пустой массив означает отсутствие отбора. Отсутствие отбора равнозначно всем выбранным элементам
	Если МассивХозОпераций.Количество() = 0 Тогда
		МассивХозОпераций = ХозяйственныеОперацииИДокументы.ВыгрузитьКолонку("ХозяйственнаяОперация");
	КонецЕсли;
	
	Возврат МассивХозОпераций;
	
КонецФункции

// Процедура - Удалить подчиненные элементы элемента формы
//
// Параметры:
//  Форма			 - УправляемаяФорма	- форма, с которой удаляются элемены
//  ЭлементФормы	 - ЭлементФормы	 	- элемент формы, подчиненные элементы которого нжно удалить
//  УдалятьКоманды	 - 				 	- Булево
//  Команды			 - Коллекция	 	- коллекция команд формы, обязательно должен быть заполнен, если УдалятьКоманды = Истина.
//
Процедура УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, ЭлементФормы, УдалятьКоманды = Ложь) Экспорт 
	
	ЭлементыНаУдаление = Новый Массив();
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ЭлементыНаУдаление, ЭлементФормы.ПодчиненныеЭлементы);
	Для ИндексЭлемента = 0 По ЭлементыНаУдаление.Количество() - 1 Цикл
		
		Элемент = ЭлементыНаУдаление[ИндексЭлемента];
		
		Если ТипЗнч(Элемент) = Тип("ГруппаФормы") Тогда
			УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, Элемент, УдалятьКоманды);
		ИначеЕсли ТипЗнч(Элемент) = Тип("КнопкаФормы")
			И УдалятьКоманды Тогда			
			КомандаКУдалению = Форма.Команды.Найти(Элемент.ИмяКоманды);
			Если КомандаКУдалению <> Неопределено Тогда
				Форма.Команды.Удалить(КомандаКУдалению);
			КонецЕсли;
		КонецЕсли;
		
		Форма.Элементы.Удалить(Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Добавляет кнопки изменения статусов в группу формы
//
// Параметры:
//  Форма							 - УправляемаяФорма	 - 
//  СписокУстановитьСтатус			 - ЭлементФормы	- Группа формы, куда должны быть помещены кнопки изменения статусов
//
Процедура УстановитьСписокСтатусов(Форма, СписокУстановитьСтатус) Экспорт
		
	// Очистка элементов в случае переинициализации списка статусов
	УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, СписокУстановитьСтатус);
	
	Форма.СоответствиеКомандСтатусам.Очистить();
	
	СтатусыДокументов = Новый ТаблицаЗначений();
	СтатусыДокументов.Колонки.Добавить("ИмяДокумента", 			Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СинонимДокумента", 		Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СтатусПредставление", 	Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СтатусИмяЗначения", 	Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("Статус");
	
	СоответствияОпераций = ВыделенныеХозяйственныеОперацииИДокументы(Форма.ХозяйственныеОперацииИДокументы.Выгрузить());
		
	СоответствияОпераций.Свернуть("ПолноеИмяДокумента, ИспользуютсяСтатусы, ПравоДоступаИзменение");
	
	Для Каждого СтрокаСоответствия Из СоответствияОпераций Цикл
		
		Если СтрокаСоответствия.ИспользуютсяСтатусы И СтрокаСоответствия.ПравоДоступаИзменение Тогда
			МенеджерДокумента = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(СтрокаСоответствия.ПолноеИмяДокумента);
			СтатусыДокумента = МенеджерДокумента.СтатусыДокументаИзменяемыеИзСписка();
			МетаданныеОбъекта = МетаданныеОбъектаПоПолномуИмени(СтрокаСоответствия.ПолноеИмяДокумента);
			Для Каждого СтрокаСтатус Из СтатусыДокумента Цикл
				СтрокаСтатусаДокумета = СтатусыДокументов.Добавить();
				СтрокаСтатусаДокумета.ИмяДокумента = МетаданныеОбъекта.Имя;
				СтрокаСтатусаДокумета.СинонимДокумента = МетаданныеОбъекта.Синоним;
				СтрокаСтатусаДокумета.Статус = СтрокаСтатус.Статус;
				СтрокаСтатусаДокумета.СтатусПредставление = СтрокаСтатус.СтатусПредставление;
				СтрокаСтатусаДокумета.СтатусИмяЗначения = ОбщегоНазначения.ИмяЗначенияПеречисления(СтрокаСтатус.Статус);
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Индекс = 0 По СтатусыДокументов.Количество() - 1 Цикл
		
		СтрокаСтатусаДокумета = СтатусыДокументов[Индекс];
		
		УникальноеИмяКнопки = СтрокаСтатусаДокумета.ИмяДокумента + Индекс;
		
		Если Форма.Команды.Найти(УникальноеИмяКнопки) = Неопределено Тогда
			Команда = Форма.Команды.Добавить(УникальноеИмяКнопки);
			Команда.Действие = "Подключаемый_УстановитьСтатус";
		КонецЕсли;
		
		Кнопка = Форма.Элементы.Добавить(УникальноеИмяКнопки, Тип("КнопкаФормы"), СписокУстановитьСтатус);
		Кнопка.Заголовок = СтрокаСтатусаДокумета.СинонимДокумента + ": " + СтрокаСтатусаДокумета.СтатусПредставление;
		Кнопка.ИмяКоманды = УникальноеИмяКнопки;
		
		СтрокаСоответствияКоманд = Форма.СоответствиеКомандСтатусам.Добавить();
		СтрокаСоответствияКоманд.ИмяКоманды = УникальноеИмяКнопки;
		СтрокаСоответствияКоманд.Статус = СтрокаСтатусаДокумета.Статус;
		СтрокаСоответствияКоманд.СтатусПредставление = СтрокаСтатусаДокумета.СтатусПредставление;
		СтрокаСоответствияКоманд.СтатусИмяЗначения = СтрокаСтатусаДокумета.СтатусИмяЗначения;
		СтрокаСоответствияКоманд.ДокументСтрока = СтрокаСтатусаДокумета.ИмяДокумента;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает шаблон таблицы для помещения в нее описаний статусов для журналов документов.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - табилца с колонками:
//		*Статус - ПеречислениеСсылка - ссылка на статус документа
//		*СтатусПредставление - Строка - представление статуса; указывается, если нужно переопределеть синоним статуса
//
Функция ТаблицаСтатусовИзменяемыхИзСписка() Экспорт 
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Статус");
	Таблица.Колонки.Добавить("СтатусПредставление", Новый ОписаниеТипов("Строка"));
	
	Возврат Таблица;
	
КонецФункции

// Добавляет строку в ранее созданную таблицу
//
// Параметры:
//  Таблица				 - ТаблицаЗначений		 - см. ТаблицаСтатусовИзменяемыхИзСписка()
//  Статус				 - ПеречислениеСсылка	 - см. ТаблицаСтатусовИзменяемыхИзСписка()
//  СтатусПредставление	 - Строка				 - см. ТаблицаСтатусовИзменяемыхИзСписка()
//
Процедура ДобавитьСтрокуВТаблицуСтатусовИзменяемыхИзСписка(Таблица, Статус, Знач СтатусПредставление = "") Экспорт
	
	НоваяСтрока = Таблица.Добавить();
	НоваяСтрока.Статус = Статус;
	Если Не ЗначениеЗаполнено(СтатусПредставление) Тогда 
		СтатусПредставление = Строка(Статус);
	КонецЕсли;
	НоваяСтрока.СтатусПредставление = СтатусПредставление;
		
КонецПроцедуры

// Возвращает массив объектов метаданных по таблице ХозяйственныеОперацииИДокументы
//
// Параметры:
//  ХозяйственныеОперацииИДокументы	 - 	ТаблицаЗначений, ДанныеФормыКоллекция - таблица колонками "ПолноеИмяДокумента" и "Отбор"
//  Отбор							 - 	Структура - структура дополнительных отборов, ключи которых должны быть колонками в таблице ХозяйственныеОперацииИДокументы
// 
// Возвращаемое значение:
//  Массив - массив объектов метаданных
//
Функция ОбъектыМетаданныхИзХозяйственныхОперацийИДокументов(ХозяйственныеОперацииИДокументы, Отбор = Неопределено) Экспорт
	
	СтруктураОтбора = Новый Структура("Отбор",Истина);
	Если Отбор <> Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(СтруктураОтбора, Отбор);
	КонецЕсли;
	НайденныеСтроки = ХозяйственныеОперацииИДокументы.НайтиСтроки(СтруктураОтбора);
	ОбработанныеИмена = Новый Соответствие;
	ОбъектыМетаданных = Новый Массив;
	Для Каждого Стр Из НайденныеСтроки Цикл
		Если ОбработанныеИмена.Получить(Стр.ПолноеИмяДокумента) = Неопределено Тогда
			ОбработанныеИмена.Вставить(Стр.ПолноеИмяДокумента, Стр.ПолноеИмяДокумента);
			МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(Стр.ПолноеИмяДокумента);
			ОбъектыМетаданных.Добавить(МетаданныеОбъекта);
		КонецЕсли;
	КонецЦикла;
	Возврат ОбъектыМетаданных;
	
КонецФункции

// Взвращает структуру параметров настройки кнопок управления документами со следующими ключами
//		*Форма - УправляемаяФорма - сюда должна быть помещена управляемая форма, в которой происходит настройка кнопок
//		*ИмяТаблицыХозяйственныхОперацийИДокументов - Строка - имя реквизита формы, который является табличной частью и хранит хоз. операции и документы рабочего места
//		*ИмяКнопкиСкопировать - Строка - имя элемента формы (кнопки Скопировать)
//		*ИмяКнопкиИзменить - Строка - имя элемента формы (кнопки Изменить)
//		*ИмяКнопкиПровести - Строка - имя элемента формы (кнопки Провести)
//		*ИмяКнопкиОтменаПроведения - Строка - имя элемента формы (кнопки ОтменитьПроведение)
//		*ИмяКнопкиУстановитьПометкуУдаления - Строка - имя элемента формы (кнопки УстановитьПометкуУдаления)
//		*ИмяГруппыСоздать - Строка - имя элемента формы (группы Создать)
// 
// Возвращаемое значение:
//  Структура
//
Функция СтруктураПараметровНастройкиКнопокУправленияДокументами() Экспорт 
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Форма");
	СтруктураПараметров.Вставить("ИмяТаблицыХозяйственныхОперацийИДокументов", "ХозяйственныеОперацииИДокументы");
	СтруктураПараметров.Вставить("ИмяКнопкиСкопировать");
	СтруктураПараметров.Вставить("ИмяКнопкиСкопироватьКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиИзменить");
	СтруктураПараметров.Вставить("ИмяКнопкиИзменитьКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиПровести");
	СтруктураПараметров.Вставить("ИмяКнопкиПровестиКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиОтменаПроведения");
	СтруктураПараметров.Вставить("ИмяКнопкиОтменаПроведенияКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиУстановитьПометкуУдаления");
	СтруктураПараметров.Вставить("ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяГруппыСоздать", "ГруппаСоздатьГенерируемая");
	СтруктураПараметров.Вставить("ИмяГруппыСоздатьКонтекст", "ГруппаСоздатьГенерируемаяКонтекст");
	СтруктураПараметров.Вставить("ПрефиксЭлементов", "");
	
	Возврат СтруктураПараметров;
		
КонецФункции

// Корректирует состав команд управления документами 
//
// Параметры:
//  СтруктураПараметров	 - Структура	 - см. функцию СтруктураПараметровНастройкиКнопокУправленияДокументами()
//
Процедура НастроитьКнопкиУправленияДокументами(СтруктураПараметров) Экспорт
	
	Форма 												= СтруктураПараметров.Форма;
	ИмяТаблицыХозяйственныхОперацийИДокументов 			= СтруктураПараметров.ИмяТаблицыХозяйственныхОперацийИДокументов;
	ИмяКнопкиСкопировать 								= СтруктураПараметров.ИмяКнопкиСкопировать;
	ИмяКнопкиСкопироватьКонтекстноеМеню 				= СтруктураПараметров.ИмяКнопкиСкопироватьКонтекстноеМеню;
	ИмяКнопкиИзменить 									= СтруктураПараметров.ИмяКнопкиИзменить;
	ИмяКнопкиИзменитьКонтекстноеМеню 					= СтруктураПараметров.ИмяКнопкиИзменитьКонтекстноеМеню;
	ИмяКнопкиПровести 									= СтруктураПараметров.ИмяКнопкиПровести;
	ИмяКнопкиПровестиКонтекстноеМеню 					= СтруктураПараметров.ИмяКнопкиПровестиКонтекстноеМеню;
	ИмяКнопкиОтменаПроведения 							= СтруктураПараметров.ИмяКнопкиОтменаПроведения;
	ИмяКнопкиОтменаПроведенияКонтекстноеМеню 			= СтруктураПараметров.ИмяКнопкиОтменаПроведенияКонтекстноеМеню;
	ИмяКнопкиУстановитьПометкуУдаления 					= СтруктураПараметров.ИмяКнопкиУстановитьПометкуУдаления;
	ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню 	= СтруктураПараметров.ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню;
	ИмяГруппыСоздать 									= СтруктураПараметров.ИмяГруппыСоздать;
	ИмяГруппыСоздатьКонтекст							= СтруктураПараметров.ИмяГруппыСоздатьКонтекст;
	ПрефиксЭлементов									= СтруктураПараметров.ПрефиксЭлементов;
	
	ПравоДоступаДобавление 			= Ложь;
	ПравоДоступаИзменение 			= Ложь;
	
	ОтобранныеСтроки = Форма[ИмяТаблицыХозяйственныхОперацийИДокументов].НайтиСтроки(Новый Структура("Отбор", Истина));
	
	Для Каждого Строка Из ОтобранныеСтроки Цикл
		
		Если ПравоДоступаДобавление
			И ПравоДоступаИзменение Тогда 
			Прервать;
		КонецЕсли;
		
		ПравоДоступаДобавление 			= ?(Строка.ПравоДоступаДобавление, Истина, ПравоДоступаДобавление);
		ПравоДоступаИзменение 							= ?(Строка.ПравоДоступаИзменение, Истина, ПравоДоступаИзменение);
		
	КонецЦикла;
	
	Форма.Элементы[ИмяКнопкиСкопировать].Видимость 									= ПравоДоступаДобавление;
	Форма.Элементы[ИмяКнопкиСкопироватьКонтекстноеМеню].Видимость 					= ПравоДоступаДобавление;
	Форма.Элементы[ИмяКнопкиИзменить].Видимость 									= ПравоДоступаИзменение;
	Форма.Элементы[ИмяКнопкиИзменитьКонтекстноеМеню].Видимость 						= ПравоДоступаИзменение;
	Форма.Элементы[ИмяКнопкиПровести].Видимость 									= ПравоДоступаИзменение;
	Форма.Элементы[ИмяКнопкиПровестиКонтекстноеМеню].Видимость 						= ПравоДоступаИзменение;
	Форма.Элементы[ИмяКнопкиОтменаПроведения].Видимость 							= ПравоДоступаИзменение;
	Форма.Элементы[ИмяКнопкиОтменаПроведенияКонтекстноеМеню].Видимость 				= ПравоДоступаИзменение;
	Форма.Элементы[ИмяКнопкиУстановитьПометкуУдаления].Видимость 					= ПравоДоступаИзменение;
	Форма.Элементы[ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню].Видимость 	= ПравоДоступаИзменение;
	Форма.Элементы[ИмяГруппыСоздать].Видимость 										= ПравоДоступаДобавление;
	Форма.Элементы[ИмяГруппыСоздатьКонтекст].Видимость 								= ПравоДоступаДобавление;
	
	Если Форма.Элементы[ИмяГруппыСоздать].Видимость Тогда
		СформироватьКомандыСоздания(Форма, ИмяТаблицыХозяйственныхОперацийИДокументов, ИмяГруппыСоздать, ИмяГруппыСоздатьКонтекст, ПрефиксЭлементов);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает параметры рабочего места в зависимости от установленных отборов по операциям и типам документов
//
// Параметры:
//  ТаблицаХозОперацииИТипыДокументов	 - ТаблицаЗначений - таблица с описанием метаданных, используемых в рабочем месте
//  КлючНазначенияФормыПоУмолчанию	 - Строка - параметр, определяющий раздел рабочего места, например, "ВнутреннееТовародвижение"
//  ЗаголовокФормыПоУмолчанию		 - Строка - заголовок рабочего места по умолчанию, например, "Внутреннее товародвижение"
// 
// Возвращаемое значение:
//  Структура - с полями:
//		*КлючНазначенияИспользования,
//		*ЗаголовокРабочегоМеста
//
Функция ДанныеРабочегоМеста(ТаблицаХозОперацииИТипыДокументов, КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию) Экспорт
	
	ОтобранныеХозОперацииИТипыДокументов = ТаблицаХозОперацииИТипыДокументов.Скопировать(Новый Структура("Отбор",Истина),
		"КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	ОтобранныеХозОперацииИТипыДокументов.Свернуть("КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	
	ДанныеРабочегоМеста = Новый Структура("КлючНазначенияИспользования,ЗаголовокРабочегоМеста",
		КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию);
		
	Если ОтобранныеХозОперацииИТипыДокументов.Количество() = 1 Тогда
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования) Тогда
			ДанныеРабочегоМеста.КлючНазначенияИспользования = ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования;	
		КонецЕсли;
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста) Тогда
			ДанныеРабочегоМеста.ЗаголовокРабочегоМеста = ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста;	
		КонецЕсли;			
	КонецЕсли;
	
	Возврат ДанныеРабочегоМеста;
	
КонецФункции

Функция СформироватьГиперссылкуКОформлению(ХозяйственныеОперацииИДокументы, ПараметрыФормирования, Заголовок = "") Экспорт
	
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(?(ПустаяСтрока(Заголовок), НСтр("ru = 'К оформлению:'"), Заголовок) + " ");
	
	СтруктураОтбора = Новый Структура("Отбор", Истина);
	МенеджерыРасчетаГиперссылок = ХозяйственныеОперацииИДокументы.Скопировать(СтруктураОтбора, "МенеджерРасчетаГиперссылкиКОформлению");
	
	МенеджерыРасчетаГиперссылок.Свернуть("МенеджерРасчетаГиперссылкиКОформлению");
	МенеджерыРасчетаГиперссылок = МенеджерыРасчетаГиперссылок.ВыгрузитьКолонку("МенеджерРасчетаГиперссылкиКОформлению");
	
	Для Каждого МенеджерРасчетаГиперссылок Из МенеджерыРасчетаГиперссылок Цикл
		Если МенеджерРасчетаГиперссылок = "" Тогда
			Продолжить;
		КонецЕсли;
		
		ПараметрыФормирования.Вставить("ХозяйственныеОперацииИДокументы",ХозяйственныеОперацииИДокументы);
		Гиперссылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МенеджерРасчетаГиперссылок).СформироватьГиперссылкуКОформлению(ПараметрыФормирования);
		
		Если ЗначениеЗаполнено(Гиперссылка) Тогда
			Если МассивСтрок.Количество()>1 Тогда
				МассивСтрок.Добавить("; ");
			КонецЕсли;
			МассивСтрок.Добавить(Гиперссылка);
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Возврат Неопределено
	Иначе
		Возврат Новый ФорматированнаяСтрока(МассивСтрок)
	КонецЕсли;
	
КонецФункции

Функция СформироватьГиперссылкуСмТакжеВРаботе(МассивМенеджеровРасчетаСмТакжеВРаботе, ПараметрыФормирования, Заголовок = "") Экспорт
	
	ЗаглавнаяСтрока = ?(ПустаяСтрока(Заголовок),
		НСтр("ru = 'См. также (в работе):'"),
		Заголовок) + " ";
	
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(ЗаглавнаяСтрока);
		
	Для Каждого МенеджерРасчетаСмТакжеВРаботе Из МассивМенеджеровРасчетаСмТакжеВРаботе Цикл
		Если МенеджерРасчетаСмТакжеВРаботе = "" Тогда
			Продолжить;
		КонецЕсли;
		
		Гиперссылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МенеджерРасчетаСмТакжеВРаботе).СформироватьГиперссылкуСмТакжеВРаботе(ПараметрыФормирования);
		
		Если ЗначениеЗаполнено(Гиперссылка) Тогда
			Если МассивСтрок.Количество()>1 Тогда
				МассивСтрок.Добавить("; ");
			КонецЕсли;
			МассивСтрок.Добавить(Гиперссылка);
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Возврат Неопределено
	Иначе
		Возврат Новый ФорматированнаяСтрока(МассивСтрок)
	КонецЕсли;
	
КонецФункции

// Функция - Данные по штрих коду печатной формы
//
// Параметры:
//  ХозяйственныеОперацииИДокументы	 - 	ТаблицаЗначений -  таблица с колонкой "ПолноеИмяДокумента"
// 
// Возвращаемое значение:
//  Неопределено, Структура
//
Функция ДанныеПоШтрихКодуПечатнойФормы(Штрихкод, ХозяйственныеОперацииИДокументы) Экспорт 
	
	ТаблицаОперацииНакладные = ОбщегоНазначенияУТ.ВыделенныеХозяйственныеОперацииИДокументы(ХозяйственныеОперацииИДокументы);
	
	ИменаДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ПолноеИмяДокумента");
	
	МассивПустыхСсылок = Новый Массив();
	
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		ПустаяСсылка = ПредопределенноеЗначение(ИмяДокумента+".ПустаяСсылка");
		МассивПустыхСсылок.Добавить(ПустаяСсылка);
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивПустыхСсылок);
	
	Ссылки = ШтрихкодированиеПечатныхФорм.ПолучитьСсылкуПоШтрихкодуТабличногоДокумента(Штрихкод, МассивПустыхСсылок);
	
	ДанныеПоШтрихКоду = Неопределено;
	Если Ссылки.Количество() > 0 Тогда
		
		ДанныеПоШтрихКоду = Новый Структура("Ссылка,КлючЗаписи");
		ДанныеПоШтрихКоду.Ссылка = Ссылки[0];
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	РеестрДокументов.ТипСсылки,
		|	РеестрДокументов.Организация,
		|	РеестрДокументов.ХозяйственнаяОперация,
		|	РеестрДокументов.Партнер,
		|	РеестрДокументов.Контрагент,
		|	РеестрДокументов.НаправлениеДеятельности,
		|	РеестрДокументов.ДополнительнаяЗапись,
		|	РеестрДокументов.Подразделение,
		|	РеестрДокументов.МестоХранения,
		|	РеестрДокументов.ДатаДокументаИБ,
		|	РеестрДокументов.Ссылка
		|ИЗ
		|	РегистрСведений.РеестрДокументов КАК РеестрДокументов
		|ГДЕ
		|	РеестрДокументов.Ссылка = &Ссылка";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Ссылка", Ссылки[0]);
		
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			НайденнаяСтрока = Результат.Выгрузить()[0];
			СтруктураКлючевыхПолей = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(НайденнаяСтрока);
			ДанныеПоШтрихКоду.КлючЗаписи = РегистрыСведений.РеестрДокументов.СоздатьКлючЗаписи(СтруктураКлючевыхПолей);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДанныеПоШтрихКоду;
	
КонецФункции

Функция ПредставлениеОбъекта(ПараметрОбъект) Экспорт
	
	Если ПараметрОбъект = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	МетаданныеОбъекта = ?(ТипЗнч(ПараметрОбъект) = Тип("Строка"), Метаданные.НайтиПоПолномуИмени(ПараметрОбъект), ПараметрОбъект);
	
	Представление = Новый Структура("ПредставлениеОбъекта");
	ЗаполнитьЗначенияСвойств(Представление, МетаданныеОбъекта);
	Если Не ПустаяСтрока(Представление.ПредставлениеОбъекта) Тогда
		Возврат Представление.ПредставлениеОбъекта;
	КонецЕсли;
	
	Возврат МетаданныеОбъекта.Представление();
	
КонецФункции


// Возвращает массив хозяйственных операций переданных типов документов,
// которые отражаются в реесте документов и не отключены по ФО
//
// Параметры:
//  ТипыДокументов	 - Массив - массив типов
// 
// Возвращаемое значение:
//  Массив - Хозяйственные операции (ПеречислениеСсылка.ХозяйственныеОперации)
//
Функция ХозяйственныеОперацииДокументовОтраженныеВРееестре(ТипыДокументов) Экспорт
	
	МассивИдентификаторов = Новый Массив;
	МассивХозяйственныхОпераций = Новый Массив;
	
	Для Каждого СтрМас из ТипыДокументов Цикл
		Если ОбщегоНазначения.ЭтоСсылка(СтрМас) Тогда
			ОбъектМетаданных = Метаданные.НайтиПоТипу(СтрМас);
			Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				МассивИдентификаторов.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЕСТЬNULL(НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции, """") КАК ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|		ПО НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка = НастройкиХозяйственныхОперацийДокументы.Ссылка
	|ГДЕ
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных В(&МассивИдентификаторов)
	|	И НастройкиХозяйственныхОперацийДокументы.Ссылка.ИспользоватьВРеестреДокументов
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация";
	
	Запрос.УстановитьПараметр("МассивИдентификаторов", МассивИдентификаторов);
	
	ТекущаяХозяйственнаяОперация = Неопределено;
	ХозОперацияДобавлена = Ложь;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущаяХозяйственнаяОперация <> Выборка.ХозяйственнаяОперация Тогда 
			ХозОперацияДобавлена = Ложь;
			ТекущаяХозяйственнаяОперация = Выборка.ХозяйственнаяОперация; 
		КонецЕсли;
		
		Если Не ХозОперацияДобавлена  
			И (ПустаяСтрока(Выборка.ИмяФункциональнойОпции)
			Или ПолучитьФункциональнуюОпцию(Выборка.ИмяФункциональнойОпции)) Тогда
			
			ХозОперацияДобавлена = Истина;
			МассивХозяйственныхОпераций.Добавить(Выборка.ХозяйственнаяОперация);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МассивХозяйственныхОпераций; 
	
КонецФункции

#КонецОбласти

#Область ДобавлениеУдалениеКнопокСозданияВЖурналахДокументов

Процедура СформироватьКомандыСоздания(Форма, ИмяТаблицыСХозяйственнымиОперациямиИДокументами, ИмяГруппыСоздать, ИмяГруппыСоздатьКонтекст, ПрефиксЭлементов) 
	
	СтруктураИменГрупп = Новый Структура;
	СтруктураИменГрупп.Вставить(ИмяГруппыСоздать, Ложь); // Ложь, т.к. группа не контекстная
	СтруктураИменГрупп.Вставить(ИмяГруппыСоздатьКонтекст, Истина); // Истина, т.к. контекстная группа
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок,
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|ГДЕ
	|	Таблица.Отбор
	|	И Таблица.ДобавитьКнопкуСоздать
	|	И Таблица.ПравоДоступаДобавление
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.Порядок 								КАК Порядок,
	|	Таблица.ИдентификаторОбъектаМетаданных 			КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация 					КАК ХозяйственнаяОперация,
	|	ПРЕДСТАВЛЕНИЕ(Таблица.ХозяйственнаяОперация) 	КАК ХозОперацияСиноним,
	|	Таблица.ГруппаКнопок 							КАК ГруппаКнопок
	|ИЗ
	|	Таблица КАК Таблица";
	
	ТаблицаХозОперацийИДокументов = Форма[ИмяТаблицыСХозяйственнымиОперациямиИДокументами].Выгрузить();
	
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("Порядок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("Порядок",
			Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0)));
	КонецЕсли;
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("ГруппаКнопок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("ГруппаКнопок",
			Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	КонецЕсли;
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаХозОперацийИДокументов);
	
	ТаблицаДокументов = Запрос.Выполнить().Выгрузить();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ХозОперацияСиноним КАК СТРОКА(500)) КАК ХозОперацияСиноним,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок,
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоДокументов.ИдентификаторОбъектаМетаданных) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоДокументов
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоХозяйственныхОпераций.ХозяйственнаяОперация) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоХозяйственныхОпераций
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	Таблица.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК Имя,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	Таблица.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК Имя,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|
	|ИТОГИ ПО
	|	ИдентификаторОбъектаМетаданных";
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаДокументов);
	МассивРезультатов = Запрос.ВыполнитьПакет();
	
	КоличествоДокументов = 0;
	ВыборкаКоличествоДокументов = МассивРезультатов[1].Выбрать();
	Если ВыборкаКоличествоДокументов.Следующий() Тогда 
		КоличествоДокументов = ВыборкаКоличествоДокументов.Количество;
	КонецЕсли;
	
	КоличествоХозОпераций = 0;
	ВыборкаКоличествоХозОпераций = МассивРезультатов[2].Выбрать();
	Если ВыборкаКоличествоХозОпераций.Следующий() Тогда 
		КоличествоХозОпераций = ВыборкаКоличествоХозОпераций.Количество;
	КонецЕсли;
	
	Для Каждого ИмяКонтекстГруппы Из СтруктураИменГрупп Цикл
		
		ИмяГруппыСоздать 			= ИмяКонтекстГруппы.Ключ;
		ДобавлениеВКонтекстноеМеню 	= ИмяКонтекстГруппы.Значение;
		
		Префикс = ПрефиксЭлементов + ?(ДобавлениеВКонтекстноеМеню, "Контекст", "");
		
		ГруппаСоздать = Форма.Элементы[ИмяГруппыСоздать];
	
		УдалитьКомандыСоздания(Форма, ГруппаСоздать, ИмяГруппыСоздать);
		
		СоответствиеГруппКоманды = Новый Соответствие;
		СоответствиеГруппКоманды.Вставить("", ГруппаСоздать);
		
		Если КоличествоДокументов = 1 И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Если Выборка.Следующий() Тогда   
				МестоРазмещенияКнопки = МестоРазмещенияКнопки("", Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, НСтр("ru = 'Создать'"), Выборка, Префикс, ГруппаСоздать.ПодчиненныеЭлементы.Количество() = 0);
			КонецЕсли;
					
		ИначеЕсли КоличествоДокументов = 1 И КоличествоХозОпераций > 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.ХозяйственнаяОперация, Выборка, Префикс);			
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= 7 И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.Синоним, Выборка, Префикс);
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= 7 И КоличествоХозОпераций > 1 Тогда
			
			Дерево = МассивРезультатов[4].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
			
			Для Каждого СтрокаДокумент Из Дерево.Строки Цикл
				
				Если СтрокаДокумент.Строки.Количество() = 1 Тогда
					ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, ГруппаСоздать, СтрокаДокумент.Синоним, СтрокаДокумент.Строки[0], Префикс);
				Иначе			
					ГруппаКнопок = ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, СтрокаДокумент.Имя, СтрокаДокумент.Синоним, Префикс);
					Для Каждого Строка Из СтрокаДокумент.Строки Цикл
						ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, ГруппаКнопок, Строка.ХозяйственнаяОперация, Строка, Префикс);
					КонецЦикла;
				КонецЕсли;
				
			КонецЦикла;
			
		ИначеЕсли Форма.ОтборТипыДокументов.Количество() > 7 Тогда
			
			ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс); 
					
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяНовойГруппы, ЗаголовокНовойГруппы, Префикс)
	
	Элемент = Форма.Элементы.Добавить(Префикс + "ГруппаСоздать_" + СокрЛП(ИмяНовойГруппы), Тип("ГруппаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.Заголовок = ЗаголовокНовойГруппы;
	Возврат Элемент;
КонецФункции

Функция ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, Родитель, ЗаголовокКнопки, ТекущаяСтрокаТаблицы, Префикс, ОднаКнопка = Ложь)
	
	МетаданныеХозяйственнойОперации = ТекущаяСтрокаТаблицы.ХозяйственнаяОперация.Метаданные();
	МетаданныеДокумента = Метаданные.НайтиПоПолномуИмени(ТекущаяСтрокаТаблицы.ПолноеИмяДокумента);
	
	ИмяЗначенияПеречисления = XMLСтрока(ТекущаяСтрокаТаблицы.ХозяйственнаяОперация);
	ИмяМетаданныхДокумента = МетаданныеДокумента.Имя;
	
	Если ОднаКнопка Тогда 
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	Иначе
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.Подменю;
		Форма.Элементы[ИмяГруппыСоздать].Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;		
	КонецЕсли;
	
	ИмяКоманды = Префикс + "Создать_" + ИмяЗначенияПеречисления + "_" + ИмяМетаданныхДокумента;
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокумент";
	Команда.Заголовок = ЗаголовокКнопки;
	Если ОднаКнопка Тогда 
		Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
		Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	КонецЕсли;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Родитель);
	Элемент.ИмяКоманды = ИмяКоманды;

КонецФункции

Функция ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс)
	 
	Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	
	ИмяКоманды = Префикс + "Создать_ДокументЧерезФормуВыбора";
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокументЧерезФормуВыбора";
	Команда.Заголовок = НСтр("ru = 'Создать...'");	
	Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
	Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.ИмяКоманды = ИмяКоманды;

КонецФункции

Процедура УдалитьКомандыСоздания(Форма, Родитель, ИмяГруппыСоздать)
	
	// Если родитель - не корневая группа и он не создан программно, то удалять ничего не нужно 
	Если Родитель <> Форма.Элементы[ИмяГруппыСоздать] 
		И СтрНайти(Родитель.Имя, "Создать_") = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Родитель) = Тип("ГруппаФормы") Тогда 
		
		Количество = Родитель.ПодчиненныеЭлементы.Количество();
		
		Для Индекс = 1 По Количество Цикл
			УдалитьКомандыСоздания(Форма, Родитель.ПодчиненныеЭлементы.Получить(0), ИмяГруппыСоздать);
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Родитель) = Тип("КнопкаФормы") Тогда 
		Форма.Команды.Удалить(Форма.Команды.Найти(Родитель.Имя));		
	КонецЕсли;
	
	Если СтрНайти(Родитель.Имя, "Создать_") <> 0 Тогда 
		Форма.Элементы.Удалить(Родитель);
	КонецЕсли;
	
КонецПроцедуры

Функция МестоРазмещенияКнопки(ИмяГруппыКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды)

	ГруппаКнопок = СоответствиеГруппКоманды.Получить(СокрЛП(ИмяГруппыКнопок));
	Если ГруппаКнопок = Неопределено Тогда
		ГруппаКнопок = ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяГруппыКнопок, ИмяГруппыСоздать, Префикс);	
		ГруппаКнопок.Вид = ВидГруппыФормы.ГруппаКнопок;
		СоответствиеГруппКоманды.Вставить(СокрЛП(ИмяГруппыКнопок), ГруппаКнопок);
	КонецЕсли; 

	Возврат ГруппаКнопок;
	
КонецФункции

#КонецОбласти

#КонецОбласти
