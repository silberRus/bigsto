
// ОБЩИЕ

Функция ПолучитьКлючИзЗначения(СтруктураИлиСоответствие, Значение) Экспорт
	
	// Возвращает ключ по переданному значению
	
	Для Каждого Элемент ИЗ СтруктураИлиСоответствие Цикл Если Элемент.Значение = Значение Тогда Возврат Элемент.Ключ КонецЕсли; КонецЦикла;
	
КонецФункции

Функция ПолучитьПустуюСтруктуруИзПолейТабличнойЧасти(МетаТаблица, ЗаполнятьЗначенияРеквизитом = Неопределено) Экспорт
	
	СтруктураКолонок = Новый Структура;
	
	Для КАждого Реквизит Из МетаТаблица.Реквизиты Цикл
		
		СтруктураКолонок.Вставить(Реквизит.Имя, ?(ЗаполнятьЗначенияРеквизитом = Неопределено, Реквизит.Имя, ЗаполнятьЗначенияРеквизитом));
		
	КонецЦикла;
	
	Возврат СтруктураКолонок;
	
КонецФункции
Функция ПолучитьПустуюСтруктуруИзКолонокТаблицыЗначений(Колонки, ЗаполнятьЗначенияРеквизитом = Неопределено) Экспорт
	
	СтруктураКолонок = Новый Структура;
	
	Для КАждого Колонка Из Колонки Цикл СтруктураКолонок.Вставить(Колонка.Имя, ?(ЗаполнятьЗначенияРеквизитом = Неопределено, Колонка.Имя, ЗаполнятьЗначенияРеквизитом)); КонецЦикла;
	
	Возврат СтруктураКолонок;
	
КонецФункции
Функция ПолучитьПустуюСтруктуруИзСтруктуры(Структура) Экспорт
	
	ИмяСтр = "";
	
	Для Каждого Элемент Из Структура Цикл ИмяСтр = ИмяСтр + ?(ИмяСтр = "","",",") + Элемент.Ключ КонецЦикла;
	
	Возврат Новый Структура(ИмяСтр);
	
КонецФункции

Функция ПолучитьСтруктуруИзСТрокиТаблицыЗначений(ТаблицаЗначений, ИндексСтроки = 0, ИсключитьКолонки = "") Экспорт
	
	// Возвращает структуру в ключе имена колонко, в значении значения строки,
	// строка берется на переданный индекс
	//
	// Если пустая таблица то вернет структуру но с пустыми значениям
	// Если значение будет таблица тогда вернет как массив внунтри которого будут структуры значений (колонок)
	
	СтруктураВозврата 	= Новый Структура;
	
	// Определяем строку
	
	Если ТаблицаЗначений.Количество() Тогда Строка = ТаблицаЗначений[ИндексСтроки];
	Иначе	ВремТаблица = ТаблицаЗначений.Скопировать();
			Строка = ВремТаблица.Добавить(); КонецЕсли;
	
	// Копируем значения из строки
	
	ТипТаблица = Тип("ТаблицаЗначений");
	Для КАждого Колонка Из ТаблицаЗначений.Колонки Цикл 
		Если Не СтрНайти(ИсключитьКолонки, Колонка.Имя) Тогда
		
			Значение = Строка[Колонка.Имя];
			Если ТипЗнч(Значение) = ТипТаблица Тогда
				
				МассивСтрок = Новый Массив;
				ВИнд 	= Значение.Количество() - 1;
				Для Инд = 0 По ВИнд Цикл МассивСтрок.Добавить(ПолучитьСтруктуруИзСТрокиТаблицыЗначений(Значение, Инд)) КонецЦикла;
				СтруктураВозврата.Вставить(Колонка.Имя, МассивСтрок);
				
			Иначе
				СтруктураВозврата.Вставить(Колонка.Имя, Значение); КонецЕсли; КонецЕсли; КонецЦикла;
	
	Возврат СтруктураВозврата;
	
КонецФункции
Функция ПолучитьСтруктуруИзСТрокиДереваЗначений(ДеревоЗначений, ИндексСтроки = 0) Экспорт
	
	// Возвращает структуру в ключе имена колонко, в значении значения строки,
	// строка берется на переданный индекс
	//
	// Если пустая таблица то вернет структуру но с пустыми значениям
	
	СтруктураВозврата 	= Новый Структура;
	
	// Определяем строку
	
	Если ДеревоЗначений.Строки.Количество() Тогда
		
		Строка = ДеревоЗначений.Строки[ИндексСтроки];
		
	Иначе
		
		ВремДерево = ДеревоЗначений.Скопировать();
		Строка = ВремДерево.Строки.Добавить();
		
	КонецЕсли;
	
	// Копируем значения из строки
	
	Для КАждого Колонка Из ДеревоЗначений.Колонки Цикл СтруктураВозврата.Вставить(Колонка.Имя, Строка[Колонка.Имя]); КонецЦикла;
	
	Возврат СтруктураВозврата;
	
КонецФункции
Функция ПолучитьСтруктуруИзСТрокиТаблицы(МетаТаблица, Строка = Неопределено) Экспорт
	
	// Возвращает структуру в ключе имена колонко, в значении значения строки,
	// строка берется на переданный индекс
	
	СтруктураВозврата = Новый Структура;
	
	Для КАждого Колонка Из МетаТаблица.Реквизиты Цикл СтруктураВозврата.Вставить(Колонка.Имя, ?(Строка = Неопределено, Неопределено, Строка[Колонка.Имя])) КонецЦикла;
	Возврат СтруктураВозврата;
	
КонецФункции

Функция ПолучитьСписокСУстановленнымиОтметками(Список, МассивЗначений) Экспорт
	
	// Возвращает список с отмеченными элементами
	// Создается новый список и заполняет его МассивЗначений
	// дальше выставляется галки тем элементам которые есть в списке и массиве или только в массиве
	
	новСписок = Новый СписокЗначений;
	Для Каждого Значение Из МассивЗначений Цикл новСписок.Добавить(Значение,,Список.НайтиПоЗначению(Значение) <> Неопределено) КонецЦикла;
	
	Возврат новСписок;
	
КонецФункции
Функция ПолучитьОтмеченныеПредставленияСписка(СписокЗначений) Экспорт
	
	// Возвращает массив элементами которого являются отмеченные представления 
	// переданного списка значений
	
	Представления = Новый Массив;
	
	Для Каждого Элемент Из СписокЗначений Цикл
		Если Элемент.Пометка Тогда
			
			Представления.Добавить(Элемент.Представление);
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат Представления;
	
КонецФункции
Функция ПолучитьОтмеченныеЗначенияСписка(СписокЗначений) Экспорт
	
	// Возвращает массив элементами которого являются отмеченные значения 
	// переданного списка значений
	
	Значения = Новый Массив;
	
	Для Каждого Элемент Из СписокЗначений Цикл Если Элемент.Пометка Тогда Значения.Добавить(Элемент.Значение); КонецЕсли; КонецЦикла;
	
	Возврат Значения;
	
КонецФункции
Функция ПолучитьОтмеченныеЗначенияСпискаСписком(СписокЗначений) Экспорт
	
	// Возвращает список значений элементами которого являются отмеченные значения 
	// переданного списка значений
	
	НовСписок = Новый СписокЗначений;
	Для Каждого Элемент Из СписокЗначений Цикл Если Элемент.Пометка Тогда НовСписок.Добавить(Элемент.Значение, Элемент.Представление, Элемент.Пометка, Элемент.Картинка); КонецЕсли; КонецЦикла;
	
	Возврат НовСписок;
	
КонецФункции

Функция ПолучитьЭлементСпискаПоПредставлению(СписокЗначений, Представление) Экспорт
	
	// Возвращает элемент списка значения,
	// ищет элемент по представлению
	
	Для Каждого Элемент Из СписокЗначений Цикл
		
		Если Элемент.Представление = Представление Тогда
			
			Возврат Элемент;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецФункции

Функция ПолучитьСтрокуИзТаблицыЗначений(ТаблицаЗначений, имяКолонки = Неопределено, Разделитель = ", ") Экспорт 
	стр = "";
	Если ТаблицаЗначений.Количество() = 0 Тогда
		Возврат стр;
	КонецЕсли;
	Если имяКолонки = Неопределено Тогда
		имяКолонки = ТаблицаЗначений.Колонки[0].Имя;
	КонецЕсли;
	Для каждого лСтрока Из ТаблицаЗначений Цикл
		стр = стр + лСтрока[имяКолонки] + Разделитель;
	КонецЦикла;
	
	Возврат Лев(стр, СтрДлина(стр) - СтрДлина(Разделитель));
КонецФункции
Функция ПолучитьСтрокуИзМассива(Массив, Разделитель = ",") Экспорт
	
	// Возвращает строку разделенную разделителями
	// элементы массивы должны бысть строками
	
	строка = "";
	
	Для Каждого Элмассива ИЗ Массив Цикл строка = строка + ?(строка = "","",",") + Элмассива КонецЦикла;
	
	Возврат Строка;
	
КонецФункции
Функция ПолучитьСтрокуИзОтмеченныхЗначенийСпискаЗначений(Список) Экспорт
	
	стр = "";
	Для Каждого Элемент Из Список Цикл Если Элемент.Пометка Тогда Стр = Стр + ?(Стр = "","",",") + Элемент.Значение КонецЕсли; КонецЦикла;
	
	Возврат Стр;
	
КонецФункции
Функция ПолучитьСтрокуИзКолонокТаблицыЗначений(ТаблицаЗначений, ИсключитьКолонки = "", Разделитель = ", ") Экспорт
	
	КолонкиСтрока="";
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		
		Если СтрНайти(ИсключитьКолонки, Колонка.Имя) Тогда Продолжить; КонецЕсли;

		КолонкиСтрока = КолонкиСтрока + Колонка.Имя + Разделитель; КонецЦикла;
	
	
	Возврат Лев(КолонкиСтрока, СтрДлина(КолонкиСтрока) - СтрДлина(Разделитель));
		
	
КонецФункции
	
Функция ПолучитьСтрокуИзПредставленийСпискаЗначений(Список, Разделитель = "; ") Экспорт
	
	Массив = Новый Массив;
	Для Каждого Элемент Из Список Цикл Массив.Добавить(Элемент.Представление) КонецЦикла;
	Возврат СтрСоединить(Массив, Разделитель);
	
КонецФункции

Функция СократитьНомерДо8ми(Номер)Экспорт 
	
	НачНуля = Найти(Номер,"0");
	
	Если НачНуля = 0 Тогда
		
		Возврат Прав(Номер, 8);
		
	Иначе
		
		Отрезать = СтрДлина(Номер) - 8 + НачНуля;
		Возврат Сред(Номер, 1, НачНуля - 1) + Прав(Номер, Отрезать);
		
	КонецЕсли;
	
КонецФункции


Функция ПолучитьСоответствияИзСправочника(ИмяСправочника, ЗначениеПоУмолчанию = Ложь, Владелец = Неопределено, Родитель = Неопределено) Экспорт
	
	// Возвращает соответствия, где ключами являются ссылки на справочник
	
	Соответствие = Новый Соответствие;
	
	Запрос = Новый Запрос("ВЫБРАТЬ Ссылка ИЗ Справочник." + ИмяСправочника + " ГДЕ ИСТИНА " +
		?(Владелец = Неопределено,"","И Владелец = &Владелец") +
		?(Родитель = Неопределено,"","И Родитель = &Родитель")
						);
						
	Запрос.УстановитьПараметр("Владелец", Владелец);
	Запрос.УстановитьПараметр("Родитель", Родитель);
	
	Выборка = Запрос.Выполнить.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Соответствие.Вставить(Выборка.Ссылка, ЗначениеПоУмолчанию);
		
	КонецЦикла;
	
	Возврат Соответствие;
	
КонецФункции
Функция ПолучитьСоответствиеИзТаблицыЗначений(ТаблицаЗначений, ИмяПоляКлюча, ИмяПоляЗначения = Неопределено) Экспорт
	
	// Возвращает соответствие, котолрые загружены из ТЗ
	//	если не указать ИмяПоляЗначения то в значение будет вставлено ИСТИНА
	
	Соответствие = Новый Соответствие;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		
		Соответствие.Вставить(Строка[ИмяПоляКлюча],
								?(ИмяПоляЗначения = Неопределено, 
										ИСТИНА, 
										Строка[ИмяПоляЗначения]));
	КонецЦикла;
	
	Возврат Соответствие;
	
КонецФункции
Функция ПолучитьСоответствиеИзВыборки(Выборка, ИмяПоляКлюча, ИмяПоляЗначения = Неопределено) Экспорт
	
	// Возвращает соответствие, которые в выборки
	//	если не указать ИмяПоляЗначения то в значение будет вставлено ИСТИНА
	
	Соответствие = Новый Соответствие;
	Выборка.Сбросить();
	Пока Выборка.Следующий() Цикл Соответствие.Вставить(Выборка[ИмяПоляКлюча], ?(ИмяПоляЗначения = Неопределено, ИСТИНА, Выборка[ИмяПоляЗначения])); КонецЦикла;
	
	Возврат Соответствие;
	
КонецФункции

Функция ПолучитьКопиюСоответствия()
КонецФункции

Функция ПолучитьМассивИзКлючейСтруктуры(Структура) Экспорт
	
	// Возвращает массив внутри которого строковые ключи структуры
	
	Массив = Новый Массив;
	
	Для Каждого Элемент Из Структура Цикл Массив.Добавить(Элемент.Ключ) КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивИзСтроки(Строка, СимволРазделения = ",", СокрЛП = Истина, УдалятьВсеПробелы = Истина) Экспорт
	
	// Ура в 3.6 теперь делаем так
	
	// Уберем пробелы
	Если СокрЛП Тогда 
		Если УдалятьВсеПробелы Тогда
			Возврат СтрРазделить(СтрЗаменить(Строка, " ", ""), СимволРазделения, Ложь);
			
		Иначе
			Массив = СтрРазделить(Строка, СимволРазделения, Ложь);
			Инд = -1; 
			Для Каждого Элемент Из Массив Цикл Инд = Инд + 1; Массив[Инд] = Элемент; КонецЦикла;
			Возврат Массив; КонецЕсли; 
	Иначе
		Возврат СтрРазделить(Строка, СимволРазделения, Истина); КонецЕсли;
		
	// Конвертит строку в массив, имена должны быть разделены запятыми
	
	Массив = Новый Массив;
	
	стрСтрока 	= СтрЗаменить(Строка, Символы.ПС, "");
	стрСтрока 	= СтрЗаменить(стрСтрока, СимволРазделения, Символы.ПС);
	ЧислоСтрок 	= СтрЧислоСтрок(стрСтрока);
	
	Для Ном = 1 По ЧислоСтрок Цикл стр = СтрПолучитьСтроку(стрСтрока, Ном); Массив.Добавить(?(СокрЛП, СокрЛП(стр), стр)); КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивОтмеченныхЗначенийИзТаблица(Таблица, ИмяКолонкиЗначений, ЗначениеОтбираемогоУсловия = Истина, ИмяКолонкиУсловие = "Пометка") Экспорт
	
	// Возвращает массив в котором будут выбранные значения
	
	Массив = Новый Массив;
	Строки = Таблица.НайтиСтроки(Новый Структура(ИмяКолонкиУсловие, ЗначениеОтбираемогоУсловия));
	
	Для Каждого Строка Из Строки Цикл Массив.Добавить(Строка[ИмяКолонкиЗначений]) КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивИзПоляВыборки(Выборка, ИмяПоляВыборки) Экспорт
	
	// Конвертит строку в массив, имена должны быть разделены запятыми
	
	Массив = Новый Массив;
	
	Пока Выборка.Следующий() Цикл
		
		Массив.Добавить(Выборка[ИмяПоляВыборки]);
		
	КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивИзТаблицыЗначений_ст(ТаблицаЗначений) Экспорт
	
	// Возвращает массив элементами которого является структура 
	//	в ключе имена колонок, в значении значения данной строки
	
	Массив 	= Новый Массив;
	ПослИнд = ТаблицаЗначений.Количество() - 1;
	
	Для Инд = 0 По ПослИнд Цикл Массив.Добавить(ПолучитьСтруктуруИзСТрокиТаблицыЗначений(ТаблицаЗначений, Инд)) КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивИзТаблицыЗначений(ТаблицаЗначений, Отбор = Неопределено, ИсключитьКолонки = "") Экспорт
	
	// Возвращает массив элементами которого является структура 
	//	в ключе имена колонок, в значении значения данной строки
	
	Массив 	= Новый Массив;
	Табл	= ?(Отбор = Неопределено, ТаблицаЗначений, ТаблицаЗначений.НайтиСтроки(Отбор));
	
	Для Каждого Строка ИЗ Табл Цикл Массив.Добавить(ПолучитьСтруктуруИзСТрокиТаблицыЗначений(ТаблицаЗначений, ТаблицаЗначений.Индекс(Строка), ИсключитьКолонки)) КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивИзНайденныхЗначенийСтрокТаблицыЗначений(ТаблицаЗначений, Отбор, ИмяПоля) Экспорт
	
	// Возвращает массив элементами которого является значения строк попавших в отбор 
	
	Массив = Новый Массив;
	Строки = ТаблицаЗначений.НайтиСтроки(Отбор);
	
	Для Каждого Строка Из Строки Цикл Массив.Добавить(Строка[ИмяПоля]) КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьУникальныйМассивИзНайденныхЗначенийСтрокТаблицыЗначений(ТаблицаЗначений, Отбор, ИмяПоля) Экспорт
	
	// Возвращает массив элементами которого является значения строк попавших в отбор 
	// значения в возвращаемом массиве будут уникальны
	
	Массив = Новый Массив;
	Строки = ТаблицаЗначений.НайтиСтроки(Отбор);
	
	Для Каждого Строка Из Строки Цикл 
		Если Массив.Найти(Строка[ИмяПоля]) = Неопределено Тогда
			Массив.Добавить(Строка[ИмяПоля]);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивЗначенийперечислений(ИмяПеречисления, СтрокаЗначение) Экспорт
	
	// Возвращает массив со значениями перечислений
	//	ИмяПеречисления - имя перечисления как задано в метаданных
	//	СтрокаЗначение - через запятую перечислены значения перечислений которые нужно вернуть в массиве
	
	Массив 		= Новый Массив;
	Менеджер 	= Перечисления[ИмяПеречисления];
	Значения 	= ПолучитьМассивИзСтроки(СтрокаЗначение);
	
	Для Каждого Значение Из Значения Цикл
		Массив.Добавить(Менеджер[Значение]);
	КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ПолучитьМассивУникальныхЗначений(Таблица, ИмяКолонки, БезПустыхЗначений = Истина) Экспорт
	
	// Возвращает массив уникальных значений из таблицы
	// БезПустыхЗначений - если установить то пустые значения не будут добавляться в массив
	
	Массив = Новый Массив;
	Для Каждого Строка Из Таблица Цикл
		Значение = Строка[ИмяКолонки];
		Если НЕ (БезПустыхЗначений И НЕ ЗначениеЗаполнено(Значение)) И Массив.Найти(Значение) = Неопределено Тогда
			Массив.Добавить(Строка[ИмяКолонки]);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Массив;
	
КонецФункции

Функция ПеревернутьМассив(М) Экспорт
	
	Н = Новый Массив;
	Для Каждого Э Из М Цикл Н.Вставить(0, Э) КонецЦикла;
	Возврат Н;
	
КонецФункции

Функция ПолучитьМассивОбщихРеквизитовМетаОбъекта(МетаОбъект, ВернутьТолькоИмена = Ложь) Экспорт
	
	Массив = Новый Массив;
	
	Использовать 		= Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать;
	АвтоИспользовать 	= Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Авто;
	
	Для КАждого МетаОбщ Из Метаданные.ОбщиеРеквизиты Цикл
		
		Элемент = МетаОбщ.Состав.Найти(МетаОбъект);
		
		Если 	Элемент <> Неопределено И
				Элемент.Использование = Использовать Или
				(МетаОбщ.АвтоИспользование = Использовать И Элемент.Использование = АвтоИспользовать) Тогда
			
			Массив.Добавить(?(ВернутьТолькоИмена, МетаОбщ.Имя, МетаОбщ)); КонецЕсли; КонецЦикла;
	
	Возврат Массив;
	
КонецФункции
Функция ЕстьРеквизит(МетаОбъект, Имяреквизита, УчитыватьОбщие = Истина) Экспорт
	
	// Проверяет есть реквизит у метаобъекта или нет
	
	Если МетаОбъект.Реквизиты.Найти(ИмяРеквизита) <> Неопределено Тогда 
									Возврат Истина 
	ИначеЕсли УчитыватьОбщие Тогда	Возврат ПолучитьМассивОбщихРеквизитовМетаОбъекта(МетаОбъект, Истина).Найти(Имяреквизита) <> Неопределено;
	Иначе 							Возврат Ложь КонецЕсли;
	
КонецФункции

Процедура УдалитьЗначенияМассиваИзМассива(ОбрабатываемыйМассив, УдаляемыеЗначения)
	
	// Удаляет значения из ОбрабатываемыйМассив значения которые есть в УдаляемыеЗначения
	
	Кол = ОбрабатываемыйМассив.Количество();
	Для Ном = 1 По Кол Цикл Инд = Кол - Ном;
		
		Если УдаляемыеЗначения.Найти(ОбрабатываемыйМассив[Инд]) <> Неопределено Тогда
			ОбрабатываемыйМассив.Удалить(Инд) КонецЕсли; КонецЦикла;			
	
КонецПроцедуры
Процедура ДобавитьМассивВКонецМассива(МассивПриемник, МассивДобавления, Различные = Ложь) Экспорт
	
	// Добавляет в конец Массива приемника Массив добавления
	
	Для Каждого Значение Из МассивДобавления Цикл Если Различные И МассивПриемник.Найти(Значение) <> Неопределено Тогда Продолжить;КонецЕсли;
		
		МассивПриемник.Добавить(Значение);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьТаблицуКДругойТаблице(Таблица1, Таблица2, ВставитьВверх = Ложь) Экспорт
	
	Для Каждого Строка Из Таблица2 Цикл ЗаполнитьЗначенияСвойств(?(ВставитьВверх, Таблица1.Вставить(0), Таблица1.Добавить()), Строка); КонецЦикла;
	
КонецПроцедуры
Процедура ДобавитьТаблицуКТаблицеПроссумировавСтроки(Таблица1, Таблица2, КолонкиПоиска, СуммируемыеКолонки) Экспорт
	
	// Добавляет таблицу2 к Таблице1 по условию (КолонкиПоиска)
	// суммируеммые колонки при этом увеличивает на сумму Таблицы2
	// если не находяться строки в таблице1 по уусловию тогда добовляетсья новая строка
	//
	//	КолонкиПоиска 		- строка, в которой перечислены колонки по которым будут синхронизироваться строки
	//	СуммируемыеКолонки	- структура, в которой перечислены колонки которые нужно просуммировать
	//							в ключе имя колонки в таблице1
	//							в значении имя полонки в таблице2
	
	Колонки 	= ПолучитьМассивИзСтроки(КолонкиПоиска);
	КолонкиСумм = ПолучитьМассивИзСтроки(СуммируемыеКолонки);
	
	Для Каждого Строка Из Таблица2 Цикл
		
		// Поищем
		
		СтруктураПоиска = Новый Структура;
		Для Каждого Колонка Из Колонки Цикл СтруктураПоиска.Вставить(Колонка, Строка[Колонка]) КонецЦикла;
		
		// Найдем
		
		найдСтроки = Таблица1.НайтиСтроки(СтруктураПоиска);
		
		// Если не нашел тогда добавим новую
		
		Если Не найдСтроки.Количество() Тогда
			НовСтрока = Таблица1.Добавить(); 
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка); 
			Для Каждого Колонка Из КолонкиСумм Цикл НовСтрока[Колонка] = 0 КонецЦикла;
			найдСтроки.Добавить(НовСтрока); КонецЕсли;
		
		// Просуммируем
		
		Для Каждого НайдСтрока Из найдСтроки Цикл Для Каждого Колонка Из КолонкиСумм Цикл НайдСтрока[Колонка] = НайдСтрока[Колонка] + Строка[Колонка]; КонецЦикла; КонецЦикла; КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьСписокВКонецСписка(СписокПриемник, СписокИсточник, ТолькоОтмеченные = Ложь) Экспорт
	
	Для Каждого Элемент Из СписокИсточник Цикл Если Не ТолькоОтмеченные Или Элемент.Пометка Тогда СписокПриемник.Добавить(Элемент.Значение, Элемент.Представление, Элемент.Пометка, Элемент.Картинка) КонецЕсли; КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьДеревоКДругомуДереву(деревоПриемник, деревоИсточник) Экспорт
	
	Для Каждого Строка Из деревоИсточник.Строки Цикл
		
		новСтрока = деревоПриемник.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(новСтрока, Строка);
		
		// Ныряем
		
		ДобавитьДеревоКДругомуДереву(новСтрока, Строка);
		
	КонецЦикла;
	
КонецПроцедуры
Процедура ДобавитьКолонкиТаблицыКДругимКолонкам( // v 0001
										КолонкиРезультат, ДобавляемыеКолонки) Экспорт
										
	// Добавляет к первым колонкам вторые при этом проверяет чтобы они не совпали
	
	Для Каждого Колонка Из ДобавляемыеКолонки Цикл
		Если КолонкиРезультат.Найти(Колонка.Имя) = Неопределено Тогда
			
			КолонкиРезультат.Добавить(Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
			
		КонецЕсли;
	КонецЦикла;
	
	
КонецПроцедуры
Процедура ДобавитьВСтруктуруСтруктуру(СтруктураОсновная, СтруктураДобавляемая) Экспорт
	
	Для Каждого Элемент Из СтруктураДобавляемая Цикл СтруктураОсновная.Вставить(Элемент.Ключ, Элемент.Значение) КонецЦикла
	
КонецПроцедуры

Функция ПолучитьСтруктуруИзОбъекта(Объект, МетаОбъект = Неопределено) Экспорт
	
	Структура 	= Новый Структура("Ссылка", Объект.Ссылка);
	Если МетаОбъект = Неопределено Тогда МетаОбъект = Объект.метаданные() КонецЕсли;
	
	Если Метаданные.Справочники.Содержит(МетаОбъект) Тогда
		
		Структура.Вставить("Владелец", Объект.Владелец);
		
		Если МетаОбъект.Иерархический Тогда 		Структура.Вставить("ЭтоГруппа", 	Объект.ЭтоГруппа); КонецЕсли;
		Если МетаОбъект.ДлинаНаименования Тогда 	Структура.Вставить("Наименование", 	Объект.Наименование); КонецЕсли;
		Если МетаОбъект.ДлинаКода Тогда 			Структура.Вставить("Код", 			Объект.Код);КонецЕсли;
		
	ИначеЕсли Метаданные.Документы.Содержит(МетаОбъект) Тогда
		
		Структура.Вставить("Номер", 	Объект.Номер);
		Структура.Вставить("Дата", 		Объект.Дата);
		Структура.Вставить("Проведен", 	Объект.Проведен);
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаОбъект) Тогда
		
		Структура.Вставить("Номер", 	Объект.Номер);
		Структура.Вставить("Дата", 		Объект.Дата);
		Структура.Вставить("Завершен", 	Объект.Завершен);
		
	Иначе Возврат Структура; КонецЕсли;
	
	Структура.Вставить("ПометкаУдаления", Объект.ПометкаУдаления);
	
	// Добавим шапку
	
	Для каждого Реквизит Из МетаОбъект.Реквизиты Цикл Структура.Вставить(Реквизит.Имя, Объект[Реквизит.Имя]); КонецЦикла;
	
	// Добавим таблицы
	
	Для Каждого МетаТаблица Из МетаОбъект.ТабличныеЧасти Цикл
		
		Таблица 		= Объект[МетаТаблица.Имя];
		МассивТаблицы 	= Новый Массив;
		
		Для Каждого Строка Из Таблица Цикл
			
			СтруктураСтроки = Новый Структура;
			
			Для Каждого Колонка Из МетаТаблица.Реквизиты Цикл СтруктураСтроки.Вставить(Колонка.Имя, Строка[Колонка.Имя]);КонецЦикла;
			
			Если СтруктураСтроки.Количество() Тогда
				МассивТаблицы.Добавить(СтруктураСтроки); КонецЕсли; КонецЦикла;
		
		Структура.Вставить(МетаТаблица.Имя, МассивТаблицы); КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

Функция ПолучитьВыборкуИзДинамическогоСписка(ДинамическийСписок) Экспорт
	
	// Возвращает из динамического списка выборку запроса
	
	Запрос = Новый Запрос(ДинамическийСписок.ТекстЗапроса);
	
	Для Каждого Параметр Из ДинамическийСписок.Параметры.Элементы Цикл
		
		Запрос.УстановитьПараметр(Параметр.Параметр, Параметр.Значение);
		
	КонецЦикла;
	
	Возврат Запрос.Выполнить();
	
	
КонецФункции

Функция ПолучитьКоличествоСимволовЧислаСправа(Строка) Экспорт
	
	// Возвращает сколько цифр в слове справа
	
	КолСимволов = СтрДлина(Строка);
	Чисел 		= 0;
	
	Для Инд = 0 По КолСимволов - 1 Цикл
		
		Если Не Найти("01234567890",Сред(Строка, КолСимволов - Инд, 1)) Тогда
			Прервать;
		КонецЕсли;
		
		Чисел = Чисел + 1;
		
	КонецЦикла;
	
	Возврат Чисел;
	
КонецФункции

Функция ПолучитьТаблицуИзНайденныхСтрокТаблицы(Таблица, СтруктураПоиска) Экспорт
	
	Строки 		= Таблица.НайтиСтроки(СтруктураПоиска);
	НовТаблица 	= Таблица.ВыгрузитьКолонки();
	
	Для Каждого Строка Из Строки Цикл ЗаполнитьЗначенияСвойств(НовТаблица.Добавить(), Строка);КонецЦикла;
	
	Возврат НовТаблица;
	
КонецФункции
Функция ПолучитьТаблицуИзНайденныхСтрокТаблицыЗначений(Таблица, СтруктураПоиска, Колонки = Неопределено, ИсключитьКолонки = Неопределено) Экспорт
	
	Перем текКолонки;
	
	Если ИсключитьКолонки <> Неопределено Тогда
		
		Если Колонки = Неопределено Тогда
			ВсеКолонки = Новый Массив;
			Для Каждого Колонка Из Таблица.Колонки Цикл ВсеКолонки.Добавить(Колонка.Имя) КонецЦикла;
		Иначе
			ВсеКолонки = ПолучитьМассивИзСтроки(Колонки); КонецЕсли;
			
		УдалитьЗначенияМассиваИзМассива(ВсеКолонки, ПолучитьМассивИзСтроки(ИсключитьКолонки));
		текКолонки = СтрСоединить(ВсеКолонки, ",");
		
	ИначеЕсли Колонки <> Неопределено Тогда
		
		текКолонки = Колонки; КонецЕсли;
		
	Строки 		= Таблица.НайтиСтроки(СтруктураПоиска);
	НовТаблица 	= ?(текКолонки = Неопределено, Таблица.СкопироватьКолонки(), Таблица.СкопироватьКолонки(текКолонки));
	
	Для Каждого Строка Из Строки Цикл ЗаполнитьЗначенияСвойств(НовТаблица.Добавить(), Строка) КонецЦикла;
	
	Возврат НовТаблица;
	
КонецФункции
Функция ПолучитьТаблицуИзНеНайденныхСтрокТаблицыЗначений(Таблица, СтруктураПоиска) Экспорт
	
	// возвращает таблицу в которой строки не попадают под условие "Структуры поиска"
	
	
КонецФункции

Функция ПолучитьСсылку(Гуид, Менеджер, ИмяОбъекта, ТолькоОбъекты, ИсключитьОбъекты)
	
	Если НЕ (
				(ТолькоОбъекты <> Неопределено И ТолькоОбъекты.Найти(ИмяОбъекта) = Неопределено) ИЛИ
				(ИсключитьОбъекты <> Неопределено И ИсключитьОбъекты.Найти(ИмяОбъекта) <> Неопределено)) Тогда
					
			Ссылка = Менеджер[ИмяОбъекта].ПолучитьСсылку(Гуид);
			Если Ссылка.ПолучитьОбъект() <> Неопределено Тогда Возврат Ссылка КонецЕсли; КонецЕсли;
	
КонецФункции
Функция ПолучитьСсылкуПоГуиду(Гуид, ПеребираемыеОбъекты = Неопределено, ИсключаемыеОбъекты = Неопределено) Экспорт
	
	// Возвращает ссылку на объект по гуиду
	//
	// ПеребираемыеОбъекты - строка, через запятую передаются имена объектов (например: "Номенклатура, Контрагенты, ЗаказПокупателя")
	//									это объекты только которые нужно смотреть
	// ИсключаемыеОбъекты - строка, тоже что и ПеребираемыеОбъекты, только объекты которые нужно исключить из перебора
	
	Перем ТолькоОбъекты, ИсключитьОбъекты;
	
	Если ПеребираемыеОбъекты = Неопределено Тогда
			ЕстьТолько = Ложь;
	Иначе	ЕстьТолько = Истина;
			ТолькоОбъекты = ПолучитьМассивИзСтроки(ПеребираемыеОбъекты); КонецЕсли;
	
	Если ИсключаемыеОбъекты = Неопределено Тогда
			ЕстьКроме = Ложь;
	Иначе	ЕстьКроме = Истина;
			ИсключитьОбъекты = ПолучитьМассивИзСтроки(ИсключаемыеОбъекты); КонецЕсли;
		
	тГуид = ?(ТипЗнч(Гуид) = Тип("Строка"), Новый УникальныйИдентификатор(Гуид), Гуид);
		
	Ссылка = 	ВернутьСсылкуИзМетаКоллекции(тГуид, Метаданные.Справочники, Справочники, ЕстьТолько, ЕстьКроме, ТолькоОбъекты, ИсключитьОбъекты);
	Возврат ?(Ссылка = Неопределено, 
				ВернутьСсылкуИзМетаКоллекции(тГуид, Метаданные.Документы, Документы, ЕстьТолько, ЕстьКроме, ТолькоОбъекты, ИсключитьОбъекты), 
				Ссылка);
КонецФункции
Функция ВернутьСсылкуИзМетаКоллекции(Гуид, МетаданноеКоллекция, Менеджер, ЕстьТолько, ЕстьКроме, ТолькоОбъекты, ИсключитьОбъекты)
	
	Для Каждого МетаДанное Из МетаданноеКоллекция Цикл 
		Если 	(ЕстьТолько И ТолькоОбъекты.Найти(МетаДанное.Имя) = Неопределено) Или
				(ЕстьКроме И ИсключитьОбъекты.Найти(МетаДанное.Имя) <> Неопределено) Тогда Продолжить; КонецЕсли;
		Ссылка = ПолучитьСсылку(Гуид, Менеджер, МетаДанное.Имя, ТолькоОбъекты, ИсключитьОбъекты); 
	Если Ссылка <> Неопределено Тогда Возврат Ссылка КонецЕсли;КонецЦикла;
	
КонецФункции

Функция ЗаполнитьСтруктуру(обЗаполнения, обИсточник, ДопСтруктура = Неопределено) Экспорт
	
	ЗаполнитьЗначенияСвойств(обЗаполнения, обИсточник);
	Если ДопСтруктура <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(обЗаполнения, ДопСтруктура);
	КонецЕсли;
	
	Возврат обЗаполнения;
	
КонецФункции

// СКД

Процедура ЗаполнитьЭлементыОтбораКомпоновкиДанных(ЭлементыДобавляемые, ЭлементыПринимаемые) Экспорт
	
	// Добавляет в настройки отбора компановки данных строки из других настроек
	
	// ЭлементыДобавляемые - от сюда берутся элементы
	// ЭлементыПринимаемые - сюда добавляются элементы
	
	ТипГруппа = Тип("ГруппаЭлементовОтбораКомпоновкиДанных");
	Для Каждого Элемент Из ЭлементыДобавляемые Цикл
		
		ТипЭлемента = ТипЗнч(Элемент);
		НовЭлемент 	= ЭлементыПринимаемые.Добавить(ТипЭлемента);
		ЗаполнитьЗначенияСвойств(НовЭлемент, Элемент);
		
		Если ТипЭлемента = ТипГруппа Тогда
			ЗаполнитьЭлементыОтбораКомпоновкиДанных(Элемент.Элементы, НовЭлемент.Элементы); КонецЕсли; КонецЦикла;
	
КонецПроцедуры


// ПРЕОБРАЗОВАНИЯ В ТАБЛИЦАХ

Функция СоздатьТаблицуЗначенийИзМассива(Массив, ИмяКолонки, ОписаниеТипаКолонки = Неопределено) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить(ИмяКолонки, ОписаниеТипаКолонки);
	
	ЗагрузитьМассивТаблицу(Таблица, Массив, ИмяКолонки);
	
	Возврат Таблица;
	
КонецФункции

Функция ПолучитьСписокЗначенийИзВыборки(Выборка, ПолеЗначение = "Значение", ПолеПредставление = Неопределено, ПолеПометка = Неопределено, ПолеКартинка = Неопределено) Экспорт
	
	// Возвращает список значений который загружен из выборки запроса
	// ПолеЗначение	- (обязательно) имя поля откуда будет добавлятся значение
	// ПолеПредставление 	- (необязательно) имя поля откуда будет браться представление
	// ПолеПометка 			- (необязательно) имя поля откуда будет браться пометка
	// ПолеКартинка 	-  (необязательно) имя поля откуда будет браться картинка
	//						если указать тогда нужно чтобы в этом поле, был тип "хранилище значения" внутри которого картинка
	
	Список = Новый СписокЗначений;
	Выборка.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Представление 	= ?(ПолеПредставление 	= Неопределено, Выборка[ПолеЗначение], 	Выборка[ПолеПредставление]);
		Пометка 		= ?(ПолеПометка 		= Неопределено, Ложь, 					Выборка[ПолеПометка]);
		
		Картинка = Неопределено;
		Если ПолеКартинка <> Неопределено Тогда
			ДвДанные = Выборка[ПолеКартинка].Получить();
			Если ДвДанные <> Неопределено Тогда
				Картинка = Новый Картинка(ДвДанные); КонецЕсли; КонецЕсли;
		
		Список.Добавить(Выборка[ПолеЗначение], Представление, Пометка, Картинка); КонецЦикла;
	
	Возврат Список;
	
КонецФункции
Функция ПолучитьСписокЗначенийИзТаблицы(Таблица, ПолеЗначение = "Значение", ПолеПредставление = Неопределено, ПолеПометка = Неопределено, ПолеКартинка = Неопределено) Экспорт
	
	// Возвращает список значений который загружен из выборки запроса
	// ПолеЗначение	- (обязательно) имя поля откуда будет добавлятся значение
	// ПолеПредставление 	- (необязательно) имя поля откуда будет браться представление
	// ПолеПометка 			- (необязательно) имя поля откуда будет браться пометка
	// ПолеКартинка 		- (необязательно) имя поля откуда будет браться картинка
	//						если указать тогда нужно чтобы в этом поле, был тип "хранилище значения" внутри которого картинка
	
	Список = Новый СписокЗначений;
	
	Для Каждого Строка Из Таблица Цикл
		
		Представление 	= ?(ПолеПредставление 	= Неопределено, Строка[ПолеЗначение], 	Строка[ПолеПредставление]);
		Пометка 		= ?(ПолеПометка 		= Неопределено, Ложь, 					Строка[ПолеПометка]);
		
		Картинка = Неопределено;
		Если ПолеКартинка <> Неопределено Тогда
			ДвДанные = Строка[ПолеКартинка].Получить();
			Если ДвДанные <> Неопределено Тогда
				Картинка = Новый Картинка(ДвДанные); КонецЕсли; КонецЕсли;
		
		Список.Добавить(Строка[ПолеЗначение], Представление, Пометка, Картинка); КонецЦикла;
	
	Возврат Список;
	
КонецФункции
Процедура ЗагрузитьСписокЗначенийВТаблицу(Таблица, Список, ИмяКолонкиЗначения, ИмяКолонкиПредставления = "", ИмяКолонкиПометки = "", ИмяКолонкиКартинка = "", ТолькоОтмеченные = Ложь) Экспорт
	
	Для Каждого Элемент Из Список Цикл 
		Если Не ТолькоОтмеченные Или Элемент.Пометка Тогда
		
			НовСтрока = Таблица.Добавить(); 
			НовСтрока[ИмяКолонкиЗначения] = Элемент.Значение; 
			
			Если ИмяКолонкиПредставления <> "" Тогда 
				НовСтрока[ИмяКолонкиПредставления] = Элемент.Представление; КонецЕсли; 
			
			Если ИмяКолонкиПометки <> "" Тогда 
				НовСтрока[ИмяКолонкиПометки] = Элемент.Пометка; КонецЕсли; 
			
			Если ИмяКолонкиКартинка <> "" Тогда 
				НовСтрока[ИмяКолонкиКартинка] = Элемент.Картинка; КонецЕсли; КонецЕсли; КонецЦикла;
	
КонецПроцедуры
Процедура ЗагрузитьМассивТаблицу(Таблица, Массив, ИмяКолонкиЗначения) Экспорт
	
	Для Каждого Значение Из Массив Цикл НовСтрока = Таблица.Добавить(); НовСтрока[ИмяКолонкиЗначения] = Значение; КонецЦикла;
	
КонецПроцедуры
Процедура ЗагрузитьВыборкуВТаблицу(Выборка, Таблица) Экспорт
	
	Пока Выборка.Следующий() Цикл ЗаполнитьЗначенияСвойств(Таблица.Добавить(), Выборка); КонецЦикла;
	
КонецПроцедуры
Процедура ЗагрузитьДеревоВДанныеФормыДерево(Дерево, ДанныеФормы) Экспорт

	// Загружает в дерево выборку запроса
	
	Элементы = ДанныеФормы.ПолучитьЭлементы();
	
	Для Каждого Строка Из Дерево.Строки Цикл НовСтрока = Элементы.Добавить(); 
		
		ЗаполнитьЗначенияСвойств(НовСтрока, Строка); 
		ЗагрузитьДеревоВДанныеФормыДерево(Строка, НовСтрока); 
		
	КонецЦикла;
		
КонецПроцедуры

Процедура НижниеОдинаковыеСтрокиДереваЗаменить(Дерево, ПоляСравнений) Экспорт
	
	// Нижнюю строку с одинаковыми полями поднимает вверх заменяя ее
	//
	// Например было:				Станет:
	//	- знач 0 |						- знач 0 |	
	//		- знач 1 | 						- знач 1 | знач 2
	//			- знач 1 | знач 2
	
	Для Каждого Строка Из Дерево.Строки Цикл
		
		// Опустимся ниже в себя
		
		НижниеОдинаковыеСтрокиДереваЗаменить(Строка, ПоляСравнений);
		
		// Отберем одинаковые которые будем убирать
		
		Отбор = Новый Структура; Колонки = ПолучитьМассивИзСтроки(ПоляСравнений);
		Для Каждого Колонка Из Колонки Цикл Отбор.Вставить(Колонка, Строка[Колонка]) КонецЦикла;
		Одинаковые = Строка.Строки.НайтиСтроки(Отбор, Ложь);
		
		КолСвоих = Одинаковые.Количество();
		Для Ном = 1 По КолСвоих Цикл Одинаковый = Одинаковые[КолСвоих - Ном];
			
			// Заберем детей
			Для Каждого Деть Из Одинаковый.Строки Цикл ЗаполнитьЗначенияСвойств(Строка.Строки.Добавить(), Деть) КонецЦикла;
			
			// Копируем настройки нижнего
			ЗаполнитьЗначенияСвойств(Строка, Одинаковый);
			
			// Убираем
			Строка.Строки.Удалить(Одинаковый); КонецЦикла; КонецЦикла;
	
КонецПроцедуры
Процедура НижниеОдинаковыеСтрокиДереваЗаменить_Ст(Дерево, ПоляСравнений, ПервыйВход = Истина, ТеньДерева = Неопределено) Экспорт
	
	//// Нижнюю строку с одинаковыми полями поднимает вверх заменяя ее
	////
	//// Например было:				Станет:
	////	- знач 0 |						- знач 0 |	
	////		- знач 1 | 						- знач 1 | знач 2
	////			- знач 1 | знач 2
	//
	//// Дерево 					- дерево значений
	//// ПоляСравнений 			- перечисляются поля через запятую по которым будут определятся одинаковые строки
	//// ПервыйВход, ТеньДерева	- системное, нужно для рекурсии (внимание не обращать)
	//
	//Если ПервыйВход Тогда
	//	ТеньДерева = Дерево.Скопировать();
	//	ТеньДерева.Строки.Очистить(); КонецЕсли;
	//
	//Для Каждого Строка Из Дерево.Строки Цикл
	//	
	//	Если Строка.Строки.Количество()  Тогда
	//			//Не Строка.Строки[0].Строки.Количество() Тогда
	//		
	//		Колонки = ПолучитьМассивИзСтроки(ПоляСравнений);
	//		
	//		Отбор = Новый Структура;
	//		Для Каждого Колонка Из Колонки Цикл Отбор.Вставить(Колонка, Строка[Колонка]) КонецЦикла;
	//		Одинаковые = Строка.Строки.НайтиСтроки(Отбор, Ложь);
	//		
	//		// Одинаковые = Истина;
	//		//Для Каждого Колонка Из Колонки Цикл
	//		//	Если Строка[Колонка] <> Строка.Строки[0][Колонка] Тогда
	//		//		Одинаковые = Ложь; КонецЕсли; КонецЦикла;
	//		
	//		//Если Одинаковые Тогда 
	//		//Если Одинаковые.Количество() Тогда 
	//		Если Одинаковые.Количество() И Не Одинаковые[0].Строки.Количество() Тогда 
	//			//ЗаполнитьЗначенияСвойств(Строка, Строка.Строки[0]);
	//			ЗаполнитьЗначенияСвойств(Строка, Одинаковые[0]);
	//			//Строка.Строки.Удалить(0); КонецЕсли;
	//			Строка.Строки.Удалить(Одинаковые[0]); КонецЕсли;
	//		
	//		// проверим если родитель такой же то самоубъемся
	//		
	//		Если Строка.Родитель <> Неопределено Тогда
	//			
	//			ТекСтрокиРодителя = Строка.Родитель.Строки.НайтиСтроки(Отбор);
	//			Если ТекСтрокиРодителя.Количество() И ТекСтрокиРодителя[0] = Строка Тогда
	//				
	//				Если Строка.Строки.Количество() Тогда
	//					Для Каждого СтрокаПодч Из Строка.Строки Цикл ЗаполнитьЗначенияСвойств(Строка.Родитель.Строки.Добавить(), СтрокаПодч); КонецЦикла; КонецЕсли;
	//					
	//				Строка.Родитель.Строки.Удалить(Строка);
	//				Продолжить; КонецЕсли; КонецЕсли; 
	//		
	//		НижниеОдинаковыеСтрокиДереваЗаменить(Строка, ПоляСравнений); КонецЕсли; КонецЦикла;
	
КонецПроцедуры
Процедура СтрокиДереваОбработатьКрасиво(Дерево, ПоляСравнений, ПервыйВход = Истина, ТеньДерева = Неопределено) Экспорт
	
	// Нижнюю строку с одинаковыми полями поднимает вверх заменяя ее убирает лишнии ветки поднимает вврх значения
	//
	// Например было:				Станет:
	//	- знач 0 |						- знач 0 |	
	//		- знач 1 | 						- знач 1 | знач 2
	//			- знач 1 | знач 2
	
	// Дерево 			- дерево значений
	// ПоляСравнений 	- перечисляются поля через запятую по которым будут определятся одинаковые строки
	//
	// ПервыйВход,      -
	//		ТеньДерева	- системное, нужно для рекурсии (внимание не обращать)
	
	Если ПервыйВход Тогда
		ТеньДерева = Дерево.Скопировать();
		ТеньДерева.Строки.Очистить(); КонецЕсли;
	
	Для Каждого Строка Из Дерево.Строки Цикл
		
		// Формируем отбор
		
		Колонки = ПолучитьМассивИзСтроки(ПоляСравнений);
		Отбор 	= Новый Структура;
		Для Каждого Колонка Из Колонки Цикл Отбор.Вставить(Колонка, Строка[Колонка]) КонецЦикла;
		
		// Смотрим если дети такиеже то не формируем новую строку
		
		Если Строка.Строки.НайтиСтроки(Отбор, Ложь).Количество() Тогда
			НовСтрока = ТеньДерева;
		Иначе
			НовСтрока = ТеньДерева.Строки.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка); КонецЕсли;
		
		СтрокиДереваОбработатьКрасиво(Строка, ПоляСравнений, Ложь, НовСтрока); КонецЦикла;
	
	// Отдадим
	
	Если ПервыйВход Тогда Дерево = ТеньДерева; КонецЕсли;
	
КонецПроцедуры

Процедура ПеренестиРодителяВДереве(Дерево, СтрокаРодитель, Строка, Копирование = Ложь) Экспорт
	
	// Устанавливает родителя строку строке ту которая нужна
	// сдеалана так как свойство "Родитель" не доступно для записи
	//
	//	Дерево 			- само дерево значений
	//	СтрокаРодитель 	- строка которая будет родителем данной строки
	//	Строка 			- строка которой назначаем родителя
	//	Копирование		- если в ИСТИНА тогда строку не удалить (Скопирует)
	//						если ЛОЖЬ тогда за собой удалить (Перемещение)
	//
	// ВАЖНО не указывать родителя если строка родитель находится внутри строк самой строки (иначе рекурсия и падение)
	
	
	// Создадим копию дерева для промежуточных строк
	
	времДерево = Новый ДеревоЗначений;
	Для Каждого Колонка Из Дерево.Колонки Цикл времДерево.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения); КонецЦикла;
	
	// Скопируем все по этой строки
	
	ДобавитьДеревоКДругомуДереву(времДерево, Строка);
	
	// Удалим эту строку
	
	Если Не Копирование И Строка.Родитель = Неопределено Тогда Дерево.Строки.Удалить(Строка) Иначе Строка.Родитель.Строки.Удалить(Строка); КонецЕсли;
	
	// Добавим к родителю нашу таблицу
	
	ДобавитьДеревоКДругомуДереву(СтрокаРодитель, времДерево);
	
КонецПроцедуры

Процедура УдалитьСтрокиТЗ(ТЗ, СтруктураУсловия, УсловиеИ = Истина) Экспорт
	
	// Удаляет строки в таблице которые соответствуют условию
	//	СтруктураУсловия 	- в ключе имя колонки в значении условие значения
	// 	УсловиеИ 			- значит все параметры условия сединяются по логическому "И"
	//							если ЛОЖЬ тогда логическое ИЛИ
	
	колСтрок 	= ТЗ.Количество();
	Инд 		= колСтрок;
	КолУсловий	= СтруктураУсловия.Количество();
	
	Для Ном = 1 По колСтрок Цикл Инд = Инд - 1;
		
		// Посчитаем количество условий
		текУсловий = 0;
		Для Каждого Условие Из СтруктураУсловия Цикл текУсловий = текУсловий + Число(ТЗ[Инд][Условие.Ключ] = Условие.Значение);КонецЦикла;
		
		// Удалим строку если не прошла через условие
		Если ?(УсловиеИ, текУсловий = КолУсловий, текУсловий) Тогда ТЗ.Удалить(Инд); КонецЕсли;	КонецЦикла;
	
КонецПроцедуры

Процедура ИнвертироватьЧислоВТаблицу(Таблица, КолонкиИнверсии = "Количество") Экспорт
	
	// Значения в колонках умнажает на -1
	
	Колонки = ПолучитьМассивИзСтроки(КолонкиИнверсии);
	
	Для Каждого Строка ИЗ Таблица Цикл
		
		Для Каждого Колонка Из Колонки Цикл
			
			Строка[Колонка] = Строка[Колонка] * -1;
			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Функция РазнестиТаблицуПоТаблицеОстатков(            // v 0001
						Таблица, 
						ТаблицаОстатков, 
						СтруктураПоиска = Неопределено,
						ИмяКолонкиКоличества = "Количество",
						ИмяКолонкиКоличестваОстатка = "Количество"//,
						//СумируемыеКолонки = ""
						) Экспорт
	
	// Разносит остатки по таблице остатков
	// актуально для списания
	// разносимая таблица будет дополнятся значениями таблицы остатков в случае если они не равны
	//
	//	СтруктураПоиска - структура по которой ищется соответствие
	//						в ключе имя колонки таблицы
	//						в значении имя колонки таблицы остатков
	//	--- пока отключено ----- //	СумируемыеКолонки - строка имен колонок перечисленные через запятые по которым нужно просумировать результат (свренуть)
	//
	// Возвращает таблицу результат в которой проставлено количество доступное в остатке
	//		колонки новой таблицы соответствуют колонкам обеих таблиц
	
	Если СтруктураПоиска = Неопределено Тогда
		СтруктураПоиска = Новый Структура("Номенклатура", "Номенклатура");
	КонецЕсли;
	
	КолонкиСтр 	= "";
	УжеВзято 	= ТаблицаОстатков.СкопироватьКолонки();
	ТаблВывода 	= Таблица.СкопироватьКолонки();
	ДобавитьКолонкиТаблицыКДругимКолонкам(ТаблВывода.Колонки, ТаблицаОстатков.Колонки);
	
	// Сформируем имена колонок
	
	Для Каждого Колонка Из ТаблВывода.Колонки Цикл
		Если Колонка.Имя <> ИмяКолонкиКоличестваОстатка Тогда
			КолонкиСтр = КолонкиСтр + ?(КолонкиСтр = "","",",") + Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Для каждого Строка Из Таблица Цикл
		
		Нужно = Строка[ИмяКолонкиКоличества];
		
		// Найдем остатки
		
		Отбор = Новый Структура;
		Для Каждого Элемент Из СтруктураПоиска Цикл
			Отбор.Вставить(Элемент.Значение, Строка[Элемент.Ключ]);
		КонецЦикла;
		
		СтрокиОстатков = ТаблицаОстатков.НайтиСтроки(Отбор);
		
		// Найдем че раньше находили
		
		СтрокиВзято = УжеВзято.НайтиСтроки(Отбор);
		
		Если СтрокиВзято.Количество() Тогда
			СтрокаВзято = СтрокиВзято[0];
		Иначе
			СтрокаВзято = УжеВзято.Добавить();
			СтрокаВзято[ИмяКолонкиКоличестваОстатка] = 0;
		КонецЕсли;
		
		Для каждого СтрокаОстатка Из СтрокиОстатков Цикл
			
			// Определим порцию
			
			Берем = Мин(СтрокаОстатка[ИмяКолонкиКоличестваОстатка] - СтрокаВзято[ИмяКолонкиКоличестваОстатка], Нужно);
			
			Если Берем > 0 Тогда
				
				НовСтрока = ТаблВывода.Добавить();
				ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
				ЗаполнитьЗначенияСвойств(НовСтрока, СтрокаОстатка);
				
				НовСтрока[ИмяКолонкиКоличества] = Берем;
				
				// Подкорректируем остатки
				
				Нужно = Нужно - Берем;
				СтрокаВзято[ИмяКолонкиКоличестваОстатка] = СтрокаВзято[ИмяКолонкиКоличестваОстатка] - Берем
							
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	
	// Свернем подготовленную таблицу
	
	ТаблВывода.Свернуть(КолонкиСтр, ИмяКолонкиКоличестваОстатка);
	
	// Вернем
	
	Возврат ТаблВывода;
	
КонецФункции

Процедура ПроставитьФлагВТаблицеПотаблицеСравнения(Таблица1, Знач Таблица2, ИмяКолонкиФлага, ИменаКолонокСравнения, ИмяКолонкиКоличество = "Количество", ПроизвольныйАлгоритмФильтра = "Истина") Экспорт
	
	// Процедура проставляет в "Таблица1" булевскую колонку "ИмяКолонкиФлага"
	// в Истина до тех пор пока количества хватает в "Таблица2"
	//
	// ИменаКолонокСравнения - имена колонок через запятую по которым соединяются таблицы
	
	МассивКолонокПоиска = ПолучитьМассивИзСтроки(ИменаКолонокСравнения);
	ТаблицаДобавления	= Таблица1.СкопироватьКолонки();
	
	Для Каждого Строка Из Таблица1 Цикл
		
		Если Вычислить(ПроизвольныйАлгоритмФильтра) Тогда
		
			СтруктураПоиска = Новый Структура;
			Для каждого имяПоиска Из МассивКолонокПоиска Цикл 
				СтруктураПоиска.Вставить(имяПоиска, Строка[имяПоиска]); КонецЦикла;
			
			НайдСтроки 	= Таблица2.НайтиСтроки(СтруктураПоиска);
			Нужно 		= Строка[ИмяКолонкиКоличество];
			
			Если Нужно Тогда
				
				Для Каждого НайдСтрока Из НайдСтроки Цикл
					
					Списываем 	= Мин(НайдСтрока[ИмяКолонкиКоличество], Нужно);
					Нужно 		= Нужно - Списываем;
					
					НайдСтрока[ИмяКолонкиКоличество] = НайдСтрока[ИмяКолонкиКоличество] - Списываем;
					
				КонецЦикла;
				
				Списано = Строка[ИмяКолонкиКоличество] - Нужно;
				
				Если Списано Тогда
					
					стФлаг					= Строка[ИмяКолонкиФлага];
					Строка[ИмяКолонкиФлага] = Истина;
									Если Списано <> Строка[ИмяКолонкиКоличество] Тогда
					
						НовСтрока = ТаблицаДобавления.Добавить();
						ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
						
						Строка[ИмяКолонкиКоличество] 	= Списываем;
						НовСтрока[ИмяКолонкиКоличество] = Нужно;
						НовСтрока[ИмяКолонкиФлага] 		= стФлаг;
					
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаДобавления.Количество() Тогда
		ДобавитьТаблицуКДругойТаблице(Таблица1, ТаблицаДобавления);
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыполнитьВыражениеВКаждойСтрокеТаблицы(Таблица, Выражение, Параметры = Неопределено) Экспорт
	
	Инд = -1;
	Для Каждого Строка Из Таблица Цикл Инд = Инд + 1; Выполнить(Выражение); КонецЦикла;
	
КонецПроцедуры
Процедура ВыполнитьВыражениеВКаждойВыборке(Выборка, Выражение, Параметры = Неопределено) Экспорт
	
	Пока Выборка.Следующий() Цикл
		Выполнить(Выражение);
	КонецЦикла;
	
КонецПроцедуры


Функция ПолучитьСуммуКолонкиПоУсловию(Знач Таблица, АкуммулКолонка = "Сумма", Отбор) Экспорт
	
	
	Сумма = 0;Строки = Таблица.НайтиСтроки(Отбор);
	
	Для Каждого Строка Из Строки Цикл Сумма = Сумма + Строка[АкуммулКолонка];КонецЦикла;
	
	Возврат Сумма;
	
КонецФункции

Процедура СвернутьАЧислаСуммировать(ТаблицаЗначений, КолонкиИсключения = "") Экспорт
	
	// Сворачивает таблицу значений
	// Числовые колонки суммирует за исключение "КолонкиИсключения" (передается строкой через запятую)
	
	
	// Вычислим колонки
	
	стрПоказателей 	= "";
	стрРесурсов 	= "";
	
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Типы = Колонка.ТипЗначения.Типы();
		Если Типы.Количество() = 1 И Типы[0] = Тип("Число") И Не Найти(КолонкиИсключения, Колонка.Имя) Тогда
			стрРесурсов = стрРесурсов + ?(стрРесурсов = "","",",") + Колонка.Имя;
		Иначе
			стрПоказателей = стрПоказателей + ?(стрПоказателей = "","",",") + Колонка.Имя; КонецЕсли; КонецЦикла;
	
	// Свернем
	
	ТаблицаЗначений.Свернуть(стрПоказателей, стрРесурсов);
	
КонецПроцедуры

Процедура ОчиститьЗначенияВСтрокеПоУказаннымКолонкам(Строка, Колонки, ИмяКолонкиНачало = "", ИмяКолонкиКонец = "") Экспорт
	
	// Очищает значения в колонках имена которых встречаются в условии
	// Строка - строка таблицы значений или коллекция
	// Колонки - колекция колонок таблицы значений, или массив элементами которого являются строка с именами колонок
	// ИмяКолонкиНачало - фильтр по имени колонки по которому оно начинается для очищения
	// ИмяКолонкиКонец 	- фильтр по имени колонки конец по которому оно заканчивается для очищения
	
	Если ТипЗнч(Колонки) = Тип("Массив") Тогда
		Для Каждого Колонка Из Колонки Цикл Если Лев(Врег(Колонка), стрДлина(ИмяКолонкиНачало)) = Врег(ИмяКолонкиНачало) Или Прав(Врег(Колонка), стрДлина(ИмяКолонкиКонец)) = Врег(ИмяКолонкиКонец) Тогда Строка[Колонка] = Неопределено КонецЕсли; КонецЦикла;
	Иначе
		Для Каждого Колонка Из Колонки Цикл Если Лев(Врег(Колонка.Имя), стрДлина(ИмяКолонкиНачало)) = Врег(ИмяКолонкиНачало) Или Прав(Врег(Колонка.Имя), стрДлина(ИмяКолонкиКонец)) = Врег(ИмяКолонкиКонец) Тогда Строка[Колонка.Имя] = Неопределено КонецЕсли; КонецЦикла; КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьНесколькоТаблицПоПолюРазделителю(ТаблЗнач, ИмяПоляРазделителя, СтрокаУСловие = "") Экспорт
	
	// Возвращает массив элементами которого будут таблицы значений
	// таблицы значений разделяться по полю разделителью переданному в параметре 
	
	Массив = Новый Массив;
	
	НовТабл = ТаблЗнач.Скопировать(,ИмяПоляРазделителя);
	НовТабл.Свернуть(ИмяПоляРазделителя);
	
	Для Каждого Строка Из НовТабл Цикл 
		Если СтрокаУСловие = "" Или Вычислить(СтрокаУСловие) Тогда
			Массив.Добавить(ПолучитьТаблицуИзНайденныхСтрокТаблицыЗначений(ТаблЗнач, Новый Структура(ИмяПоляРазделителя, Строка[ИмяПоляРазделителя]))) КонецЕсли; КонецЦикла;
	Возврат Массив;
	
КонецФункции

Функция ПолучитьТаблицуРазницуДокументаИРегистраОстатков(ТаблицаДокумента, ИмяРегистра, Измерения, Ресурсы, Параметры = Неопределено, СоответствиеПараметровПолямОтбора = Неопределено) Экспорт
	
	// Сравнивает то что есть сейчас в таблице с тем что есть в регистре для того
	// чтобы получить таблицу результат при записи которой в регистр будет получен 
	// итоговый результат таблиц остатков точно такаяже как и передаваемая таблица
	
	// Подготовим переменные для запроса сравнения
	
	мИзмерения 		= ПолучитьМассивИзСтроки(Измерения);
	мРесурсы 		= ПолучитьМассивИзСтроки(Ресурсы);
	ТекстВыборки 	= "";
	ТекстСоединения	= "";
	ТекстОтбора		= "";
	
	Для Каждого Измерение Из мИзмерения Цикл
		ТекстВыборки = ТекстВыборки + ?(ТекстВыборки = "","",",") + "
				|	ЕСТЬNULL(Рег." + Измерение + ", Таблица." + Измерение + ") " + Измерение;
		ТекстСоединения = ТекстСоединения + ?(ТекстСоединения = "",""," И ") + "
							|	Рег." + Измерение + " = Таблица." + Измерение; КонецЦикла;
			
    Для Каждого Ресурс Из мРесурсы Цикл
		ТекстВыборки = ТекстВыборки + ?(ТекстВыборки = "","",",") + "
				|	ЕСТЬNULL(Таблица." + Ресурс + ", 0) - ЕСТЬNULL(Рег." + Ресурс + "Остаток, 0) " + Ресурс;
		ТекстОтбора = ТекстОтбора + ?(ТекстОтбора = "",""," ИЛИ ") + "
		//ТекстОтбора = ТекстОтбора + ?(ТекстОтбора = "",""," И ") + "
							|   ЕСТЬNULL(Рег." + Ресурс + "Остаток, 0) - ЕСТЬNULL(Таблица." + Ресурс + ", 0) <> 0"; КонецЦикла;
			
	// Свернем сразу
	
	ТаблицаДокумента.Свернуть(Измерения, Ресурсы);
	
	// Загрузим во временую таблицу
	Запрос = Новый Запрос("
		|ВЫБРАТЬ Таб." + СтрЗаменить(СтрЗаменить(Измерения, " ", ""), ",", ", Таб.") + ", Таб." + СтрЗаменить(СтрЗаменить(Ресурсы, " ", ""), ",", ", Таб.") + "
		|ПОМЕСТИТЬ
		|	ТаблицаДокумента
		|ИЗ
		|	&ТаблицаДокумента КАК Таб
		|");
		                  		
	МенеджерВременныхТаблиц 		= Новый МенеджерВременныхТаблиц;
	Запрос.МенеджерВременныхТаблиц 	= МенеджерВременныхТаблиц;
		
	Запрос.УстановитьПараметр("ТаблицаДокумента", ТаблицаДокумента);
	Запрос.Выполнить();
	
	// Установим параметры запрос
	
	ТекстПараметров = "";
	Если Параметры <> Неопределено Тогда
		Для Каждого Параметр Из Параметры Цикл
			
			ПолеОтбора =  Параметр.Ключ;
			
			Если СоответствиеПараметровПолямОтбора <> Неопределено Тогда	ЗначениеСвойства = "";
				Если СоответствиеПараметровПолямОтбора.Свойство(Параметр.Ключ, ЗначениеСвойства) Тогда
					ПолеОтбора = ЗначениеСвойства; КонецЕсли; КонецЕсли;
			
			ТекстПараметров = ТекстПараметров + ?(ТекстПараметров = "",""," И ") + ПолеОтбора + " = &" + Параметр.Ключ;
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение); КонецЦикла; КонецЕсли;
	
	// Выполним запрос сравнения
		
	Запрос.Текст = " 
	|ВЫБРАТЬ " + ТекстВыборки + "
	|ИЗ
	|	РегистрНакопления." + ИмяРегистра + ".Остатки(," + ТекстПараметров + ") КАК Рег
	|
	|ПОЛНОЕ СОЕДИНЕНИЕ
	|   ТаблицаДокумента КАК Таблица
	|ПО 
	|"	+ ТекстСоединения + "
	|ГДЕ
	|   " + ТекстОтбора + "
	|";
	
	ТЗ = Запрос.Выполнить().Выгрузить();
	
	
	//добавим колонку "СуммаНДС"
	//СчитаемНДС=Истина;
	//ТекЗаказ=0;
	//Если Параметры.Свойство("ЗаказПокупателя",ТекЗаказ) Тогда
	//ИначеЕсли Параметры.Свойство("ИнтернетЗаказ",ТекЗаказ) Тогда
	//Иначе
	//	СчитаемНДС=Ложь;
	//КонецЕсли;	
	//
	//Если СчитаемНДС Тогда
	//	СуммаВключаетНДС = ТекЗаказ.СуммаВключаетНДС;
	//	ТЗ.Колонки.Добавить("СуммаНДС");
	//	Для Каждого Стр Из ТЗ Цикл
	//		СтавкаЧислом=КэшируемыеФункции.ПолучитьЧислоСтавкиНДС(Стр.СтавкаНДС);
	//		Если СуммаВключаетНДС Тогда
	//			Стр.СуммаНДС=Стр.Сумма*СтавкаЧислом/(100+СтавкаЧислом);
	//		Иначе
	//			Стр.СуммаНДС=Стр.Сумма*СтавкаЧислом/100;
	//		КонецЕсли;
	//	КонецЦикла;	
	//КонецЕсли;
	
	
	Возврат ТЗ;
	
КонецФункции
Функция ПолучитьТаблицуРазницуДокументаИРегистровОстатков(ТаблицаДокумента, Регистры) Экспорт
	
	// Сравнивает то что есть сейчас в таблице с тем что есть в регистрах остатков для того
	// чтобы получить таблицу результат при записи которой в регистр будет получен 
	// итоговый результат таблиц остатков точно такаяже как и передаваемая таблица
	//
	//	Регистры - массив, внутри структуры в которых перечислены регистры для запроса в сл. структуре:
	//		- ИмяРегистра - имя регистра
	//		- Измерения - строка в которой через запятую представлены измерения
	//		- Ресурсы - строкав которой через запятую представлены ресуры
	//		- Параметры - необязательно, параметры запроса, в ключе имя параметра в значении значение
	//		- СоответствиеПараметровПолямОтбора - необязательно, соответствие параметров условияю в запросе
	//	важно ! чтобы количество измерений и ресурсов совпадали так как они будут объединятся по первой структуре
	
	
	// Подготовим переменные для запроса сравнения
	
	ПараметрыДляЗапроса = Новый Структура;
	ТекстСоединения		= "";
	ТекстВыборкиЗпр 	= "";
	ТекстРеусурсовЗпр 	= "";
	ТекстОтбора			= "";
	
	СтрЗапроса = ""; ЭтоПервыйРаз = Истина;
	
	Для Каждого Регистр Из Регистры Цикл
	
		мИзмерения 		= ПолучитьМассивИзСтроки(Регистр.Измерения);
		мРесурсы 		= ПолучитьМассивИзСтроки(Регистр.Ресурсы);
		ТекстВыборки 	= "";
		
		Для Каждого Измерение Из мИзмерения Цикл
			ТекстВыборки = ТекстВыборки + ?(ТекстВыборки = "","",",") + "
								|	" + Измерение + ?(ЭтоПервыйРаз, " КАК " + Измерение, "");
			Если ЭтоПервыйРаз Тогда
				ТекстВыборкиЗпр = ТекстВыборкиЗпр + ?(ТекстВыборкиЗпр = "","",", ") + "
								|	ЕСТЬNULL(Таблица." + Измерение + ", Рег." + Измерение + ") КАК " + Измерение;
				ТекстСоединения = ТекстСоединения + ?(ТекстСоединения = "",""," И ") + "
								|	Рег." + Измерение + " = Таблица." + Измерение; КонецЕсли; КонецЦикла;
				
		Для Каждого Ресурс Из мРесурсы Цикл
			ТекстВыборки = ТекстВыборки + ?(ТекстВыборки = "","",",") + "
								|	" + Ресурс + "Остаток " + ?(ЭтоПервыйРаз, " КАК " + Ресурс, "");
			Если ЭтоПервыйРаз Тогда 
				ТекстВыборкиЗпр = ТекстВыборкиЗпр + ",
								|	ЕСТЬNULL(Таблица." + Ресурс + ", 0) - ЕСТЬNULL(Рег." + Ресурс + ", 0) " + Ресурс;
				ТекстРеусурсовЗпр = ТекстРеусурсовЗпр + ?(ТекстРеусурсовЗпр = "","",",") + "
								|	СУММА(" + Ресурс + ") КАК " + Ресурс;
				ТекстОтбора = ТекстОтбора + ?(ТекстОтбора = "",""," ИЛИ ") + "
								|   ЕСТЬNULL(Рег." + Ресурс + ", 0) - ЕСТЬNULL(Таблица." + Ресурс + ", 0) <> 0"; КонецЕсли; КонецЦикла;
						
		// Установим параметры запрос
	
		ТекстПараметров = "";
		Если Регистр.Свойство("Параметры") Тогда
			Для Каждого Параметр Из Регистр.Параметры Цикл
			
				ПолеОтбора = Параметр.Ключ;
			
				Если Регистр.Свойство("СоответствиеПараметровПолямОтбора") Тогда
					ЗначениеСвойства = "";
					Если Регистр.СоответствиеПараметровПолямОтбора.Свойство(Параметр.Ключ, ЗначениеСвойства) Тогда
						ПолеОтбора = ЗначениеСвойства; КонецЕсли; КонецЕсли;
			
				ТекстПараметров = ТекстПараметров + ?(ТекстПараметров = "",""," И ") + ПолеОтбора + " = &" + Параметр.Ключ;
				ПараметрыДляЗапроса.Вставить(Параметр.Ключ, Параметр.Значение); КонецЦикла; КонецЕсли;

		СтрЗапроса = СтрЗапроса + ?(ЭтоПервыйРаз,"","
		|ОБЪЕДИНИТЬ ВСЕ
		|") + "
		|ВЫБРАТЬ " + ТекстВыборки + "
		|ИЗ
		|	РегистрНакопления." + Регистр.ИмяРегистра + ".Остатки(," + ТекстПараметров + ")"; 
		
		ЭтоПервыйРаз = Ложь; КонецЦикла;
		
	// Свернем сразу
	
	Измерения 	= Регистры[0].Измерения;
	Ресурсы 	= Регистры[0].Ресурсы;
		
	ТаблицаДокумента.Свернуть(Измерения, Ресурсы);
		
	// Загрузим во временую таблицу
	Запрос = Новый Запрос("
			|ВЫБРАТЬ " + Измерения + "," + Ресурсы + "
			|ПОМЕСТИТЬ	ТаблицаДокумента
			|ИЗ			&ТаблицаДокумента КАК ТаблицаДокумента
			|");
		                  		
	МенеджерВременныхТаблиц 		= Новый МенеджерВременныхТаблиц;
	Запрос.МенеджерВременныхТаблиц 	= МенеджерВременныхТаблиц;
		
	Запрос.УстановитьПараметр("ТаблицаДокумента", ТаблицаДокумента);
	Запрос.Выполнить();
	
	// Установим параметры
	
	Для КАждого Параметр Из ПараметрыДляЗапроса Цикл Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение) КонецЦикла;
	
	// Выполним запрос сравнения
		
	Запрос.Текст = " 
	|ВЫБРАТЬ " + ТекстВыборкиЗпр + "
	|ИЗ (
	|	ВЫБРАТЬ				" + Измерения + "," + ТекстРеусурсовЗпр + "
	|	ИЗ (				" + СтрЗапроса + ") Запрос
	|	СГРУППИРОВАТЬ ПО 	" + Измерения + "
	|)КАК Рег
	|
	|ПОЛНОЕ СОЕДИНЕНИЕ
	|   ТаблицаДокумента КАК Таблица
	|ПО 
	|"	+ ТекстСоединения + "
	|ГДЕ
	|   " + ТекстОтбора + "
	|";
		
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

Функция ПолучитьТаблицуРазницу_Ст(Таблица1, Таблица2, ВариантСравнения = 0)
	
	// Возвращает таблицу результат сравнения двух таблиц
	// ВариантСравнения: 	0 - будет только то что содержится в обоих таблицах
	//						1 - будет только то что содержится в первой таблице
	//						2 - будет только то что содержится во второй таблице
	
	ИмяКолонкиСравнения = "Kоличествo";
	Сравнение = Таблица1.Скопировать();
	
	// Определяем колонки
	
	стрКолонки = "";
	Для Каждого Колонка Из Сравнение.Колонки Цикл
		стрКолонки = стрКолонки + ?(стрКолонки = "","",",") + Колонка.Имя;
	КонецЦикла;
	
	// Дорбавляем и заполняем вспомогательную колонку
	
	Сравнение.Колонки.Добавить(ИмяКолонкиСравнения, Новый ОписаниеТипов("Число"));
	Таблица2.Колонки.Добавить(ИмяКолонкиСравнения, Новый ОписаниеТипов("Число"));
	
	Сравнение.ЗаполнитьЗначения(-1, ИмяКолонкиСравнения);
	Таблица2.ЗаполнитьЗначения(1, ИмяКолонкиСравнения);
	
	ДобавитьТаблицуКДругойТаблице(Сравнение, Таблица2);
	
	// Сравниваем
	
	Сравнение.Свернуть(стрКолонки, ИмяКолонкиСравнения);
	
	// Определяем что вернуть
	
	ИскатьПо = 0;Если ВариантСравнения = 1 Тогда ИскатьПо = -1 Иначе ИскатьПо = 1;КонецЕсли;
	НовТаблица = ПолучитьТаблицуИзНайденныхСтрокТаблицыЗначений(Сравнение, Новый Структура(ИмяКолонкиСравнения, ИскатьПо));
	
	// Зачищаем за собой память
	
	Таблица2.Колонки.Удалить(ИмяКолонкиСравнения);
	НовТаблица.Колонки.Удалить(ИмяКолонкиСравнения);
	
	// Возвращаем результат
	
	Возврат НовТаблица;
	
КонецФункции
Функция ПолучитьТаблицуРазницу(Таблица1, Таблица2, ВариантСравнения = 0, ИменаКолонок = "") Экспорт
	
	// Возвращает таблицу результат сравнения двух таблиц
	//	! колонки в таблице1 должны быть и в Таблице2, те колонки которые есть в Таблице2 
	//	но нет в Таблице1 будут пропущенв и не появятся в таблице результате, в Таблице2
	//	должны быть все колонки которые есть в Таблице1
	//  типы в колонках должны быть примитвными либо не составными и без строк неограниченной длины
	//
	// ВариантСравнения: 	0 - будет только то что содержится в обоих таблицах
	//						1 - будет только то что содержится в первой таблице
	//						2 - будет только то что содержится во второй таблице
	
	// Определяем колонки
	
	ЕстьКолонки = ИменаКолонок <> "";
	стрКолонки 	= "";
	стрОб 		= "";
	стрСоед		= "";
	
	Для Каждого Колонка Из Таблица1.Колонки Цикл
		
		Имя = Колонка.Имя;
		
		стрОб 		= стрОб + ?(стрОб = "","",",") + "ЕСТЬNULL(Таб1." + Имя + ",Таб2." + Имя + ") ";
		стрСоед		= стрСоед + ?(стрСоед = "",""," И ") + "Таб1." + Имя + " = Таб2." + Имя;
		
		Если Не ЕстьКолонки Тогда
			стрКолонки 	= стрКолонки + ?(стрКолонки = "","",",") + "Табл." + Имя;
		КонецЕсли;
		
	КонецЦикла;
	
	//Если Если Не еЕстьКолонки Тогда
	//		стрКолонки 	= стрКолонки + ?(стрКолонки = "","",",") + "Табл." + Имя;
	//	КонецЕсли;
	
	//ИменаСравнений = ПолучитьМассивИзСтроки(СтрокиСравнения);
	//Для Каждого ИмяСравнения Из ИменаСравнений Цикл
	//	
	//	стрСоед	= стрСоед + ?(стрСоед = "",""," И ") + "Таб1." + ИмяСравнения + " = Таб2." + ИмяСравнения;
	//	
	//КонецЦикла;
	
	// Формируем текст
	
	Текст = "
	|ВЫБРАТЬ " + стрКолонки + "
	|ПОМЕСТИТЬ	Таблица1
	|ИЗ			&Таблица1 КАК Табл
	|;
	|ВЫБРАТЬ " + стрКолонки + "
	|ПОМЕСТИТЬ	Таблица2
	|ИЗ			&Таблица2 КАК Табл
	|;
	|ВЫБРАТЬ " + стрОб + "
	|ИЗ		Таблица1 Таб1
	|
	|ПОЛНОЕ СОЕДИНЕНИЕ
	|	Таблица2 Таб2
	|ПО " + стрСоед + "
	|
	|ГДЕ
	|";
	
	// Определим условия
	
	Если ВариантСравнения = 0 Тогда
		
		Текст = Текст + "НЕ Таб1." + Имя + " ЕСТЬ NULL И НЕ Таб2." + Имя + " ЕСТЬ NULL";
		
	ИначеЕсли ВариантСравнения = 1 Тогда
		
		Текст = Текст + "НЕ Таб1." + Имя + " ЕСТЬ NULL И Таб2." + Имя + " ЕСТЬ NULL";
		
	ИначеЕсли ВариантСравнения = 2 Тогда
		
		Текст = Текст + "Таб1." + Имя + " ЕСТЬ NULL И НЕ Таб2." + Имя + " ЕСТЬ NULL";
		
	Иначе
		
		ВызватьИсключение "Не понятен вариант сравнения двух таблиц ""ВариантСравнения"" = ? (сейчас " + ВариантСравнения + ")";
		
	КонецЕсли;
	
	// Загржаем в запрос и получаем результат
	
	Запрос = Новый Запрос(Текст);
	
	Запрос.УстановитьПараметр("Таблица1",Таблица1);
	Запрос.УстановитьПараметр("Таблица2",Таблица2);
	
	// Возвращаем результат
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

Процедура РаздатьКопейкиНуждающимся(Таблица, ИмяКолонки, Сумма) Экспорт
	
	// Функция раздает копейки (сумму) в таблице самым большим суммам
	// если нужно раздать или отбирает также начиная от самых больших сумм
	//
	//	Таблица 	- таблица по которой будет происходить раздача
	//	ИмяКолонки 	- строка, имя колонки в которой происходит раздача
	//	Сумма 		- сумма к которой нужно привести итог по колонке ИмяКолонки
	
	// Подготовим
	
	//текСумма = Таблица.Итог(ИмяКолонки);
	// Вычислим итог перебором а не с помощью "итог" т.к. таблица может быть не таблицой значением а массивом строк
	текСумма = 0; типЧисло = Тип("Число");
	Для КАждого Строка Из Таблица Цикл 
		Если ТипЗнч(Строка[ИмяКолонки]) = типЧисло Тогда
			текСумма = текСумма + Строка[ИмяКолонки] КонецЕсли; КонецЦикла;
	
	Если Не текСумма Или Не Сумма Или текСумма = Сумма Тогда Возврат КонецЕсли;
	
	Разница = Сумма - текСумма;
	Отдаем 	= Разница;
	
	// Раздадим пропорционально коэффициенту
	
	МаксСумма = 0; ИндМаксСуммы = 0; Инд = -1;
	Для Каждого Строка ИЗ Таблица Цикл Инд = Инд + 1;
		Если МаксСумма < Строка[ИмяКолонки] Тогда МаксСумма = Строка[ИмяКолонки]; ИндМаксСуммы = Инд; КонецЕсли;
		
		ЩасОтдаем = Строка[ИмяКолонки] / текСумма * Разница; ЗнДо = Строка[ИмяКолонки];
		Строка[ИмяКолонки] = Строка[ИмяКолонки] + ЩасОтдаем; ОкрЩасОтдаем = Строка[ИмяКолонки] - ЗнДо;
		Отдаем = Отдаем - ОкрЩасОтдаем; КонецЦикла;
	
	// Последнюю копейку отдадим толстому
	
	Если Отдаем Тогда
		Таблица[ИндМаксСуммы][ИмяКолонки] = Таблица[ИндМаксСуммы][ИмяКолонки] + Отдаем КонецЕсли;
	
КонецПроцедуры
Процедура РаздатьКопейкиНуждающимся_Колонкам(Таблица, СтруктураКолонок) Экспорт
	
	// Функция раздает копейки (сумму) в таблице самым большим суммам
	// если нужно раздать или отбирает также начиная от самых больших сумм
	//
	//	Таблица 		- таблица по которой будет происходить раздача
	//	СтруктураКолонок - Структура внутри которой
	//						в значениии, имя колонки в которой происходит раздача
	//						в знаечнии, сумма к которой нужно привести итог
	
	
	Для Каждого Элемент Из СтруктураКолонок Цикл РаздатьКопейкиНуждающимся(Таблица, Элемент.Ключ, Элемент.Значение) КонецЦикла
	
КонецПроцедуры


// РАБОТА СО СТРОКОЙ

Функция ЗабитьСтрокуСимволамиСлева(Строка, СимволЗабивания, ДлинаФинальнойСтроки) Экспорт
	
	// Заббъет и вернет строку слева символами чтобы длина строки соответвовала
	
	стр = "";
	Для Ном = 1 По ДлинаФинальнойСтроки Цикл стр = стр + СимволЗабивания КонецЦикла;
	Возврат Прав(стр + строка, ДлинаФинальнойСтроки);
	
КонецФункции

Функция ВырезатьДоПервогоПробелаСправа(Строка) Экспорт
	
	Длина = СтрДлина(Строка);
	Для Ном = 1 По Длина Цикл Если Сред(СТрока, Длина - Ном + 1, 1) = " " Тогда Возврат Прав(СТрока, Ном - 1);КонецЕсли; КонецЦикла;
	
КонецФункции

Функция ПреобразоватьРусскийТекстВАнглицкий(Строка) Экспорт
	
	Рус = "А Б В Г Д Е Ё  Ж  З И Й К Л М Н О П Р С Т У Ф Х Ц  Ч  Ш  Щ   Ъ Ы Ь Э Ю  Я";
	Анг = "A B V G D E YO ZH Z I Y K L M N O P R S T U F H TS CH SH SCH   Y   E YU YA";

	новТекст 	= "";
	Длина 		= СтрДлина(Строка);
	
	Для Ном = 1 По Длина Цикл
		
		Позиция = 0;
		вРег 	= Ложь;
		Символ	= Сред(Строка, Ном, 1);
		
		Если Символ <> " " Тогда
		
			Позиция = Найти(Рус, Символ);
			Если Не Позиция Тогда Позиция = Найти(Рус, ВРег(Символ)); ВРег = Булево(Позиция); КонецЕсли;
				
			Если Позиция Тогда
				
				новСимвол = "";
				Пока Истина Цикл новСимвол = новСимвол + СокрЛП(Сред(Анг, Позиция, 1)); Позиция = Позиция + 1; Если ПустаяСтрока(Сред(Анг, Позиция, 1)) Тогда Прервать; КонецЕсли; КонецЦикла; КонецЕсли; КонецЕсли;
		
		новТекст = новТекст + ?(Позиция, ?(вРег, НРег(новСимвол), новСимвол), Символ); КонецЦикла;
	
	Возврат новТекст;

КонецФункции
Функция ЕстьРусскиеБуквы(Строка) Экспорт
	
	РусБуквы = "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯЁ";
	
	Есть = Ложь;
	Кол = СтрДлина(Строка);
	Для Ном = 1 По Кол Цикл Если Найти(РусБуквы, Врег(Сред(Строка, Ном, 1))) Тогда Есть = Истина; Прервать; КонецЕсли; КонецЦикла;
		
	Возврат Есть;
	
КонецФункции

Функция ПолучитьТолькоЦифры(Строка) Экспорт
	
	// Возвращает строку содержащие только цифры, остальные символы удаляются
	
	Цифры = "01234567890";
	Длина = СтрДлина(Строка);
	
	новНомер = "";
	Для Ном = 1 По Длина Цикл текСимвол = Сред(Строка, Ном, 1); новНомер = новНомер + ?(Найти(Цифры, текСимвол), текСимвол, ""); КонецЦикла;
	
	Возврат новНомер;
	
КонецФункции

// РАБОТА С HTML

Функция ПолучитьТекстHTMLВнутри_Body_ст(ТекстHTML) Экспорт
	
	//Чтение = Новый ЧтениеHTML;
	//Чтение.УстановитьСтроку(ТекстHTML);
	//
	//ПостроительDOM = Новый ПостроительDOM;
	//ДокументDOM = ПостроительDOM.Прочитать(Чтение);
	//ДокументDOM.Нормализовать();

	//Возврат ДокументDOM.ТекстовоеСодержимое;
	
КонецФункции
Функция ПолучитьТекстHTMLВнутри_Body(ТекстHTML) Экспорт
	
	// Вытаскивает текст который находится внутри первого тела <body>
	
	мТекст	= НРег(ТекстHTML);
	Начало 	= Найти(мТекст, "<body>");
	Конец 	= 0;
	
	найдКонец = Найти(мТекст, "</body>");
	
	Пока найдКонец Цикл Конец = Конец + найдКонец; найдКонец = Найти(Сред(мТекст, Конец + 1), "</body>"); КонецЦикла;
	
	Возврат Сред(ТекстHTML, Начало + 6, Конец - Начало - 6);
	
КонецФункции

Функция ВычленитьТело(пСтрока) Экспорт 
	
	// Функция Олега Гомана, млин меня обогнал по скорости (
 
 мРезультат = "";
 мНачало = Ложь;
 
 Для мСч=1 По СтрЧислоСтрок(пСтрока) Цикл
  мСтр = СтрПолучитьСтроку(пСтрока, мСч);
  Если Не мНачало Тогда
   мПоз = Найти(НРег(мСтр), "<body>");
   Если Не мПоз=0 Тогда
    мРезультат = Сред(мСтр, мПоз+6);
    мНачало = Истина;
   КонецЕсли;
  Иначе
   мПоз = Найти(НРег(мСтр), "</body>");
   Если мПоз=0 Тогда
    мРезультат = мРезультат + Символы.ПС + мСтр;
   Иначе
    мРезультат = мРезультат + Символы.ПС + Лев(мСтр, мПоз-1);
    Прервать;
   КонецЕсли;
  КонецЕсли;
 КонецЦикла;
 
 Возврат мРезультат;
 
КонецФункции

Функция ПолучитьПредставлениеТекстаHTML(ТекстHTML, УбратьПустыеСтроки = Ложь) Экспорт
	
	ИмяВрФайла = ПолучитьИмяВременногоФайла("html");
	
	Текст = Новый ТекстовыйДокумент; 
    Текст.УстановитьТекст("<HTML><HEAD>
		|<META content=""text/html; charset=utf-8"" http-equiv=Content-Type>
		|<META name=GENERATOR content=""MSHTML 9.00.8112.16553""></HEAD>
		|<BODY>" + ТекстHTML + "</BODY></HTML>");

	Текст.Записать(ИмяВрФайла);
	
	Извлекатель = Новый ИзвлечениеТекста(ИмяВрФайла);
	Строка = Извлекатель.ПолучитьТекст();
	
	УдалитьФайлы(ИмяВрФайла);
	
	Если УбратьПустыеСтроки И Не ПустаяСтрока(Строка) Тогда
		
		Текст = Новый ТекстовыйДокумент;
		Текст.УстановитьТекст(Строка);
		
		ЕстьПустаяСтрока = Ложь;
		Ид = Текст.КоличествоСтрок();
		// оставим одну пустую строку, лишние удалим
		Пока Ид >0 Цикл Стр = Текст.ПолучитьСтроку(Ид);
			Если ПустаяСтрока(Стр) Тогда 
				Если ЕстьПустаяСтрока Тогда Текст.УдалитьСтроку(Ид); КонецЕсли;  
				ЕстьПустаяСтрока = Истина;
 			Иначе ЕстьПустаяСтрока = Ложь; КонецЕсли;
			Ид = Ид - 1;
		КонецЦикла; 
		Строка = Текст.ПолучитьТекст();КонецЕсли;
		
	Возврат Строка; 

КонецФункции

Функция ЗавернутьТекстВHTML(Текст) Экспорт
	
	Возврат "<HTML><HEAD>
			|<META content=""text/html; charset=utf-8"" http-equiv=Content-Type>
			|<META name=GENERATOR content=""MSHTML 11.00.9600.18052""></HEAD>
			|<BODY>" + Текст + "</BODY></HTML>";
	
КонецФункции

Функция РазбитьURLНаЭлементы(Урл) Экспорт
	
	// Разбивает URL на протокол, сервер, путь
	// Например: https://1s.garagetools.ru/cloud/products/48804-30_380.jpg-s.jpg
	//	будет:	https
	//			1s.garagetools.ru
	//			cloud/products/48804-30_380.jpg-s.jpg
	
	позДвоеточ = СтрНайти(Урл, ":");
	позСлПалка = СтрНайти(Урл, "/",,,3);
	
	Возврат Новый Структура("Протокол, Сервер, Путь", 
			Лев(Урл, позДвоеточ - 1), 
			Сред(Урл, позДвоеточ + 3, позСлПалка - позДвоеточ - 3), 
			Сред(Урл, позСлПалка + 1));
			
КонецФункции

// РАБОТА С ДАТОЙ

Функция ПолучитьРазницуВремениСтрокой(НачалоСобытия, КонецСобытия, Пояснять = 1, ВКакомтоРоде = 0) Экспорт // v 0001
	
	// Пояснять: 	0 - без пояснения:  3 - 01:23:00
	//				1 - сокращено: 1д. 1ч. 23м.
	//				2 - цифры поясчнения полно: 1 день 1 час 23 минуты
	//				3 - полно все и цифры строкой: один час две минуты двадцать три секунды
	
	// ВКакомтоРоде:
	//				0 - 31 минута
	//				1 - 31 минуту
	//			
	
	
	Секунд 	= КонецСобытия - НачалоСобытия;
	Минут 	= Цел(Секунд / 60);
	Часов 	= Цел(Минут / 60);
	Дней 	= Цел(Часов / 24);
	
	Часов 	= Часов - Дней * 24;
	Минут 	= Минут - Дней * 24 * 60 - Часов * 60;
	Секунд 	= Секунд - Дней * 24 * 60 * 60 - Часов * 60 * 60 - Минут * 60;
	
	стрДней		= Формат(Дней,"ЧГ=");
	стрЧасов	= Формат(Часов,"ЧГ=");
	стрМинут	= Формат(Минут,"ЧГ=");
	стрСекунд	= Формат(Секунд,"ЧГ=");
	
	Если Не Пояснять Тогда
		
		Текст = ?(Дней,стрДней + " - ","") + Формат(стрЧасов,"ЧЦ=2; ЧН=00; ЧВН=") + ":" + Формат(стрМинут,"ЧЦ=2; ЧН=00; ЧВН=") + ":" + Формат(стрСекунд,"ЧЦ=2; ЧН=00; ЧВН=");
		
	ИначеЕсли Пояснять = 1 Тогда
		
		Текст = СокрЛП(	?(Дней,	Строка(Дней) + "д.","") + " " +
					?(Часов,	Строка(Часов) + "ч.","") + " " +
					?(Минут,	Строка(Минут) + "м.","") + " " +
					?(Секунд,	Строка(Секунд) + "с.","")
				);
				
	Иначе
		
		Если Не ВКакомтоРоде Тогда
			
			стрДней 	= ?(стрДней = "","", 	НРег(ЧислоПрописью(Дней, "ДП=Ложь","день, дня, дней,м,0")));
			стрЧасов	= ?(стрЧасов = "","",	НРег(ЧислоПрописью(Часов,"ДП=Ложь","час, часа, часов,м,0")));
			стрМинут 	= ?(стрМинут = "","",	НРег(ЧислоПрописью(Минут,"ДП=Ложь","минута, минуты, минут,ж,0")));
			стрСекунд	= ?(стрСекунд = "","",	НРег(ЧислоПрописью(Секунд,"ДП=Ложь","секунда, секунды, секунд,ж,0")));
			
		Иначе
			
			стрДней 	= ?(стрДней = "","", 	НРег(ЧислоПрописью(Дней, "ДП=Ложь","день, дня, дней,м,0")));
			стрЧасов	= ?(стрЧасов = "","",	НРег(ЧислоПрописью(Часов,"ДП=Ложь","час, часа, часов,м,0")));
			//стрМинут 	= ?(стрМинут = "","",	НРег(ЧислоПрописью(Минут,"ДП=Ложь","минута, минуты, минут,ж,0")));
			стрМинут 	= ?(стрМинут = "","",	НРег(ЧислоПрописью(Минут,"ДП=Ложь","минуту, минуты, минут,ж,0")));
			//стрСекунд	= ?(стрСекунд = "","",	НРег(ЧислоПрописью(Секунд,"ДП=Ложь","секунда, секунды, секунд,ж,0")));
			стрСекунд	= ?(стрСекунд = "","",	НРег(ЧислоПрописью(Секунд,"ДП=Ложь","секунду, секунды, секунд,ж,0")));
			
		КонецЕсли;
		
		стрДней = Лев(стрДней,СтрДлина(стрДней) - 4);
		стрЧасов = Лев(стрЧасов,СтрДлина(стрЧасов) - 4);
		стрМинут = Лев(стрМинут,СтрДлина(стрМинут) - 4);
		стрСекунд = Лев(стрСекунд,СтрДлина(стрСекунд) - 4);
		
		Если Пояснять = 2 Тогда
			
			стрДней = Формат(Дней,"ЧГ=") + " " + ВырезатьДоПервогоПробелаСправа(стрДней);
			стрЧасов = Формат(Часов,"ЧГ=") + " " + ВырезатьДоПервогоПробелаСправа(стрЧасов);
			стрМинут = Формат(Минут,"ЧГ=") + " " + ВырезатьДоПервогоПробелаСправа(стрМинут);
			стрСекунд = Формат(Секунд,"ЧГ=") + " " + ВырезатьДоПервогоПробелаСправа(стрСекунд);
			
		КонецЕсли;
						
		Текст = СокрЛП(	?(Дней,	стрДней,"") + " " +
					?(Часов,	стрЧасов,"") + " " +
					?(Минут,	стрМинут,"") + " " +
					?(Секунд,	стрСекунд,""));
		
	КонецЕсли;
	
	Возврат Текст;
	
КонецФункции

Функция ПолучитьЧислительноеЧислоПрописью(Число) Экспорт
	
	// возвращает число дней прописью
	// работает до 1000, дальше пишите сами
	
	Если Число > 0 И Число <= 1000 Тогда
	
		Если Число = 0 Тогда Возврат "нуля" 
		ИначеЕсли Число = 1 Тогда Возврат "одного" 
		ИначеЕсли Число = 2 Тогда Возврат "двух" 
		ИначеЕсли Число = 3 Тогда Возврат "трех" 
		ИначеЕсли Число = 4 Тогда Возврат "четырех" 
		ИначеЕсли Число = 5 Тогда Возврат "пяти" 
		ИначеЕсли Число = 6 Тогда Возврат "шести" 
		ИначеЕсли Число = 7 Тогда Возврат "семи" 
		ИначеЕсли Число = 8 Тогда Возврат "восьми" 
		ИначеЕсли Число = 9 Тогда Возврат "девяти" 
		ИначеЕсли Число = 10 Тогда Возврат "десяти"
		ИначеЕсли Число = 11 Тогда Возврат "одинадцати"
		ИначеЕсли Число = 12 Тогда Возврат "двенадцати"
		ИначеЕсли Число = 13 Тогда Возврат "тринадцати"
		ИначеЕсли Число = 14 Тогда Возврат "четырнадцати"
		ИначеЕсли Число = 15 Тогда Возврат "пятнадцати"
		ИначеЕсли Число = 16 Тогда Возврат "шестнадцати"
		ИначеЕсли Число = 17 Тогда Возврат "семнадцати"
		ИначеЕсли Число = 18 Тогда Возврат "восемнадцати"
		ИначеЕсли Число = 19 Тогда Возврат "девятнадцати"
		ИначеЕсли Число = 20 Тогда Возврат "двадцати"
		ИначеЕсли Число = 30 Тогда Возврат "тридцати"
		ИначеЕсли Число = 40 Тогда Возврат "сорока"
		ИначеЕсли Число = 50 Тогда Возврат "пятидесяти"
		ИначеЕсли Число = 60 Тогда Возврат "шестидесяти"
		ИначеЕсли Число = 70 Тогда Возврат "семидесяти"
		ИначеЕсли Число = 80 Тогда Возврат "восмидесяти"
		ИначеЕсли Число = 90 Тогда Возврат "девяноста"
		ИначеЕсли Число = 100 Тогда Возврат "ста"
		ИначеЕсли Число = 200 Тогда Возврат "двухсот"
		ИначеЕсли Число = 300 Тогда Возврат "трехсот"
		ИначеЕсли Число = 400 Тогда Возврат "четырехсот"
		ИначеЕсли Число = 500 Тогда Возврат "пятисот"
		ИначеЕсли Число = 600 Тогда Возврат "шестисот"
		ИначеЕсли Число = 700 Тогда Возврат "семисот"
		ИначеЕсли Число = 800 Тогда Возврат "восьмисот"
		ИначеЕсли Число = 900 Тогда Возврат "девятисот"
		ИначеЕсли Число = 1000 Тогда Возврат "тысячи"
		Иначе
			
			Сотня 	= Цел(Число / 100) * 100;
			Десятки = Цел((Число - Сотня) / 10) * 10;
			Единицы = Число - Сотня - Десятки;
			
			Возврат СокрЛП(	ПолучитьЧислительноеЧислоПрописью(Сотня) + " " + 
							ПолучитьЧислительноеЧислоПрописью(Десятки) + " " +
							ПолучитьЧислительноеЧислоПрописью(Единицы)); КонецЕсли;
						
	Иначе Возврат ""; КонецЕсли;
	
КонецФункции
Функция ПолучитьКоличествоДнейПрописью(Дней, Прилагательное = "дня, дней", ВначалеЧислоВСкобкахПрописью = Ложь) Экспорт
	
	// Возвращает
	// дней, дня
	
	днейПрописью = ПолучитьЧислительноеЧислоПрописью(Дней);
	Если днейПрописью = "" Тогда Возврат "" Иначе
	
		стрСлов = ПолучитьМассивИзСтроки(Прилагательное,,,Ложь);
		
		ТекстДней = ?(Прав(Формат(Дней,"ЧГ="),1) = "1" И Дней <> 11, СокрЛП(стрСлов[0]), СокрЛП(стрСлов[1]));
		Возврат ?(ВначалеЧислоВСкобкахПрописью,
						строка(Дней) + " (" + днейПрописью + ") " + ТекстДней,
						днейПрописью + " " + ТекстДней); КонецЕсли;
КонецФункции

// ДЛЯ ЗАПРОСОВ

Функция ПолучитьМассивПустыхСсылокДляСоставногоТипа(ОписаниеТипа, ДобавлятьNULL = Ложь, ДобавлятьНеопределено = Ложь) Экспорт
	
	// Возвращает массив в котором перечислены пустые ссылки
	// указанные в составном реквизите (определяется по описанию типа)
	
	МассивПустыхЗначений = Новый Массив;
	
	Для каждого ТипСсылки Из ОписаниеТипа.Типы() Цикл
		
		опТипа = Новый ОписаниеТипов(ТипСсылки);
		МассивПустыхЗначений.Добавить(опТипа.ПривестиЗначение());
		
		//МетаРекв = Метаданные.НайтиПоТипу(ТипСсылки);
		
		//Если Метаданные.Документы.Содержит(МетаРекв) Тогда
		//	
		//	МассивПустыхЗначений.Добавить(Документы[МетаРекв.Имя].ПустаяСсылка());
		//	
		//ИначеЕсли Метаданные.Справочники.Содержит(МетаРекв) Тогда
		//	
		//	МассивПустыхЗначений.Добавить(Справочники[МетаРекв.Имя].ПустаяСсылка());
		//	
		//КонецЕсли;
			
	КонецЦикла; 
	
	Если ДобавлятьNULL Тогда
		МассивПустыхЗначений.Добавить(NULL);
	КонецЕсли; 
	
	Если ДобавлятьНеопределено Тогда
		МассивПустыхЗначений.Добавить(Неопределено);
	КонецЕсли; 
	
	Возврат МассивПустыхЗначений;
		
КонецФункции

Процедура УстановитьПараметрыЗапросаИзСтруктуры(Запрос, ПараметрыСтруктура) Экспорт
	
	// Устанавливает из структуры параметры в запрос
	
	Для Каждого Элемент Из ПараметрыСтруктура Цикл Запрос.УстановитьПараметр(Элемент.Ключ, Элемент.Значение) КонецЦикла;
	
КонецПроцедуры

// КАРТИНКИ

Функция РасширениеКартинки(Картинка) Экспорт
	
	Формат = Картинка.Формат();
	Если Формат = ФорматКартинки.JPEG Тогда
		Возврат "jpg";
	ИначеЕсли Формат = ФорматКартинки.Icon Тогда
		Возврат "ico";
	Иначе
		Возврат НРег(Строка(Формат)); КонецЕсли;
	
КонецФункции



Процедура ЗаполнитьОбъектПоСтруктуреОснованию(Объект, СтруктураЗаполнения) Экспорт
	
	// Заполняет объект по переданной структуре
	// если это шапка тогда это должна быть структура шапкаи
	// если табличная часть то можно передавать
	//  <Имя таблицы> - тип таблица значений
	//	<Имя таблицы + Условие> - строка условие которое будет вызываться на каждую строку таблицы при заполнении
	//								при выполнении этого условия если условие выражение будет ИСТИНА то добват строку
	//	<Имя таблицы + Алгоритм> - строка произвольный алгоритм который будет вызван на каждую строку таблицы при добавлении
	//	
	// Важно!! чтобы порядок параметров в структуре по имени таблицы всегда шло впереди условия или алгоритма
	//			например порядок структуры должна быть: "Товар", "ТоварУсловие" - правильно
	//											но не :  "ТоварУсловие" , "Товар" - не правильно
	
	ТаблЧасти = Новый Структура;
	Для Каждого Элемент Из СтруктураЗаполнения Цикл
		
		ТипЗнч = ТипЗнч(Элемент.Значение);
		Если НРег(Элемент.Ключ) = "шапка" Тогда
			ЗаполнитьЗначенияСвойств(Объект, Элемент.Значение);
			Если Объект.Дата = '00010101' Тогда Объект.Дата = ТекущаяДата() КонецЕсли;
			
		ИначеЕсли ТипЗнч = Тип("ТаблицаЗначений") Или ТипЗнч = Тип("ДанныеФормыКоллекция") Тогда
			ТаблЧасти.Вставить(Элемент.Ключ, Новый Структура("Таблица", Элемент.Значение));
			
		ИначеЕсли ТипЗнч = Тип("Строка") Тогда
			
			Если СтрЗаканчиваетсяНа(НРег(Элемент.Ключ), "алгоритм") Тогда
				ТаблЧасти[Лев(Элемент.Ключ, СтрДлина(Элемент.Ключ) - 8)].ВСтавить("Алгоритм", Элемент.Значение);
			ИначеЕсли СтрЗаканчиваетсяНа(НРег(Элемент.Ключ), "условие") Тогда
				ТаблЧасти[Лев(Элемент.Ключ, СтрДлина(Элемент.Ключ) - 7)].ВСтавить("Условие", Элемент.Значение); КонецЕсли; КонецЕсли; КонецЦикла;
	
	Для Каждого ТаблЧасть Из ТаблЧасти Цикл
		
		Объект[ТаблЧасть.Ключ].Очистить();
		
		Условие 	= "";
		Алгоритм	= "";
	
		ЕстьУсловие 	= ТаблЧасть.Значение.Свойство("Условие", 	Условие);
		ЕстьАлгоритм 	= ТаблЧасть.Значение.Свойство("Алгоритм", 	Алгоритм);
		
		Для Каждого Строка Из ТаблЧасть.Значение.Таблица Цикл 
			Если Не ЕстьУсловие ИЛИ Вычислить(Условие) Тогда
				
				НовСтрока = Объект[ТаблЧасть.Ключ].Добавить();
				ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
				Если ЕстьАлгоритм Тогда Выполнить(Алгоритм) КонецЕсли; КонецЕсли; КонецЦикла; КонецЦикла;

КонецПроцедуры